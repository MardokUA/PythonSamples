<?xml version="1.0" encoding="UTF-8"?>
<data>
<item>
<title>Создание и вызов класса</title>
<content> 
# Создать и связать класс C1
class C1():                     
	# Присвоить: C1.setname
    def setname(self, who):     
		# self – либо I1, либо I2
        self.name = who         
# Создать два экземпляра
I1 = C1()                       
I2 = C1()
# Записать ‘bob’ в I1.name
I1.setname('bob')               
# Записать ‘mel’ в I2.name
I2.setname('mel')         
      
print(I1.name)
print (I2.name)
</content>
<print>
bob
mel
</print>
</item> 
<item>
<title>Наследование</title>
<content> 
class SecondClass:
	# Изменяет display
    def display(self):  
        print('Current value = " % s"' % self.data)
# Наследует SecondClass
class ThirdClass(SecondClass): 
	# Вызывается из ThirdClass(value)
    def __init__(self, value): 
        self.data = value
	
	# Для выражения “self + other”
    def __add__(self, other): 
        return ThirdClass(self.data + other)
	
	# Вызывается из print(self), str()
    def __str__(self): 
        return '[ThirdClass: %s]' % self.data
	# Изменяет сам объект: обычный метод
    def mul(self, other):  
        self.data *= other
# Вызывается новый метод __init__
a = ThirdClass('abc')
# Унаследованный метод  
a.display()  
value = "abc"
# __str__: возвращает строку
print(a)  
# Новый __add__: создается новый экземпляр
b = a + 'xyz'  
b.display()
value = 'abcxyz'
# __str__: возвращает строку
print(b)  
# mul: изменяется сам экземпляр
a.mul(3)  
print(a)
</content>
<print>
Current value = " abc"
[ThirdClass: abc]
Current value = " abcxyz"
[ThirdClass: abcxyz]
[ThirdClass: abcabcabc]
</print>
</item> 
<item>
<title>Добавление атрибутов в класс</title>
<content> 
class Rec: 
    pass
Rec.name = 'name'
y = Rec()
print(y.name)
</content>
<print>
name
</print>
</item> 
<item>
<title>Присваивание функции атрибуту класса</title>
<content> 
class Rec:
    pass
# функция вне класса
def upperName(self):
    return self.name.upper()
# создаем атрибут
Rec.name = 'name'
# создаем экземпляр
y = Rec()
# присваиваем функцию атрибуту класса
Rec.method = upperName
# в каждом созданом экземплре будет атрибут name
print(y.name)
#теперь можно вызывать метод экземпляра
print(y.method())
#либо метод класса,передав ему экземпляр - self
print(Rec.method(y))
</content>
<print>
name
NAME
NAME
</print>
</item> 
<item>
<title>Переопределение методов</title>
<content> 
class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay
		
    def lastName(self):
        return self.name.split()[-1]
		
    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))
		
    def __str__(self):
        return '[Person: %s, %s]' % (self.name, self.pay)
		
		
class Manager(Person):
	'''
	Переопределение метода вызов версии из класса Person
	'''
    def giveRaise(self, percent, bonus=.10):    
        Person.giveRaise(self, percent + bonus) 
                                                
												
if __name__ == '__main__':
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job='dev', pay=100000)
    print(bob)
    print(sue)
    print(bob.lastName(), sue.lastName())
    sue.giveRaise(.10)
    print(sue)
# Экземпляр Manager: __init__
tom = Manager('Tom Jones', 'mgr', 50000)
# Вызов адаптированной версии 
tom.giveRaise(.10) 
# Вызов унаследованного метода
print(tom.lastName()) 
print(tom)
</content>
<print>
[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]
</print>
</item> 
<item>
<title>Переопределение конструкторов</title>
<content> 
class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay
        
    def lastName(self):
        return self.name.split()[-1]
    
    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))
    def __str__(self):
            return '[Person: % s, % s]' % (self.name, self.pay)
class Manager(Person):
	# Переопределенный конструктор
    def __init__(self, name, pay):
		'''
		Вызов оригинального конструктора со значением
		'mgr' в аргументе job
        '''
		Person.__init__(self, name, 'mgr', pay)  
      
        def giveRaise(self, percent, bonus=.10):
            Person.giveRaise(self, percent + bonus)
if __name__ == '__main__':
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job ='dev', pay = 100000)
	
    print(bob)
    print(sue)
    print(bob.lastName(), sue.lastName())
    
	sue.giveRaise(.10)
    
	print(sue)
    
	tom = Manager('Tom Jones', 50000)  
    tom.giveRaise(.10)  
    
	print(tom.lastName())  
    print(tom)
</content>
<print>
[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 55000]
</print>
</item>
<item>
<title>Абстрактные методы</title>
<content> 
class Class1(object):
	# Абстрактный метод
    def test(self, x):     
        # Возбуждаем исключение с помощью raise
        raise NotImplementedError("raise - You need override method")
		
		# Возбуждаем исключение с помощью assert
        #assert False, "assert - You need override method"
# Наследуем абстрактный метод
class Class2(Class1):      
	# Переопределяем метод
    def test(self, x):     
        print(x)
# Класс не переопределяет метод
class Class3(Class1):      
    pass
c2 = Class2()
c2.test(50)               
c3 = Class3()
try:                       	
    c3.test(50)            
except NotImplementedError as msg:
    print(msg)              
except AssertionError as msg:
    print(msg)              
</content>
<print>
50
raise - You need override method
</print>
</item>
<item>
<title>Абстрактные классы</title>
<content> 
from abc import ABCMeta, abstractmethod
class Class1(metaclass=ABCMeta):
	# Абстрактный метод
    @abstractmethod
    def test(self, x):     
        pass
# Наследуем абстрактный метод
class Class2(Class1):      
	# Переопределяем метод
    def test(self, x):     
        print(x)
# Класс не переопределяет метод
class Class3(Class1):      
    pass
c2 = Class2()
c2.test(50)                
c3 = Class3()
c3.test(50)
</content>
<print>
50
TypeError: Can't instantiate abstract class Class3 with abstract methods test
</print>
</item>
<item>
<title>ООП и композиция: взаимосвязи типа «является»</title>
<content>
class Employee:
    def __init__(self, name, salary=0):
        self.name = name
        self.salary = salary
    def giveRaise(self, percent):
        self.salary = self.salary + (self.salary * percent)
    def work(self):
        print(self.name, 'does stuff')
    def __repr__(self):
        return '&lt; Employee: name = % s, salary = % s >' % (self.name, self.salary)
class Chef(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 50000)
    def work(self):
        print(self.name, 'makes food')
class Server(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 40000)
    def work(self):
        print(self.name, 'interfaces with customer')
class PizzaRobot(Chef):
    def __init__(self, name):
        Chef.__init__(self, name)
    def work(self):
        print(self.name, 'makes pizza')
if __name__ == '__main__':
    bob = PizzaRobot('bob')
	
    print(bob)  
    
	bob.work()  
    bob.giveRaise(0.20)  
    
	print(bob);
    print()
    
	for klass in Employee, Chef, Server, PizzaRobot:
        obj = klass(klass.__name__)
        obj.work()
 
</content>
<print>
 Employee: name = bob, salary = 50000 
bob makes pizza
 Employee: name = bob, salary = 60000.0 
Employee does stuff
Chef makes food
Server interfaces with customer
PizzaRobot makes pizza
</print>
</item>
<item>
<title>ООП и композиция: взаимосвязи типа «имеет»</title>
<content> 
class Employee:
    def __init__(self, name, salary=0):
        self.name = name
        self.salary = salary
    def giveRaise(self, percent):
        self.salary = self.salary + (self.salary * percent)
    def work(self):
        print(self.name, 'does stuff')
    def __repr__(self):
        return '&lt; Employee: name = % s, salary = % s >' % (self.name, self.salary)
class Chef(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 50000)
    def work(self):
        print(self.name, 'makes food')
class Server(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 40000)
    def work(self):
        print(self.name, 'interfaces with customer')
class PizzaRobot(Chef):
    def __init__(self, name):
        Chef.__init__(self, name)
    def work(self):
        print(self.name, 'makes pizza')
class Customer:
    def __init__(self, name):
        self.name = name
        
    def order(self, server):
        print(self.name, 'orders from', server)
        
    def pay(self, server):
        print(self.name, 'pays for item to', server)
class Oven:
    def bake(self):
        print('oven bakes')
class PizzaShop:
    def __init__(self):
        self.server = Server('Pat')        
        self.chef   = PizzaRobot('Bob')    
        self.oven  = Oven()
    def order(self, name):
        customer = Customer(name)          
        customer.order(self.server)        
        self.chef.work()
        self.oven.bake()
        customer.pay(self.server)
if __name__ == '__main__':
    scene = PizzaShop()                    
    scene.order('Homer')                   
    print('...')
    scene.order('Shaggy')                  
	
'''
Класс PizzaShop – это контейнер и контроллер – это конструктор, который создает и встраивает экземпляры классов работников, а также экземпляры класса Oven.
Когда вызываетcz метод order класса PizzaShop, встроенным объектам предлагается приступить к выполнению своих обязанностей. Для каждого клиента создается новый 
экземпляр класса Customer и передаем встроенный объект Server(официант) методам класса Customer (клиент) – клиенты приходят и уходят,
а официант остается частью пиццерии. Кроме того, работники по-прежнему вовлечены во взаимосвязи наследования –
композиция и наследование – это взаимодополняющие инструменты.
'''
</content>
<print>
Homer orders from  Employee: name = Pat, salary = 40000 
Bob makes pizza
oven bakes
Homer pays for item to  Employee: name = Pat, salary = 40000 
...
Shaggy orders from  Employee: name = Pat, salary = 40000 
Bob makes pizza
oven bakes
Shaggy pays for item to  Employee: name = Pat, salary = 40000 
</print>
</item>
<item>
<title>Связаные методы</title>
<content> 
class Spam:
    def doit(self, message):
        print(message)
object1 = Spam()
# Обычная ситуация
object1.doit('hello world') 
object1 = Spam()
# Объект связанного метода: экземпляр+функция
x = object1.doit 
# То же, что и object1.doit(‘...’)
x('hello world')  
</content>
<print>
hello world
hello world
</print>
</item>
<item>
<title>Статические методы - staticmethod</title>
<content>
class Class1(object):
	# Статический метод
    @staticmethod
    def sum1(x, y):  
        print(x + y)
	
	# Обычный метод в классе
    def sum2(self, x, y):  
        print( x + y)
	
	# Вызов из метода класса
    def sum3(self, x, y):
        return Class1.sum1(x, y)  
# Вызываем статический метод
Class1.sum1(10, 20)  
c1 = Class1()
# Вызываем метод класса
c1.sum2(15, 6)  
# Вызываем статический метод
# через экземпляр класса
c1.sum1(50, 12)  
# Вызываем статический метод
# внутри класса
c1.sum3(23, 5)  
</content>
<print>
30
21
62
28
</print>
</item>
</data>