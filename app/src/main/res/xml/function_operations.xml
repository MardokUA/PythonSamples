<?xml version="1.0" encoding="UTF-8"?>
<data>
<item>
<title>Определение функции</title>
<content> 
def &lt;name&gt;(arg1, arg2,... argN):
	&lt;statements&gt;
	
	# Если требуется вернуть результат
	return &lt;value&gt;  
</content>
<print>
</print>
</item> 
<item>
<title>Вызов функции</title>
<content> 
def f(x):
    print(x)
# Связывание объекта функции с именем
func = f	
	
# Вызов функции
func(1)			
</content>
<print>
1
</print>
</item> 
<item>
<title>Присоединение атрибутов</title>
<content> 
def f(x):
    print(x)
f.attr = "hello"
print(f.attr)
</content>
<print>
hello
</print>
</item> 
<item>
<title>nonlocal</title>
<content> 
def tester(start):
    state = start
    def nested(label):
		
		# без инструкции nonlocal 
        nonlocal state	
        print(label, state)
        state += 1 
    return nested
F = tester(0)
F('hello')
</content>
<print>
hello
# without nonlocal 
UnboundLocalError: local variable 'state' referenced before assignment
</print>
</item> 
<item>
<title>Рекурсивные функции вычисление суммы</title>
<content> 
def mysum(L):
    if not L:
        return 0
    else:
        return L[0] + mysum(L[1:]) 
L = [1,2,3,4,5]
print(mysum(L))
</content>
<print>
15
</print>
</item> 
<item>
<title>lambda выражения</title>
<content> 
f = lambda x, y, z: x + y + z
result = f(1, 2, 3)
print(result)
L = [lambda x: x**2,
    lambda x: x**3,
    lambda x: x**4]
	
for f in L:
    print(f(2),end=' ')
	
print()
print(L[0](3))
L = [1, 6, 8, 4, 7, 3, 2, 1, 0]
l = lambda x :[y for y in L if y &lt; x]
print(l(5))
</content>
<print>
6
4 8 16 
9
[1, 4, 3, 2, 1, 0]
</print>
</item> 
<item>
<title>Вложенные lambda-выражения </title>
<content> 
def action(x):
	# Создать и вернуть ф-цию, запомнить x
    return (lambda y: x + y) 
act = action(99)
# Вызвать функцию, созданную ф-цией action
print(act(2))       
'''
Эта структура lambda-выражений создает функцию, которая при вызове создает другую функцию. В обоих случаях вложенное lambda-выражение имеет доступ к переменной x в объемлющем lambda-выражении. Этот фрагмент будет работать, но программный код выглядит весьма замысловато, поэтому в интересах соблюдения удобочитаемости лучше избегать использования вложенных друг в друга lambda-выражений.
'''
action = (lambda x: (lambda y: x + y))
act = action(99)
act(3)
print(act(3))
print(((lambda x: (lambda y: x + y))(99))(4))
</content>
<print>
101
</print>
</item> 
<item>
<title>Функция map()</title>
<content> 
counters = [1, 2, 3, 4]
def inc(x): return x + 10 
l = list(map(inc, counters))
print(l) 
m = list(map((lambda x: x + 3), counters))
print(m)
</content>
<print>
[11, 12, 13, 14]
[4, 5, 6, 7]
</print>
</item> 
<item>
<title>Функция filter()</title>
<content> 
L = list(range(-5, 5))
l = list(filter((lambda x: x > 0), range(-5, 5)))
print(l)
l = list(filter(lambda x: x % 2 == 0,L))
print(l)
</content>
<print>
[1, 2, 3, 4]
[-4, -2, 0, 2, 4]
</print>
</item> 
<item>
<title>Функция reduce()</title>
<content> 
'''
reduce может принимать третий необязательный аргумент, который используется в качестве начального значения и служит значением по умолчанию, когда передаваемая последовательность не содержит ни одного элемента
Цепочка вызовов связывается с помощью промежуточного результата (res). Если список пустой, просто используется третий параметр 
x – текущий пункт, а – аккумулятор. Это значение, которое возвращает выполнение lambda на предыдущем пункте. reduce() перебирает все значения, и запускает для каждого lambda на текущих значениях а и х, и возвращает результат в а для следующей итерации.
'''
from functools import reduce
L = [1, 2, 3, 4]
l = reduce((lambda a, x: a + x), L)
print(l)
l =  reduce((lambda a, x: a * x), L)
print(l)
l = reduce(lambda res, x: [x]+res, L, [])
print(l)
</content>
<print>
10
24
[4, 3, 2, 1]
</print>
</item> 
</data>