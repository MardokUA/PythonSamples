<?xml version="1.0" encoding="UTF-8"?>

<data>

<item>
<title>Слияние объектов DataFrame как в базах данных </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                    'data1': range(7)})
df2 = DataFrame({'key': ['a', 'b', 'd'],
                     'data2': range(3)})
print(df1 ,end='\n\n')
print(df2,end='\n\n')
print(pd.merge(df1,df2,on='key'),end='\n\n')
</content>
<print>
   data1 key
0      0   b
1      1   b
2      2   a
3      3   c
4      4   a
5      5   a
6      6   b

   data2 key
0      0   a
1      1   b
2      2   d

   data1 key  data2
0      0   b      1
1      1   b      1
2      6   b      1
3      2   a      0
4      4   a      0
5      5   a      0

</print>
</item>

<item>
<title>Слияние объектов DataFrame как в базах данных (2)</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame({'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                     'data1': range(7)})
df2 = DataFrame({'rkey': ['a', 'b', 'd'],
                     'data2': range(3)})
print(df1 ,end='\n\n')
print(df2,end='\n\n')
print(pd.merge(df1,df2,left_on='lkey', right_on='rkey'),end='\n\n')

# В случае соединения outer попадают так же отсутствующие ключи ,по умолчанию inner
print(pd.merge(df1,df2,left_on='lkey', right_on='rkey',how='outer'),end='\n\n')
</content>
<print>
   data1 lkey
0      0    b
1      1    b
2      2    a
3      3    c
4      4    a
5      5    a
6      6    b

   data2 rkey
0      0    a
1      1    b
2      2    d

   data1 lkey  data2 rkey
0      0    b      1    b
1      1    b      1    b
2      6    b      1    b
3      2    a      0    a
4      4    a      0    a
5      5    a      0    a

   data1 lkey  data2 rkey
0    0.0    b    1.0    b
1    1.0    b    1.0    b
2    6.0    b    1.0    b
3    2.0    a    0.0    a
4    4.0    a    0.0    a
5    5.0    a    0.0    a
6    3.0    c    NaN  NaN
7    NaN  NaN    2.0    d
</print>
</item>

<item>
<title>Слияние объектов DataFrame как в базах данных (3)</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

left = DataFrame({'key1': ['foo', 'foo', 'bar'],
                      'key2': ['one', 'two', 'one'],
                      'lval': [1, 2, 3]})
right = DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],
                       'key2': ['one', 'one', 'one', 'two'],
                       'rval': [4, 5, 6, 7]})
print(left ,end='\n\n')
print(right,end='\n\n')
print(pd.merge(left, right, on=['key1', 'key2'], how='outer'))
</content>
<print>
  key1 key2  lval
0  foo  one     1
1  foo  two     2
2  bar  one     3

  key1 key2  rval
0  foo  one     4
1  foo  one     5
2  bar  one     6
3  bar  two     7

  key1 key2  lval  rval
0  foo  one   1.0   4.0
1  foo  one   1.0   5.0
2  foo  two   2.0   NaN
3  bar  one   3.0   6.0
4  bar  two   NaN   7.0
</print>
</item>

<item>
<title>Слияние по индексу</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

left1 = DataFrame({'key': ['a', 'b', 'a', 'a', 'b', 'c'],
                      'value': range(6)})
right1 = DataFrame({'group_val': [3.5, 7]}, index=['a', 'b'])

print(left1 ,end='\n\n')
print(right1,end='\n\n')
print(pd.merge(left1, right1, left_on='key', right_index=True),end='\n\n')
'''
По умолчанию слияние производится по пересекающимся ключам, но можно вместо пересечения выполнить объединение, указав внешнее соединение
'''
print(pd.merge(left1, right1, left_on='key', right_index=True, how='outer'))
 </content>
<print>
  key1 key2  lval
0  foo  one     1
1  foo  two     2
2  bar  one     3

  key1 key2  rval
0  foo  one     4
1  foo  one     5
2  bar  one     6
3  bar  two     7

  key1 key2_x  lval key2_y  rval
0  foo    one     1    one     4
1  foo    one     1    one     5
2  foo    two     2    one     4
3  foo    two     2    one     5
4  bar    one     3    one     6
5  bar    one     3    two     7

  key  value  group_val
0   a      0        3.5
2   a      2        3.5
3   a      3        3.5
1   b      1        7.0
4   b      4        7.0
5   c      5        NaN
</print>
</item>

<item>
<title>Слияние иерархически индексированных данных </title>
<content>
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

lefth = DataFrame({'key1': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],
                       'key2': [2000, 2001, 2002, 2001, 2002],
                       'data': np.arange(5.)})
righth = DataFrame(np.arange(12).reshape((6, 2)),
                      index=[['Nevada', 'Nevada', 'Ohio', 'Ohio', 'Ohio', 'Ohio'],
                              [2001, 2000, 2000, 2000, 2001, 2002]],
                       columns=['event1', 'event2'])

print(lefth ,end='\n\n')
print(righth,end='\n\n')
'''
В данном случае необходимо перечислить столбцы, по которым производится слияние, в виде списка ( обращайте внимание на обработку повторяющихся зна­чений в индексе): 
'''
print(pd.merge(lefth, righth, left_on=['key1', 'key2'], right_index=True),end='\n\n')
print(pd.merge(lefth, righth, left_on=['key1', 'key2'],right_index=True, how='outer'))
</content>
<print>
   data    key1  key2
0   0.0    Ohio  2000
1   1.0    Ohio  2001
2   2.0    Ohio  2002
3   3.0  Nevada  2001
4   4.0  Nevada  2002

             event1  event2
Nevada 2001       0       1
       2000       2       3
Ohio   2000       4       5
       2000       6       7
       2001       8       9
       2002      10      11

   data    key1  key2  event1  event2
0   0.0    Ohio  2000       4       5
0   0.0    Ohio  2000       6       7
1   1.0    Ohio  2001       8       9
2   2.0    Ohio  2002      10      11
3   3.0  Nevada  2001       0       1

   data    key1  key2  event1  event2
0   0.0    Ohio  2000     4.0     5.0
0   0.0    Ohio  2000     6.0     7.0
1   1.0    Ohio  2001     8.0     9.0
2   2.0    Ohio  2002    10.0    11.0
3   3.0  Nevada  2001     0.0     1.0
4   4.0  Nevada  2002     NaN     NaN
4   NaN  Nevada  2000     2.0     3.0
</print>
</item>

<item>
<title>Тндексы в обоих частях слияния</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

left2 = DataFrame([[1., 2.], [3., 4.], [5., 6.]], index=['a', 'c', 'e'],
                     columns=['Ohio', 'Nevada'])
right2 = DataFrame([[7., 8.], [9., 10.], [11., 12.], [13, 14]],
                      index=['b', 'c', 'd', 'e'], columns=['Missouri', 'Alabama'])

print(left2 ,end='\n\n')
print(right2,end='\n\n')
print(pd.merge(left2, right2, how='outer', left_index=True, right_index=True),end='\n\n')
'''
метод экземпляра join для слияния по индексу. Его также можно использовать для комбинирования нескольких объектов DataFrame,обладающих одинаковыми или похожими  индексами, но непересекающимися столбцами. 
'''
print(left2.join(right2, how='outer'))
</content>
<print>
   Ohio  Nevada
a   1.0     2.0
c   3.0     4.0
e   5.0     6.0

   Missouri  Alabama
b       7.0      8.0
c       9.0     10.0
d      11.0     12.0
e      13.0     14.0

   Ohio  Nevada  Missouri  Alabama
a   1.0     2.0       NaN      NaN
b   NaN     NaN       7.0      8.0
c   3.0     4.0       9.0     10.0
d   NaN     NaN      11.0     12.0
e   5.0     6.0      13.0     14.0

   Ohio  Nevada  Missouri  Alabama
a   1.0     2.0       NaN      NaN
b   NaN     NaN       7.0      8.0
c   3.0     4.0       9.0     10.0
d   NaN     NaN      11.0     12.0
e   5.0     6.0      13.0     14.0
</print>
</item>

<item>
<title>Конкатенация вдоль оси </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

arr = np.arange(12).reshape((3, 4))

print(arr,end='\n\n')
print(np.concatenate([arr, arr], axis=1),end='\n\n')
print(np.concatenate([arr, arr], axis=0))
</content>
<print>
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]

[[ 0  1  2  3  0  1  2  3]
 [ 4  5  6  7  4  5  6  7]
 [ 8  9 10 11  8  9 10 11]]

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</print>
</item>

<item>
<title>concat Series</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame
'''
Можно использовать когда:
Объекты по-разному проиндексированы по другим осям
Нужно иметь возможность идентифицировать группы в результирующем объекте
Имеет значение ось конкатенации
'''
s1 = Series([0, 1], index=['a', 'b'])
s2 = Series([2, 3, 4], index=['c', 'd', 'e'])
s3 = Series([5, 6], index=['f', 'g'])

print(pd.concat([s1, s2, s3]),end='\n\n')
print(pd.concat([s1, s2, s3],axis=1) ,end='\n\n')
print(pd.concat([s1, s1, s3], keys=['one', 'two', 'three']) ,end='\n\n')
print(pd.concat([s1, s2, s3], axis=1, keys=['one', 'two', 'three']) ,end='\n\n')
</content>
<print>
a    0
b    1
c    2
d    3
e    4
f    5
g    6
dtype: int64

     0    1    2
a  0.0  NaN  NaN
b  1.0  NaN  NaN
c  NaN  2.0  NaN
d  NaN  3.0  NaN
e  NaN  4.0  NaN
f  NaN  NaN  5.0
g  NaN  NaN  6.0

one    a    0
       b    1
two    a    0
       b    1
three  f    5
       g    6
dtype: int64

   one  two  three
a  0.0  NaN    NaN
b  1.0  NaN    NaN
c  NaN  2.0    NaN
d  NaN  3.0    NaN
e  NaN  4.0    NaN
f  NaN  NaN    5.0
g  NaN  NaN    6.0
</print>
</item>

<item>
<title>concat DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame(np.arange(6).reshape(3, 2), index=['a', 'b', 'c'],
                   columns=['one', 'two'])

df2 = DataFrame(5 + np.arange(4).reshape(2, 2), index=['a', 'c'],
                    columns=['three', 'four'])
print(pd.concat([df1, df2], axis=1, keys=['level1', 'level2']),end='\n\n')
'''
Если передать не список, а словарь объектов, то роль аргумента keys будут играть ключи словаря: 
'''
print(pd.concat({'level1': df1, 'level2': df2}, axis=1),end='\n\n')
print(pd.concat([df1, df2], axis=1, keys=['level1', 'level2'],names=['upper', 'lower']),end='\n\n')
</content>
<print>
  level1     level2     
     one two  three four
a      0   1    5.0  6.0
b      2   3    NaN  NaN
c      4   5    7.0  8.0

  level1     level2     
     one two  three four
a      0   1    5.0  6.0
b      2   3    NaN  NaN
c      4   5    7.0  8.0

upper level1     level2     
lower    one two  three four
a          0   1    5.0  6.0
b          2   3    NaN  NaN
c          4   5    7.0  8.0
</print>
</item>

<item>
<title>Комбинирование перекрывающихся данных Series</title>
<content> 
'''
два набора данных, индексы которых полностью или частично пересекаются. 
'''
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

a = Series([np.nan, 2.5, np.nan, 3.5, 4.5, np.nan],
               index=['f', 'e', 'd', 'c', 'b', 'a'])

b = Series(np.arange(len(a), dtype=np.float64),
               index=['f', 'e', 'd', 'c', 'b', 'a'])

print(a,end='\n\n')
print(b,end='\n\n')

'''
combine_first подставляет вместо данных, отсутствующих в вызывающем объекте, данные из объекта, переданного в аргументе
'''
print(b[:-2].combine_first(a[2:]) ,end='\n\n')
</content>
<print>
f    NaN
e    2.5
d    NaN
c    3.5
b    4.5
a    NaN
dtype: float64

f    0.0
e    1.0
d    2.0
c    3.0
b    4.0
a    5.0
dtype: float64

a    NaN
b    4.5
c    3.0
d    2.0
e    1.0
f    0.0
dtype: float64
</print>
</item>

<item>
<title>Комбинирование перекрывающихся данных DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame({'a': [1., np.nan, 5., np.nan],
                     'b': [np.nan, 2., np.nan, 6.],
                     'c': range(2, 18, 4)})

df2 = DataFrame({'a': [5., 4., np.nan, 3., 7.],
                     'b': [np.nan, 3., 4., 6., 8.]})

print(df1,end='\n\n')
print(df2,end='\n\n')
print(df1.combine_first(df2),end='\n\n')
</content>
<print>
     a    b   c
0  1.0  NaN   2
1  NaN  2.0   6
2  5.0  NaN  10
3  NaN  6.0  14

     a    b
0  5.0  NaN
1  4.0  3.0
2  NaN  4.0
3  3.0  6.0
4  7.0  8.0

     a    b     c
0  1.0  NaN   2.0
1  4.0  2.0   6.0
2  5.0  4.0  10.0
3  3.0  6.0  14.0
4  7.0  8.0   NaN
</print>
</item>

</data>