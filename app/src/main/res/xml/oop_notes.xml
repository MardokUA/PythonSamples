<?xml version="1.0" encoding="UTF-8"?>
<data>
<item>
<title>
Классы – это основные инструменты объектно-ориентированного программирования (ООП) в языке Python
</title>
<content> 
</content>
<print>
</print>
</item> 
<item>
<title>
Экземпляры представляют конкретные элементы программы. Их атрибуты хранят данные, которые могут отличаться в конкретных объектах
</title>
<content> 
</content>
<print>
</print>
</item> 
<item>
<title>
Методы класса
__name__ — имя класса;
__module__ — имя модуля;
__dict__ — словарь атрибутов класса, можно изменять этот словарь напрямую;
__bases__ — кортеж базовых классов в порядке их следования;
__doc__ — строка документации класса.
__dict__ — словарь атрибутов класса, можно изменять этот словарь напрямую;
__class__ — объект-класс, экземпляром которого является данный инстанс;
__init__ — конструктор. Если в базовом классе есть конструктор, конструктор производного класса должен вызвать его;
__del__ — деструктор. Если в базовом классе есть деструкор, деструктор производного класса должен вызвать его;
__cmp__ — вызывается для всех операций сравнения;
__hash__ — возвращает хеш-значение объекта, равное 32-битному числу;
__getattr__ — возвращает атрибут, недоступный обычным способом;
__setattr__ — присваивает значение атрибуту;
__delattr__ — удаляет атрибут;
__call__ — срабатывает при вызове экземпляра класса.
__len__ — возвращает длину последовательности;
__getitem__ — получение элемента по индексу или ключу;
__setitem__ — присваивание элемента с данным ключом или индексом;
__delitem__ — удаление элемента с данным ключом или индексом;
__getslice__ — возвращает вложенную последовательность;
__setslice__ — заменяет вложенную последовательность;
__delslice__ — удаляет вложенную последовательность;
__contains__ — реализует оператор in.
__repr__ — возвращает формальное строковое представление объекта;
__str__ — возвращает строковое представление объекта;
__oct__ , __hex__ , __complex__ , __int__ , __long__ , __float__ — возвращают строковое представление в соответствующей системе счисления.</title>
<content> 
</content>
<print>
</print>
</item> 
<item>
<title>
__init__			
Конструктор 	
При создании объекта:X = Class(args)
__del__				
Деструктор 		
При уничтожении объекта
__add__				
Оператор + 		
X + Y, X += Y,если отсутствует метод __iadd__ 
__or__ 				
Оператор | (побитовое ИЛИ) 		
X | Y, X |= Y,если отсутствует метод __ior__
__repr__,
__str__				
Вывод, преобразование	
print(X), repr(X), str(X)
__call__ 			
Вызовы функции 			
X(*args, **kargs)
__getattr__ 		
Обращение к атрибуту 	
X.undefined
__setattr__ 		
Присваивание атрибуту	
X.any = value
__delattr__ 		
Удаление атрибута 		
del X.any
__getattribute__	
Обращение к атрибуту	
X.any
__getitem__			
Доступ к элементу по индексу, извлечение среза, итерации			
X[key], X[i:j], циклы for и другие конструкции итерации, при отсутствии метода __iter__
__setitem__ 		
Присваивание элементу по индексу или срезу
X[key] = value, X[i:j] = sequence
__delitem__ 		
Удаление элемента по индексу или среза
del X[key], del X[i:j]
__len__
Длина 					
len(X), проверка истинности, если отсутствует метод __bool__
											
__bool__
Проверка логического значения	
bool(X) , проверка истинности
					
__lt__, __gt__,		 
__le__, __ge__,								
__eq__, __ne__
Сравнивание				
X &lt; Y, X &gt; Y, X &lt;= Y, X >= Y,X == Y, X != Y
__radd__ 			
Правосторонний	оператор +		
Не_экземпляр + X
					
__iadd__ 			
Добавление(увеличение)				
X += Y (в ином случае __add__)
					
__iter__,						 
__next__							 
Итерационный контекст		
I=iter(X), next(I)  циклы for,оператор in (если не определен метод	__contains__), все типы генераторов,map(F, X) и другие
											
__contains__ 		
Проверка на вхождение	
item in X (где X – любой итерируемый объект)
					
__index__ 			
Целое число 			
hex(X), bin(X) , oct(X) , O[X] , O[X:] 
	
__enter__,			
__exit__
Менеджеры контекстов	
with obj as var:
__get__, 			
__set__,
__delete__
Дескрипторы атрибутов	
X.attr, X.attr = value, del X.attr
__new__ 			
Создание 				
Вызывается при создании объектов,перед вызовом метода __init__
</title>
<content> 
</content>
<print>
</print>
</item>
<item>
<title>Инициализатор __init__, вызывается автоматически всякий раз, когда создается новый экземпляр.
# Добавим инициализацию полей записи
class Person:
	# Конструктор принимает 3 аргумента
	def __init__(self, name, job, pay):
		# Заполняет поля при создании
		self.name = name		
		self.job = job 
		self.pay = pay
</title>
<content> 
</content>
<print>
</print>
</item> 
<item>
<title>
Наследование
# Общий суперкласс
class BaseClass:                  
	# Общее поведение
    def computeSalary(self): ...  
    def giveRaise(self): ...
    def promote(self): ...
    def retire(self): 
# Наследуемый класс
class DerivedClass(BaseClass):        
	# Особенная реализация
    def computeSalary(self): ... 	  	
</title>
<content> 
</content>
<print>
</print>
</item> 
<item>
<title>
Чтобы получить доступ к классу, нам необходимо обратиться к модулю, как
обычно:
import person # Импортировать модуль
x = person.Person()  # Класс внутри модуля
Хотя этот способ может показаться избыточным, он совершенно необходим:
имя person.person ссылается на класс person внутри модуля person. Если использовать просто имя person, мы обратимся к модулю, а не к классу кроме случая,
когда используется инструкция from:
from person import Person # Получить класс из модуля
x = Person() 
</title>
<content> 
</content>
<print>
</print>
</item> 
<item>
<title>
# Базовый класс для класса Class2
class Class1:         
    def f_func1(self):
        print ("Метод f_func1() класса Class1")
 
# Класс Class2 наследует класс Class1
class Class2(Class1): 
    def f_func2(self):
        print ("Метод f_func2() класса Class2")
# Класс Class3 наследует класс Class1
class Class3(Class1): 
    def f_func1(self):
        print ("Метод f_func1() класса Class3")
    def f_func2(self):
        print ("Метод f_func2() класса Class3")
    def f_func3(self):
        print ("Метод f_func3() класса Class3")
    def f_func4(self):
        print ("Метод f_func4() класса Class3")
 
# Множественное наследование
class Class4(Class2, Class3): 
    def f_func4(self):
        print ("Метод f_func4() класса Class4")
 
# Создаем экземпляр класса Class4
c1 = Class4()             
# Выведет: Метод f_func1() класса Class1
c1.f_func1()              
# Выведет: Метод f_func2() класса Class2
c1.f_func2()              
# Выведет: Метод f_func3() класса Class3
c1.f_func3()              
# Выведет: Метод f_func4() класса Class4
c1.f_func4()              
метод f_func1() определен в двух классах - Class1 и Class3. Так как класс Class2 стоит первым в списке базовых классов, вначале просматривается этот класс, а затем все его базовые классы. Поэтому метод f_func1() будет найден в классе Class1, а не в классе Class3.
Метод f_func2() также определен в двух классах - Class2 и Class3. Так как класс Class2 стоит первым в списке базовых классов, то метод будет найден именно в этом классе. Чтобы наследовать метод из класса Class3, следует указать это явным образом. Передаем определение класса Class4 из предыдущего примера и наследуем метод f_func2() из класса Class3.
</title>
<content> 
</content>
<print>
</print>
</item> 
<item>
<title>
# Множественное наследование
class Class4(Class2, Class3): 
    # Наследуем f_func2() из класса Class3, а не из класса Class2
    f_func2 = Class3.f_func2
    def f_func4(self):
        print ("Метод f_func4() класса Class4")
Метод f_func3() определен только в классе Class3, поэтому метод наследуется от этого класса. Метод f_func4(), определенный в классе Class3, переопределяется в производном классе. Если метод найден в производном классе, то вся иерархия наследования просматривается не будет.
</title>
<content> 
</content>
<print>
</print>
</item> 
<item>
<title>Не возможно выполнить перегрузку операторов ,так как инструкция def
просто присваивает объект некоторому имени в области видимости класса, сохранено будет только последнее определение метода (это все равно, что записать две инструкции подряд: X = 1, а затем X = 2, в результате чего X будет иметь
значение 2).
</title>
<content> 
</content>
<print>
</print>
</item> 
</data>