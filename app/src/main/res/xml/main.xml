<?xml version="1.0" encoding="UTF-8"?>
<data>

<item>
<id>1</id>
<menu>Pandas</menu>
<submenu>Группировка</submenu>
<title>Группировка по ключам/вычисление среднего/размер</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df = DataFrame({'key1' : ['a', 'a', 'b', 'b', 'a'],
                   'key2' : ['one', 'two', 'one', 'two', 'one'],
                    'data1' : np.random.randn(5),
                    'data2' : np.random.randn(5)})

states = np.array(['Ohio', 'California', 'California', 'Ohio', 'Ohio'])
years = np.array([2005, 2005, 2006, 2005, 2006])

print(df,end='\n\n')
print(df['data1'].groupby(df['key1']).mean(),end='\n\n')
print(df['data1'].groupby([states, years]).mean(),end='\n\n')
print(df.groupby(['key1', 'key2']).size(),end='\n\n')
</content>
<print>
      data1     data2 key1 key2
0 -0.233091  0.052449    a  one
1  1.014173 -0.280138    a  two
2 -0.610911  0.254683    b  one
3  1.557628  0.310622    b  two
4  1.891275  0.456131    a  one

key1
a    0.890786
b    0.473358
Name: data1, dtype: float64

California  2005    1.014173
            2006   -0.610911
Ohio        2005    0.662269
            2006    1.891275
Name: data1, dtype: float64

key1  key2
a     one     2
      two     1
b     one     1
      two     1
dtype: int64
</print>
</item>


<item>
<id>2</id>
<menu>Pandas</menu>
<submenu>Группировка</submenu>
<title>Обход групп</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df = DataFrame({'key1' : ['a', 'a', 'b', 'b', 'a'],
                   'key2' : ['one', 'two', 'one', 'two', 'one'],
                    'data1' : np.random.randn(5),
                    'data2' : np.random.randn(5)})

print(df,end='\n\n')

for name, group in df.groupby('key1'):
     print(name)
     print(group,end='\n\n')

'''
В случае нескольких ключей первым элементом кортежа будет кортеж, содержащий значения ключей
'''
for (k1, k2), group in df.groupby(['key1', 'key2']):
        print (k1, k2)
        print (group,end='\n\n')
</content>
<print>
      data1     data2 key1 key2
0 -0.877496  0.403621    a  one
1  0.170725  2.274369    a  two
2  0.404032 -0.213540    b  one
3  0.780361  0.129255    b  two
4 -1.655188  0.448684    a  one

a
      data1     data2 key1 key2
0 -0.877496  0.403621    a  one
1  0.170725  2.274369    a  two
4 -1.655188  0.448684    a  one

b
      data1     data2 key1 key2
2  0.404032 -0.213540    b  one
3  0.780361  0.129255    b  two

a one
      data1     data2 key1 key2
0 -0.877496  0.403621    a  one
4 -1.655188  0.448684    a  one

a two
      data1     data2 key1 key2
1  0.170725  2.274369    a  two

b one
      data1    data2 key1 key2
2  0.404032 -0.21354    b  one

b two
      data1     data2 key1 key2
3  0.780361  0.129255    b  two
</print>
</item>

<item>
<id>3</id>
<menu>Pandas</menu>
<submenu>Группировка</submenu>
<title>Группировка по уровням индекса </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

columns = pd.MultiIndex.from_arrays([['US', 'US', 'US', 'JP', 'JP'],
                                        [1, 3, 5, 1, 3]], names=['cty', 'tenor'])

hier_df = DataFrame(np.random.randn(4, 5), columns=columns)

print (hier_df,end='\n\n')
print (hier_df.groupby(level='cty', axis=1).count(),end='\n\n')
</content>
<print>
cty          US                            JP          
tenor         1         3         5         1         3
0      0.323779 -0.124714 -0.298186 -1.035420  2.184965
1     -1.671095 -1.399012 -2.199690 -1.637548  0.982262
2      0.389026 -0.036713  0.889183  0.390412  1.004523
3      0.427959  0.895415 -1.054257  0.376230 -0.008952

cty  JP  US
0     2   3
1     2   3
2     2   3
3     2   3
</print>
</item>

<item>
<id>4</id>
<menu>Pandas</menu>
<submenu>Группировка</submenu>
<title>Групповое взвешенное среднее и корреляция </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df = DataFrame({'category': ['a', 'a', 'a', 'a', 'b', 'b', 'b', 'b'],
                    'data': np.random.randn(8),
                    'weights': np.random.rand(8)})

print (df,end='\n\n')
grouped = df.groupby('category')
get_wavg = lambda g: np.average(g['data'], weights=g['weights'])
print (grouped.apply(get_wavg),end='\n\n')
</content>
<print>
  category      data   weights
0        a -0.205636  0.932480
1        a -0.240191  0.342228
2        a  0.701988  0.874741
3        a  0.774522  0.785103
4        b -0.982988  0.406458
5        b -0.019618  0.979014
6        b -1.456669  0.634408
7        b -2.259708  0.952324

category
a    0.323111
b   -1.175843
dtype: float64
</print>
</item>

<item>
<id>5</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Слияние объектов DataFrame как в базах данных </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                    'data1': range(7)})
df2 = DataFrame({'key': ['a', 'b', 'd'],
                     'data2': range(3)})
print(df1 ,end='\n\n')
print(df2,end='\n\n')
print(pd.merge(df1,df2,on='key'),end='\n\n')
</content>
<print>
   data1 key
0      0   b
1      1   b
2      2   a
3      3   c
4      4   a
5      5   a
6      6   b

   data2 key
0      0   a
1      1   b
2      2   d

   data1 key  data2
0      0   b      1
1      1   b      1
2      6   b      1
3      2   a      0
4      4   a      0
5      5   a      0
</print>
</item>

<item>
<id>6</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Слияние объектов DataFrame как в базах данных (2)</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame({'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                     'data1': range(7)})
df2 = DataFrame({'rkey': ['a', 'b', 'd'],
                     'data2': range(3)})
print(df1 ,end='\n\n')
print(df2,end='\n\n')
print(pd.merge(df1,df2,left_on='lkey', right_on='rkey'),end='\n\n')

# В случае соединения outer попадают так же отсутствующие ключи ,по умолчанию inner
print(pd.merge(df1,df2,left_on='lkey', right_on='rkey',how='outer'),end='\n\n')
</content>
<print>
   data1 lkey
0      0    b
1      1    b
2      2    a
3      3    c
4      4    a
5      5    a
6      6    b

   data2 rkey
0      0    a
1      1    b
2      2    d

   data1 lkey  data2 rkey
0      0    b      1    b
1      1    b      1    b
2      6    b      1    b
3      2    a      0    a
4      4    a      0    a
5      5    a      0    a

   data1 lkey  data2 rkey
0    0.0    b    1.0    b
1    1.0    b    1.0    b
2    6.0    b    1.0    b
3    2.0    a    0.0    a
4    4.0    a    0.0    a
5    5.0    a    0.0    a
6    3.0    c    NaN  NaN
7    NaN  NaN    2.0    d
</print>
</item>

<item>
<id>7</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Слияние объектов DataFrame как в базах данных (3)</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

left = DataFrame({'key1': ['foo', 'foo', 'bar'],
                      'key2': ['one', 'two', 'one'],
                      'lval': [1, 2, 3]})
right = DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],
                       'key2': ['one', 'one', 'one', 'two'],
                       'rval': [4, 5, 6, 7]})

					   print(left ,end='\n\n')
print(right,end='\n\n')
print(pd.merge(left, right, on=['key1', 'key2'], how='outer'))
</content>
<print>
  key1 key2  lval
0  foo  one     1
1  foo  two     2
2  bar  one     3

  key1 key2  rval
0  foo  one     4
1  foo  one     5
2  bar  one     6
3  bar  two     7

  key1 key2  lval  rval
0  foo  one   1.0   4.0
1  foo  one   1.0   5.0
2  foo  two   2.0   NaN
3  bar  one   3.0   6.0
4  bar  two   NaN   7.0
</print>
</item>

<item>
<id>8</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Слияние по индексу</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

left1 = DataFrame({'key': ['a', 'b', 'a', 'a', 'b', 'c'],
                      'value': range(6)})
right1 = DataFrame({'group_val': [3.5, 7]}, index=['a', 'b'])

print(left1 ,end='\n\n')
print(right1,end='\n\n')
print(pd.merge(left1, right1, left_on='key', right_index=True),end='\n\n')
'''
По умолчанию слияние производится по пересекающимся ключам, но можно вместо пересечения выполнить объединение, указав внешнее соединение
'''
print(pd.merge(left1, right1, left_on='key', right_index=True, how='outer'))
 </content>
<print>
  key1 key2  lval
0  foo  one     1
1  foo  two     2
2  bar  one     3

  key1 key2  rval
0  foo  one     4
1  foo  one     5
2  bar  one     6
3  bar  two     7

  key1 key2_x  lval key2_y  rval
0  foo    one     1    one     4
1  foo    one     1    one     5
2  foo    two     2    one     4
3  foo    two     2    one     5
4  bar    one     3    one     6
5  bar    one     3    two     7

  key  value  group_val
0   a      0        3.5
2   a      2        3.5
3   a      3        3.5
1   b      1        7.0
4   b      4        7.0
5   c      5        NaN
</print>
</item>

<item>
<id>9</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Слияние иерархически индексированных данных </title>
<content>
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

lefth = DataFrame({'key1': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],
                       'key2': [2000, 2001, 2002, 2001, 2002],
                       'data': np.arange(5.)})
righth = DataFrame(np.arange(12).reshape((6, 2)),
                      index=[['Nevada', 'Nevada', 'Ohio', 'Ohio', 'Ohio', 'Ohio'],
                              [2001, 2000, 2000, 2000, 2001, 2002]],
                       columns=['event1', 'event2'])

print(lefth ,end='\n\n')
print(righth,end='\n\n')
'''
В данном случае необходимо перечислить столбцы, по которым производится слияние, в виде списка ( обращайте внимание на обработку повторяющихся зна­чений в индексе): 
'''
print(pd.merge(lefth, righth, left_on=['key1', 'key2'], right_index=True),end='\n\n')
print(pd.merge(lefth, righth, left_on=['key1', 'key2'],right_index=True, how='outer'))
</content>
<print>
   data    key1  key2
0   0.0    Ohio  2000
1   1.0    Ohio  2001
2   2.0    Ohio  2002
3   3.0  Nevada  2001
4   4.0  Nevada  2002

             event1  event2
Nevada 2001       0       1
       2000       2       3
Ohio   2000       4       5
       2000       6       7
       2001       8       9
       2002      10      11

   data    key1  key2  event1  event2
0   0.0    Ohio  2000       4       5
0   0.0    Ohio  2000       6       7
1   1.0    Ohio  2001       8       9
2   2.0    Ohio  2002      10      11
3   3.0  Nevada  2001       0       1

   data    key1  key2  event1  event2
0   0.0    Ohio  2000     4.0     5.0
0   0.0    Ohio  2000     6.0     7.0
1   1.0    Ohio  2001     8.0     9.0
2   2.0    Ohio  2002    10.0    11.0
3   3.0  Nevada  2001     0.0     1.0
4   4.0  Nevada  2002     NaN     NaN
4   NaN  Nevada  2000     2.0     3.0
</print>
</item>


<item>
<id>10</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Тндексы в обоих частях слияния</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

left2 = DataFrame([[1., 2.], [3., 4.], [5., 6.]], index=['a', 'c', 'e'],
                     columns=['Ohio', 'Nevada'])
right2 = DataFrame([[7., 8.], [9., 10.], [11., 12.], [13, 14]],
                      index=['b', 'c', 'd', 'e'], columns=['Missouri', 'Alabama'])

print(left2 ,end='\n\n')
print(right2,end='\n\n')
print(pd.merge(left2, right2, how='outer', left_index=True, right_index=True),end='\n\n')
'''
метод экземпляра join для слияния по индексу. Его также можно использовать для комбинирования нескольких объектов DataFrame,обладающих одинаковыми или похожими  индексами, но непересекающимися столбцами. 
'''
print(left2.join(right2, how='outer'))
</content>
<print>
   Ohio  Nevada
a   1.0     2.0
c   3.0     4.0
e   5.0     6.0

   Missouri  Alabama
b       7.0      8.0
c       9.0     10.0
d      11.0     12.0
e      13.0     14.0

   Ohio  Nevada  Missouri  Alabama
a   1.0     2.0       NaN      NaN
b   NaN     NaN       7.0      8.0
c   3.0     4.0       9.0     10.0
d   NaN     NaN      11.0     12.0
e   5.0     6.0      13.0     14.0

   Ohio  Nevada  Missouri  Alabama
a   1.0     2.0       NaN      NaN
b   NaN     NaN       7.0      8.0
c   3.0     4.0       9.0     10.0
d   NaN     NaN      11.0     12.0
e   5.0     6.0      13.0     14.0
</print>
</item>

<item>
<id>11</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Конкатенация вдоль оси </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

arr = np.arange(12).reshape((3, 4))

print(arr,end='\n\n')
print(np.concatenate([arr, arr], axis=1),end='\n\n')
print(np.concatenate([arr, arr], axis=0))
</content>
<print>
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]

[[ 0  1  2  3  0  1  2  3]
 [ 4  5  6  7  4  5  6  7]
 [ 8  9 10 11  8  9 10 11]]

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</print>
</item>


<item>
<id>12</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>concat Series</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame
'''
Можно использовать когда:
Объекты по-разному проиндексированы по другим осям
Нужно иметь возможность идентифицировать группы в результирующем объекте
Имеет значение ось конкатенации
'''
s1 = Series([0, 1], index=['a', 'b'])
s2 = Series([2, 3, 4], index=['c', 'd', 'e'])
s3 = Series([5, 6], index=['f', 'g'])

print(pd.concat([s1, s2, s3]),end='\n\n')
print(pd.concat([s1, s2, s3],axis=1) ,end='\n\n')
print(pd.concat([s1, s1, s3], keys=['one', 'two', 'three']) ,end='\n\n')
print(pd.concat([s1, s2, s3], axis=1, keys=['one', 'two', 'three']) ,end='\n\n')
</content>
<print>
a    0
b    1
c    2
d    3
e    4
f    5
g    6
dtype: int64

     0    1    2
a  0.0  NaN  NaN
b  1.0  NaN  NaN
c  NaN  2.0  NaN
d  NaN  3.0  NaN
e  NaN  4.0  NaN
f  NaN  NaN  5.0
g  NaN  NaN  6.0

one    a    0
       b    1
two    a    0
       b    1
three  f    5
       g    6
dtype: int64

   one  two  three
a  0.0  NaN    NaN
b  1.0  NaN    NaN
c  NaN  2.0    NaN
d  NaN  3.0    NaN
e  NaN  4.0    NaN
f  NaN  NaN    5.0
g  NaN  NaN    6.0
</print>
</item>

<item>
<id>13</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>concat DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame(np.arange(6).reshape(3, 2), index=['a', 'b', 'c'],
                   columns=['one', 'two'])

df2 = DataFrame(5 + np.arange(4).reshape(2, 2), index=['a', 'c'],
                    columns=['three', 'four'])

print(pd.concat([df1, df2], axis=1, keys=['level1', 'level2']),end='\n\n')
'''
Если передать не список, а словарь объектов, то роль аргумента keys будут играть ключи словаря: 
'''
print(pd.concat({'level1': df1, 'level2': df2}, axis=1),end='\n\n')
print(pd.concat([df1, df2], axis=1, keys=['level1', 'level2'],names=['upper', 'lower']),end='\n\n')
</content>
<print>
  level1     level2     
     one two  three four
a      0   1    5.0  6.0
b      2   3    NaN  NaN
c      4   5    7.0  8.0

  level1     level2     
     one two  three four
a      0   1    5.0  6.0
b      2   3    NaN  NaN
c      4   5    7.0  8.0

upper level1     level2     
lower    one two  three four
a          0   1    5.0  6.0
b          2   3    NaN  NaN
c          4   5    7.0  8.0
</print>
</item>

<item>
<id>14</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Комбинирование перекрывающихся данных Series</title>
<content> 
'''
два набора данных, индексы которых полностью или частично пересекаются. 
'''
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

a = Series([np.nan, 2.5, np.nan, 3.5, 4.5, np.nan],
               index=['f', 'e', 'd', 'c', 'b', 'a'])

b = Series(np.arange(len(a), dtype=np.float64),
               index=['f', 'e', 'd', 'c', 'b', 'a'])

print(a,end='\n\n')
print(b,end='\n\n')

'''
combine_first подставляет вместо данных, отсутствующих в вызывающем объекте, данные из объекта, переданного в аргументе
'''
print(b[:-2].combine_first(a[2:]) ,end='\n\n')
</content>
<print>
f    NaN
e    2.5
d    NaN
c    3.5
b    4.5
a    NaN
dtype: float64

f    0.0
e    1.0
d    2.0
c    3.0
b    4.0
a    5.0
dtype: float64

a    NaN
b    4.5
c    3.0
d    2.0
e    1.0
f    0.0
dtype: float64
</print>
</item>

<item>
<id>15</id>
<menu>Pandas</menu>
<submenu>Слияние</submenu>
<title>Комбинирование перекрывающихся данных DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame({'a': [1., np.nan, 5., np.nan],
                     'b': [np.nan, 2., np.nan, 6.],
                     'c': range(2, 18, 4)})

df2 = DataFrame({'a': [5., 4., np.nan, 3., 7.],
                     'b': [np.nan, 3., 4., 6., 8.]})

print(df1,end='\n\n')
print(df2,end='\n\n')
print(df1.combine_first(df2),end='\n\n')
</content>
<print>
     a    b   c
0  1.0  NaN   2
1  NaN  2.0   6
2  5.0  NaN  10
3  NaN  6.0  14

     a    b
0  5.0  NaN
1  4.0  3.0
2  NaN  4.0
3  3.0  6.0
4  7.0  8.0

     a    b     c
0  1.0  NaN   2.0
1  4.0  2.0   6.0
2  5.0  4.0  10.0
3  3.0  6.0  14.0
4  7.0  8.0   NaN
</print>
</item>

<item>
<id>16</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Series – это проиндексированный одномерный массив значений. Он похож на простой словарь типа dict, где имя элемента будет соответствовать индексу, а значение – значению записи.
DataFrame — это проиндексированный многомерный массив значений, соответственно каждый столбец DataFrame, является структурой Series.
Panel - трехмерный аналог DataFrame,соответственно каждый столбец Panel, является структурой DataFrame
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>17</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Аргументы конструктора DataFrame

Двумерный ndarray  		Матрица данных, дополнительно можно передать метки строк и столбцов 

Словарь массивов, 		
списков, кортежей 		Каждая последовательность становится столбцом объекта DataFrame. Все последовательности должны быть одинаковой длины 

Структурный массив 
NumPy 					Интерпретируется так же, как «словарь массивов» 

Словарь объектов Series Каждое значение становится столбцом. Если индекс явно не задан, то индексы объектов Series объединяются и образуют индекс строк результата 

Словарь словарей 		Каждый внутренний словарь становится столбцом. Ключи объединяются и образуют индекс строк, как в случае «словаря объектов Series» 

Список словарей или 
объектов Series 		Каждый элемент списка становится строкой объекта DataFrame. Объединение ключей словаря или индексов объектов Series становится множеством меток столбцов DataFrame 

Список списков или 
кортежей 				Интерпретируется так же, как «двумерный ndarray» 

Другой объект DataFrame Используются индексы DataFrame, если явно не заданы другие индексы 

Объект NumPy MaskedArray  Как «двумерный ndarray» с тем отличием, что замаскированные значения становятся отсутствующими в результирующем объекте  DataFrame 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>18</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Методы и свойства объекта lndex 

append 			Конкатенирует с дополнительными индексными объектами, порождая новый объект lndex 

diff 			Вычисляет теоретико-множественную разность, представляя ее в виде индексного объекта 

intersection 	Вычисляет теоретико-множественное пересечение 

union 			Вычисляет теоретико-множественное объединение 

isin 			Вычисляет булев массив, показывающий, содержится ли каждое значение индекса в переданной коллекции 

delete 			Вычисляет новый индексный объект, получающийся после удаления элемента с индексом i 

drop			Вычисляет новый индексный объект, получающийся после удаления переданных значений 

insert 			Вычисляет новый индексный объект, получающийся после вставки элемента в позицию с индексом i 

is_monotonic 	Возвращает True, если каждый элемент больше или равен предыдущему 

is_unique 		Возвращает True, eсли в индексе нет повторяющихся значений 

unique 			Вычисляет массив уникальных значений в индексе 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>19</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Значение параметра method функции reindex (интерполяция) 

ffill или pad 	Восполнить (или перенести) значения в прямом направлении 

Ьfill или backfill Восполнить (или перенести) значения в обратном направлении 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>20</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Аргументы функции reindex 

index 			Последовательность, которая должна стать новым индексом. Может быть экземпляром Index или любой другой структурой данных Python, похожей на последовательность. Экземпляр Index будет использован «как есть», без копирования 

method 			Метод интерполяции (восполнения),возможные значения приведены выше

fill_value		Значение, которой должно подставляться вместо отсутствующих значений, появляющихся в результате переиндексации 

limit 			При прямом или обратном восполнении максимальная длина восполняемой лакуны 

level 			Сопоставить с простым объектом Index на указанном уровне Multiindex, иначе выбрать подмножество 

сору 			Не копировать данные, если новый индекс эквивалентен старому. По умолчанию True (т. е. всегда копировать данные) 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>21</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Варианты доступа по индексу для объекта DataFrame 

obj [val]		Выбрать один столбец или последовательность столбцов из DataFrame. Частные случаи: булев массив (фильтрация строк), срез (вырезание строк) или булев DataFrame (установка значений в позициях, удовлетворяющих некоторому критерию) 

obj.ix [val]	Выбрать одну строку или подмножество строк из DataFrame 

obj.ix[:, val]	Выбрать один столбец или подмножество столбцов  

obj.ix[vall, val2]	Выбрать строки и столбцы  

reindex		 	(метод)Привести одну или несколько осей в соответствие с новыми индексами 

хs		 		(метод)ыбрать одну строку или столбец по метке и вернуть объект Series 

icol, irow		(метод)Выбрать одну строку или столбец соответственно по целочисленному номеру и вернуть объект Series  

get_value, set_value	 Выбрать одно значение по меткам строки и столбца 

</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>22</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Арифметические методы 

add			Сложение(+)

sub			Вычитание(-)

div			Деление(/)

mul			Умножение(*)
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>23</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Ранжирование

average		По умолчанию: одинаковым значениям присвоить средний ранг

min			Всем элементам группы присвоить минимальный ранг

max			Всем элементам группы присвоить максимальный ранг

first		Присваивать ранги в порядке появления значений в наборе данных
</title>
<content> 
Описательный и сводные статистики

count 		Количество значений, исключая отсутствующие 

describe 	Вычисляет набор сводных статистик для Series или для каждого столбца DataFrame 

min, max	Вычисляет минимальное или максимальное значение 

argmin, argmax 	Вычисляет позицию в индексе (целые числа), при котором достигается минимальное или максимальное значение соответственно 

idxmin, idxmax 	Вычисляет значение индекса, при котором достигается минимальное или максимальное значение соответственно 

quantile 	Вычисляет выборочный квантиль в диапазоне от 0 до 1

sum 		Сумма значений  

median 		Медиана (50%-ый квантиль) 

mad 		Среднее абсолютное отклонение от среднего 

var 		Выборочная дисперсия 

std 		Выборочное стандартное отклонение 

skew 		Асимметрия (третий момент) 

kurt 		Куртозис (четвертый момент) 

cumsum 		Нарастающая сумма  

cummin, cummax 	Нарастающий минимум или максимум соответственно

cumprod 	Нарастающее произведение 

diff 		Первая арифметическая разность (полезно для временных рядов) 

pct_change	Вычисляет процентное изменение 
</content>
<print>
</print>
</item>


<item>
<id>24</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Уникальные значения, счетчики значений и методы «раскладывания» 

isin 		Вычисляет булев массив, показывающий, содержится ли каждое принадлежащее Series значение в переданной последовательности 

unique 		Вычисляет массив уникальных значений в Series и возвращает их в порядке появления 

value_counts 	Возвращает объект Series, который содержит уникальное значение в качестве индекса и его частоту в качестве соответствующего значения. Отсортирован в порядке убывания частот 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>25</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Методы обработки отсутствующих данных 

dropna 		Фильтрует метки оси в зависимости от того, существуют ли для метки отсутствующие данные, причем есть возможность указать различные пороги, определяющие, какое количество отсутствующих данных считать допустимым 

fillna 		Восполняет отсутствующие данные указанным значением или использует какой-нибудь метод интерполяции, например ffill или bfill

isnull 		Возвращает объект, содержащий булевы значения, которые показывают, какие значения отсутствуют  

notnull 	Логическое отрицание isnull 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>26</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Аргументы метода fillna 

value 		Скалярное значение или похожий на словарь объект для восполнения отсутствующих значений 

method 		Метод интерполяции. По умолчанию, если не задано других аргументов, предполагается метод ffill

axis 		Ось, по которой производится восполнение. По умолчанию axis=0

inplace 	Модифицировать исходный объект, не создавая копию 

limit 		Для прямого и обратного восполнения максимальное количество непрерывных заполняемых промежутков 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>27</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Функции чтения в pandas 

read_csv 		Загружает данные с разделителями из файла, URL-aдpeca или похожего на файл объекта. По умолчанию разделителем является запятая 

read_taЬle 		Загружает данные с разделителями из файла, URL-aдpeca или похожего на файл объекта. По умолчанию разделителем является символ табуляции ('\t') 

read_fwf 		Читает данные в формате с фиксированной шириной столбцов (без разделителей) 

read_clipboard 	Вариант read_taЬle, который читает данные из буфера обмена. Полезно для преобразования в таблицу данных на веб-странице 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>28</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Аргументы функций read_csv и read_table

path 		 	Строка, обозначающая путь в файловой системе, URL-aдpec или похожий на файл объект 

sep или 
delimiter 		Последовательность символов или регулярное выражение, служащее для разделения полей в строке 

header 			Номер строки, содержащей имена столбцов. По умолчанию равен 0 (первая строка). Если строки-заголовка нет, должен быть равен None 

index_col 		Номера или имена столбцов, трактуемых как индекс строк в результирующем объекте. Может быть задан один номер (имя) или список номеров (имен), определяющий иерархический индекс 

names 			Список имен столбцов результирующего объекта, задается, если header=None 

skiprows 		Количество игнорируемых начальных строк или список номеров игнорируемых строк (нумерация начинается с 0) 

na_values		 Последовательность значений, интерпретируемых как маркеры отсутствующих данных 

comment 		Один или несколько символов, начинающих комментарий, который продолжается до конца строки 

parse_dates 	Пытаться разобрать данные как дату и время; по умолчанию False. Если равен True, то производится попытка разобрать все столбцы. Можно также задать список столбцов, которые следует объединить перед разбором (если, например, время и даты заданы в разных столбцах) 

keep_date_col 	В случае, когда для разбора данных столбцы объединяются, следует ли отбрасывать объединенные столбцы. По умолчанию тrue 

converters 		Словарь, содержащий  отображение номеров или имен столбцов на функции. Например, {'foo':f} означает, что нужно применить функцию f ко всем значением в столбце foo 

dayfirst 		При разборе потенциально неоднозначных дат предполагать международный формат (т. е. 7 /6/2012 означает «7 июня 2012»). По умолчанию False 

date_parser 	Функция, применяемая для разбора дат 

nrows 			Количество читаемых строк от начала файла 

iterator 		Возвращает объект 'TextParser для чтения файла порциями 

chunksize 		Размер порции при итерировании 

skip_footer 	Сколько строк в конце файла игнорировать 

verbose 		Печатать разного рода информацию о ходе разбора, например, количество отсутствующих значений, помещенных в нечисловые столбцы 

encoding 		Кодировка текста в случае Unicode. Например, 'utf-8'  означает, что текст представлен в кодировке UTF-8 

squeeze 		Если в результате разбора данных оказалось, что имеется только один столбец,  вернуть объект Series 

thousands 		Разделитель тысяч, например, ',' или '.' 	
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>29</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Аргументы функции merge 

left 			Объект DataFrame в левой части операции слияния 

right 			Объект DataFrame в правой части операции слияния 

how 			Допустимые значения: 'inner', 'outer', 'left', 'right '. 

on				Имена столбцов, по которым производится соединение. Должны присутствовать в обоих объектах DataFrame. Если не заданы и не указаны никакие другие ключи соединения, то используются имена столбцов, общих для обоих объектов 

left_on 		Столбцы левого DataFrame, используемые как ключи соединения 

right_on 		Столбцы правого DataFrame, используемые как ключи соединения 

left_index 		Использовать индекс строк левого DataFrame в качестве его ключа соединения (или нескольких ключей в случае мультииндекса) 

right_index 	То же, что left_index, но для правого DataFrame 

sort 			Сортировать слитые данные лексикографически по ключам соединения; по умолчанию True. Иногда при работе с большими наборами данных лучше отключить 

suffixes 		Кортеж строк, которые дописываются в конец совпадающих имен столбцов; по умолчанию ('_х',·_у').Например, если в обоих объектах DataFrame встречается столбец 'data',то в результирующем объекте появятся столбцы 'data_x' и 'data_y' 

copy			Если равен False, то в некоторых особых случаях разрешается не копировать данные в результирующую структуру. По умолчанию данные копируются всегда 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>30</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Аргументы функции concat 

objs 			Список или словарь конкатенируемых объектов pandas. Единственный обязательный аргумент. 

axis 			Ось, вдоль которой производится конкатенация, по умолчанию 0 
				
join 			Допустимые значения: inner outer , по умолчанию  outer следует ли пересекать (inner) или объединять (outer) индексы вдоль других осей. 
				
join_axes		Какие конкретно индексы использовать для других n-1 осей вместо выполнения пересечения или объединения 
				
keys 			Значения, которые ассоциируются с конкатенируемыми объектами и образуют иерархический индекс вдоль оси конкатенации. Может быть список или массив произвольных значений, а также массив кортежей или список массивов (если в параметре levels передаются массивы для нескольких уровней) 

levels 			Конкретные индексы, которые используются на одном или нескольких уровнях иерархического индекса, если задан параметр keys 

names 			Имена создаваемых уровней иерархического индекса, если заданы параметры keys и (или) levels 

verify_integrity	Проверить новую ось в конкатенированном объекте на наличие дубликатов и, если они имеются, возбудить исключение. По умолчанию False -дубликаты разрешены 

ignore_index 	Не сохранять индексы вдоль оси конкатенации, а вместо этого создать новый индекс range (total_length) 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>31</id>
<menu>Pandas</menu>
<submenu>Заметки</submenu>
<title>
Оптимизированные функции агрегирования 

count 		Количество отличных от NA значений в группе 

sum 		Сумма отличных от NA значений 

mean 		Среднее отличных от NA значений 

median 		Медиана отличных от NA значений 

std,var 	Несмещенное ( со знаменателем п -1 )  стандартное отклонение и дисперсия 

min,max		Минимальное и максимальное отличное от NA значение

prod 		Произведение отличных от NA значений

first,last 	Первое и последнее отличное от NA значение 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>32</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Oбъект Series</title>
<content> 
from pandas import Series, DataFrame

data = [4, 7, -5,  3]
index = ['a','b','c','d']
obj = Series(data=data,index=index)

print(obj, end='\n\n')
print(obj.values)
print(obj.index)
</content>
<print>
a    4
b    7
c   -5
d    3
dtype: int64

[ 4  7 -5  3]
Index(['a', 'b', 'c', 'd'], dtype='object')
</print>
</item>

<item>
<id>33</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Изменение Series</title>
<content> 
from pandas import Series, DataFrame

data = [4, 7, -5,  3]
index = ['a', 'b', 'c', 'd']
obj = Series(data=data,index=index)
obj['d'] = 0

print(obj, end='\n\n')
</content>
<print>
a    4
b    7
c   -5
d    0
dtype: int64
</print>
</item>

<item>
<id>34</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Фильтрация по значениям</title>
<content> 
'''
Фильтрация с помощью булева масси­ва, скалярное умножение или применение математических функций, сохраняют связь между индексом и значением
'''
from pandas import Series, DataFrame

data = [4, 7, -5,  3]
index = ['a', 'b', 'c', 'd']
obj = Series(data=data,index=index)

print(obj[obj > 0], end='\n\n')
</content>
<print>
a    4
b    7
d    3
dtype: int64
</print>
</item>

<item>
<id>35</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Изменение значений по условиям</title>
<content> 
from pandas import Series, DataFrame

data = [4, 7, -5,  3]
index = ['a', 'b', 'c', 'd']
obj = Series(data=data,index=index)
obj[obj > 0] = 100

print(obj, end='\n\n')
</content>
<print>
a    100
b    100
c     -5
d    100
dtype: int64
</print>
</item>


<item>
<id>36</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Математические операции</title>
<content> 
'''
Фильтрация с помощью булева масси­ва, скалярное умножение или применение математических функций, сохраняют связь между индексом и значением
'''
from pandas import Series, DataFrame

data = [4, 7, -5,  3]
index = ['a', 'b', 'c', 'd']
obj = Series(data=data,index=index)

print(obj * 2, end='\n\n')
print(obj + 2, end='\n\n')
print(obj / 2, end='\n\n')
print(obj - 2, end='\n\n')
</content>
<print>
a     8
b    14
c   -10
d     6
dtype: int64

a    6
b    9
c   -3
d    5
dtype: int64

a    2.0
b    3.5
c   -2.5
d    1.5
dtype: float64

a    2
b    5
c   -7
d    1
dtype: int64
</print>
</item>

<item>
<id>37</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Проверка на вхождение</title>
<content> 
from pandas import Series, DataFrame

data = [4, 7, -5,  3]
index = ['a', 'b', 'c', 'd']
obj = Series(data=data,index=index)

print('b' in obj)
print('e' in obj)
print(4 in obj.values)
print(2 in obj.values)
</content>
<print>
True
False
True
False
</print>
</item>

<item>
<id>38</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Создание Series из словаря</title>
<content> 
from pandas import Series, DataFrame

data = {'Ohio':  35000,  'Texas':  71000,  'Oregon':  16000,  'Utah':  5000}
obj = Series(data=data)

print(obj)
</content>
<print>
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
</print>
</item>

<item>
<id>39</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Нахождение NaN </title>
<content> 
import pandas as pd
from pandas import Series, DataFrame

data = {'Ohio':  None,  'Texas':  71000,  'Oregon':  16000,  'Utah':  5000}
obj = Series(data=data)

print(pd.isnull(obj), end='\n\n')
print(pd.notnull(obj), end='\n\n')
print(obj.isnull, end='\n\n')
print(obj.notnull, end='\n\n')
</content>
<print>
Ohio       True
Oregon    False
Texas     False
Utah      False
dtype: bool

Ohio      False
Oregon     True
Texas      True
Utah       True
dtype: bool

&lt;bound method NDFrame.isnull of Ohio          NaN
Oregon    16000.0
Texas     71000.0
Utah       5000.0
dtype: float64&gt;

&lt;bound method NDFrame.notnull of Ohio          NaN
Oregon    16000.0
Texas     71000.0
Utah       5000.0
dtype: float64&gt;
</print>
</item>


<item>
<id>40</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Аттрибут name</title>
<content> 
from pandas import Series, DataFrame

data = {'Ohio':  None,  'Texas':  71000,  'Oregon':  16000,  'Utah':  5000}
obj = Series(data=data)
obj.name = 'population'
obj.index.name = 'states'

print(obj, end='\n\n')
</content>
<print>
states
Ohio          NaN
Oregon    16000.0
Texas     71000.0
Utah       5000.0
Name: population, dtype: float64
</print>
</item>

<item>
<id>41</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Создание DataFrame</title>
<content> 
from pandas import Series, DataFrame

data ={ 'state':  [   'Ohio',  'Ohio' ,   'Ohio',  'Nevada',  'Nevada'] ,
        'year':[2000,2001,2002,2001,2002],
        ' рор ' :  [ 1.5 ,  1.7 ,  3.6 ,  2.4 ,  2.9 ] }
frame =  DataFrame(data)

print(frame, end='\n\n')
</content>
<print>    
	 рор    state year
0    1.5    Ohio  2000
1    1.7    Ohio  2001
2    3.6    Ohio  2002
3    2.4  Nevada  2001
4    2.9  Nevada  2002
</print>
</item>

<item>
<id>42</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Создание DataFrame (2)</title>
<content> 
from pandas import Series, DataFrame

'''
Ключи внешнего словаря будут интерпретированы как столбцы, а ключи внутреннего словаря - как индексы строк
'''
op  = {'Nevada':{2001:2.4,2002:2.9},
       'Ohio':{2000:1.5,2001:1.7,2002:3.6}}

frame =  DataFrame(op)

print(frame,end='\n\n')
print(frame.T,end='\n\n')
</content>
<print>
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6

        2000  2001  2002
Nevada   NaN   2.4   2.9
Ohio     1.5   1.7   3.6
</print>
</item>

<item>
<id>43</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Изменение порядка столбцов</title>
<content> 
from pandas import Series, DataFrame

data ={ 'state':  [   'Ohio',  'Ohio' ,   'Ohio',  'Nevada',  'Nevada'] ,
        'year':[2000,2001,2002,2001,2002],
        'pop' :  [ 1.5 ,  1.7 ,  3.6 ,  2.4 ,  2.9 ]}
frame =  DataFrame(data)

print(frame, end='\n\n')

frame =  DataFrame(data, columns=['year','state','pop'])

print(frame, end='\n\n')
</content>
<print>
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002

   year   state  pop
0  2000    Ohio  1.5
1  2001    Ohio  1.7
2  2002    Ohio  3.6
3  2001  Nevada  2.4
4  2002  Nevada  2.9
</print>
</item>

<item>
<id>44</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Изменение значений столбцов</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data ={ 'state':  [   'Ohio',  'Ohio' ,   'Ohio',  'Nevada',  'Nevada'] ,
        'year':[2000,2001,2002,2001,2002],
        'popl' :  [ 1.5 ,  1.7 ,  3.6 ,  2.4 ,  2.9 ]}
frame =  DataFrame(data)
frame['popl'] = 22

print(frame, end='\n\n')

frame.popl = 33

print(frame, end='\n\n')

frame.popl = np.arange(5.)

print(frame, end='\n\n')
</content>
<print>
   popl   state  year
0    22    Ohio  2000
1    22    Ohio  2001
2    22    Ohio  2002
3    22  Nevada  2001
4    22  Nevada  2002

   popl   state  year
0    33    Ohio  2000
1    33    Ohio  2001
2    33    Ohio  2002
3    33  Nevada  2001
4    33  Nevada  2002

   popl   state  year
0   0.0    Ohio  2000
1   1.0    Ohio  2001
2   2.0    Ohio  2002
3   3.0  Nevada  2001
4   4.0  Nevada  2002
</print>
</item>

<item>
<id>45</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Доступ к строкам DataFrame</title>
<content> 
from pandas import Series, DataFrame

data ={ 'state':  ['Ohio',  'Ohio' ,   'Ohio',  'Nevada',  'Nevada'] ,
        'year':[2000,2001,2002,2001,2002],
        'popl' :  [ 1.5 ,  1.7 ,  3.6 ,  2.4 ,  2.9 ]}
index = ['one','two','three','four','five']
frame =  DataFrame(data,index=index)

print(frame.ix['three'], end='\n\n')
print(frame.ix['three'].popl)
print(frame.ix['three']['state'])
</content>
<print>
popl      3.6
state    Ohio
year     2002
Name: three, dtype: object

3.6
Ohio
</print>
</item>

<item>
<id>46</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Вставка Series в DataFrame</title>
<content> 
from pandas import Series, DataFrame
'''
Если присваивается объект Series, то он будет точно согласован с индексом DataFrame, а в дырки будут вставлены значения NaN
'''
data ={ 'state':  ['Ohio',  'Ohio' ,   'Ohio',  'Nevada',  'Nevada'] ,
        'year':[2000,2001,2002,2001,2002],
        'popl' :  [ 1.5 ,  1.7 ,  3.6 ,  2.4 ,  2.9 ]}
index = ['one','two','three','four','five']
frame =  DataFrame(data,index=index)

print(frame,end='\n\n')

series = Series(data = [2.5,6,1.2],index=['two','four','five'])

frame['popl'] = series

print(frame)
</content>
<print>
       popl   state  year
one     1.5    Ohio  2000
two     1.7    Ohio  2001
three   3.6    Ohio  2002
four    2.4  Nevada  2001
five    2.9  Nevada  2002

       popl   state  year
one     NaN    Ohio  2000
two     2.5    Ohio  2001
three   NaN    Ohio  2002
four    6.0  Nevada  2001
five    1.2  Nevada  2002
</print>
</item>

<item>
<id>47</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Удаление столбцов DataFrame</title>
<content> 
from pandas import Series, DataFrame

data ={ 'state':  ['Ohio',  'Ohio' ,   'Ohio',  'Nevada',  'Nevada'] ,
        'year':[2000,2001,2002,2001,2002],
        'popl' :  [ 1.5 ,  1.7 ,  3.6 ,  2.4 ,  2.9 ]}
index = ['one','two','three','four','five']
frame =  DataFrame(data,index=index)

print(frame,end='\n\n')

del frame['popl']

print(frame)
</content>
<print>
       popl   state  year
one     1.5    Ohio  2000
two     1.7    Ohio  2001
three   3.6    Ohio  2002
four    2.4  Nevada  2001
five    2.9  Nevada  2002

        state  year
one      Ohio  2000
two      Ohio  2001
three    Ohio  2002
four   Nevada  2001
five   Nevada  2002
</print>
</item>

<item>
<id>48</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Переиндексация</title>
<content> 
from pandas import Series, DataFrame
'''
данные будут реорганизованы в соответствии с новым индексом, а если каких-то из имеющихся в этом индексе значений раньше не было, то вместо них будут подставлены отсутствующие значения
'''
obj = Series([4.5, 7.2, -5.3, 3.6], index=['d', 'b', 'a', 'c'])

print(obj,end='\n\n')

obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e'],fill_value=0)

print(obj2,end='\n\n')
</content>
<print>
d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64

a   -5.3
b    7.2
c    3.6
d    4.5
e    0.0
dtype: float64
</print>
</item>

<item>
<id>49</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Интерполяция - восполнение отсутствующих значений в процессе переиндексации. </title>
<content> 
from pandas import Series, DataFrame

obj = Series(['blue', 'purple', 'yellow'], index=[0, 2, 4])

print(obj,end='\n\n')

obj2 = obj.reindex(range(6), method='ffill')

print(obj2,end='\n\n')
</content>
<print>
0      blue
2    purple
4    yellow
dtype: object

0      blue
1      blue
2    purple
3    purple
4    yellow
5    yellow
dtype: object
</print>
</item>


<item>
<id>50</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Удаление элементов из оси (Series)</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

obj = Series(np.arange(5.), index=['a', 'b', 'c', 'd', 'e'])

print(obj,end='\n\n')

new_obj = obj.drop(['c','d'])

print(new_obj,end='\n\n')
</content>
<print>
a    0.0
b    1.0
c    2.0
d    3.0
e    4.0
dtype: float64

a    0.0
b    1.0
e    4.0
dtype: float64
</print>
</item>

<item>
<id>51</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Удаление элементов из оси (DataFrame)</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = DataFrame(np.arange(16).reshape((4, 4)),
                  index=['Ohio', 'Colorado', 'Utah', 'New York'],
                  columns=['one', 'two', 'three', 'four'])

print(data,end='\n\n')
print(data.drop(['Colorado','New York'],axis=0),end='\n\n')
print(data.drop(['one','two'],axis=1),end='\n\n')
</content>
<print>
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

      one  two  three  four
Ohio    0    1      2     3
Utah    8    9     10    11

          three  four
Ohio          2     3
Colorado      6     7
Utah         10    11
New York     14    15
</print>
</item>

<item>
<id>52</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Доступ по индексу, выборка и фильтрация </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

obj = Series(np.arange(4.), index=['a', 'b', 'c', 'd'])

print(obj['b'])
print(obj[1])
print(obj[2:4],end='\n\n')
print(obj[['b', 'a', 'd']],end='\n\n')
print(obj[[1, 3]],end='\n\n')
print(obj[obj &lt; 2],end='\n\n')

obj['b':'c'] = 5

print(obj,end='\n\n')
</content>
<print>
1.0
1.0
c    2.0
d    3.0
dtype: float64

b    1.0
a    0.0
d    3.0
dtype: float64

b    1.0
d    3.0
dtype: float64

a    0.0
b    1.0
dtype: float64

a    0.0
b    5.0
c    5.0
d    3.0
dtype: float64
</print>
</item>

<item>
<id>53</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Достцп к индексам DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = DataFrame(np.arange(16).reshape((4, 4)),
                  index=['Ohio', 'Colorado', 'Utah', 'New York'],
                  columns=['one', 'two', 'three', 'four'])

print(data,end='\n\n')
print(data[['one','three']],end='\n\n')
print(data[data['two']>5],end='\n\n')
</content>
<print>
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

          one  three
Ohio        0      2
Colorado    4      6
Utah        8     10
New York   12     14

          one  two  three  four
Utah        8    9     10    11
New York   12   13     14    15
</print>
</item>

<item>
<id>54</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Проверка DataFrame по условиям</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = DataFrame(np.arange(16).reshape((4, 4)),
                  index=['Ohio', 'Colorado', 'Utah', 'New York'],
                  columns=['one', 'two', 'three', 'four'])

print(data &lt; 5,end='\n\n')

data[data &lt; 5] = 0

print(data,end='\n\n')
</content>
<print>
            one    two  three   four
Ohio       True   True   True   True
Colorado   True  False  False  False
Utah      False  False  False  False
New York  False  False  False  False

          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
</print>
</item>


<item>
<id>55</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Срезы DataFrame,условия</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = DataFrame(np.arange(16).reshape((4, 4)),
                  index=['Ohio', 'Colorado', 'Utah', 'New York'],
                  columns=['one', 'two', 'three', 'four'])

print(data,end='\n\n')
print(data.ix[:2,:3] ,end='\n\n')
print(data.ix[data.three > 5,:3] ,end='\n\n')
</content>
<print>
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

          one  two  three
Ohio        0    1      2
Colorado    4    5      6

          one  two  three
Colorado    4    5      6
Utah        8    9     10
New York   12   13     14
</print>
</item>

<item>
<id>56</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Арифметические операции </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df1 = DataFrame(np.arange(12.).reshape((3, 4)), columns=list('abcd'))
df2 = DataFrame(np.arange(20.).reshape((4, 5)), columns=list('abcde'))

print(df1.add(df2,fill_value = 0),end='\n\n')
print(df1.sub(df2,fill_value = 0),end='\n\n')
print(df1.div(df2,fill_value = 0),end='\n\n')
print(df1.mul(df2,fill_value = 0),end='\n\n')
</content>
<print>
      a     b     c     d     e
0   0.0   2.0   4.0   6.0   4.0
1   9.0  11.0  13.0  15.0   9.0
2  18.0  20.0  22.0  24.0  14.0
3  15.0  16.0  17.0  18.0  19.0

      a     b     c     d     e
0   0.0   0.0   0.0   0.0  -4.0
1  -1.0  -1.0  -1.0  -1.0  -9.0
2  -2.0  -2.0  -2.0  -2.0 -14.0
3 -15.0 -16.0 -17.0 -18.0 -19.0

     a         b         c         d    e
0  NaN  1.000000  1.000000  1.000000  0.0
1  0.8  0.833333  0.857143  0.875000  0.0
2  0.8  0.818182  0.833333  0.846154  0.0
3  0.0  0.000000  0.000000  0.000000  0.0

      a     b      c      d    e
0   0.0   1.0    4.0    9.0  0.0
1  20.0  30.0   42.0   56.0  0.0
2  80.0  99.0  120.0  143.0  0.0
3   0.0   0.0    0.0    0.0  0.0
</print>
</item>

<item>
<id>57</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

obj = Series(range(4), index=['d', 'a', 'b', 'c'])

print(obj.sort_index(),end='\n\n')

frame = DataFrame(np.arange(8).reshape((2, 4)), index=['three', 'one'],
                       columns=['d', 'a', 'b', 'c'])

print(frame.sort_index(),end='\n\n')
print(frame.sort_index(axis=1,, ascending=False),end='\n\n')
</content>
<print>
a    1
b    2
c    3
d    0
dtype: int32

       d  a  b  c
one    4  5  6  7
three  0  1  2  3

       d  c  b  a
three  0  3  2  1
one    4  7  6  5
</print>
</item>

<item>
<id>58</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка Series по значениям</title>
<content>
from pandas import Series, DataFrame

obj = Series(range(4), index=['d', 'a', 'b', 'c'])

print(obj.sort_values(),end='\n\n') 
</content>
<print>
d    0
a    1
b    2
c    3
dtype: int32
</print>
</item>

<item>
<id>59</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Cортировка DataFrame по значениям</title>
<content> 
from pandas import Series, DataFrame

frame = DataFrame({'b': [4, 7, -3, 2], 'a': [0, 1, 0, 1]})

print(frame,end='\n\n')
print(frame.sort_values(by='b'),end='\n\n')
print(frame.sort_values(by=['a','b']),end='\n\n')
</content>
<print>
   a  b
0  0  4
1  1  7
2  0 -3
3  1  2

   a  b
2  0 -3
3  1  2
0  0  4
1  1  7

   a  b
2  0 -3
0  0  4
3  1  2
1  1  7
</print>
</item>

<item>
<id>60</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Ранжирование</title>
<content> 
from pandas import Series, DataFrame

obj = Series([7, -5, 7, 4, 2, 0, 4])

print(obj.rank(),end='\n\n')
print(obj.rank(method='first'),end='\n\n')
print(obj.rank(ascending=False, method='max'),end='\n\n')
</content>
<print>
0    6.5
1    1.0
2    6.5
3    4.5
4    3.0
5    2.0
6    4.5
dtype: float64

0    6.0
1    1.0
2    7.0
3    4.0
4    3.0
5    2.0
6    5.0
dtype: float64

0    2.0
1    7.0
2    2.0
3    4.0
4    5.0
5    6.0
6    4.0
dtype: float64
</print>
</item>

<item>
<id>61</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Суммирование по столбцам/строкам</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df = DataFrame([[1.4, np.nan], [7.1, -4.5],[np.nan, np.nan], [0.75, -1.3]],
                   index=['a', 'b', 'c', 'd'],
                   columns=['one', 'two'])

print(df)
print(df.sum(),end='\n\n')
print(df.sum(axis=1),end='\n\n')
print(df.sum(axis=1,skipna=False),end='\n\n')
print(df.cumsum(),end='\n\n')
</content>
<print>
    one  two
a  1.40  NaN
b  7.10 -4.5
c   NaN  NaN
d  0.75 -1.3
one    9.25
two   -5.80
dtype: float64

a    1.40
b    2.60
c    0.00
d   -0.55
dtype: float64

a     NaN
b    2.60
c     NaN
d   -0.55
dtype: float64

    one  two
a  1.40  NaN
b  8.50 -4.5
c   NaN  NaN
d  9.25 -5.8
</print>
</item>

<item>
<id>62</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Свойство DataFrame describe()</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

df = DataFrame([[1.4, np.nan], [7.1, -4.5],[np.nan, np.nan], [0.75, -1.3]],
                   index=['a', 'b', 'c', 'd'],
                   columns=['one', 'two'])

print(df)
print(df.describe(),end='\n\n')
</content>
<print>
    one  two
a  1.40  NaN
b  7.10 -4.5
c   NaN  NaN
d  0.75 -1.3
            one       two
count  3.000000  2.000000
mean   3.083333 -2.900000
std    3.493685  2.262742
min    0.750000 -4.500000
25%    1.075000 -3.700000
50%    1.400000 -2.900000
75%    4.250000 -2.100000
max    7.100000 -1.300000
</print>
</item>

<item>
<id>63</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Уникальные значения Series,счетчики значений,вхождение</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

obj = Series(['c', 'a', 'd', 'a', 'a', 'b', 'b', 'c', 'c'])

print(obj.unique())
print(obj.value_counts(),end='\n\n')
print(pd.value_counts(obj.values,sort=False),end='\n\n')

# описание в заметках
mask = obj.isin(['b','c'])

print(mask,end='\n\n')
print(obj[mask],end='\n\n')
</content>
<print>
['c' 'a' 'd' 'b']
c    3
a    3
b    2
d    1
dtype: int64

a    3
c    3
d    1
b    2
dtype: int64

0     True
1    False
2    False
3    False
4    False
5     True
6     True
7     True
8     True
dtype: bool

0    c
5    b
6    b
7    c
8    c
dtype: object
</print>
</item>

<item>
<id>64</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Удаление отсутствующих данных Series</title>
<content>
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = Series([1, np.nan, 3.5, np.nan, 7])

print(data,end='\n\n')
print(data.dropna(),end='\n\n')
print(data[data.notnull()],end='\n\n') 
</content>
<print>
0    1.0
1    NaN
2    3.5
3    NaN
4    7.0
dtype: float64

0    1.0
2    3.5
4    7.0
dtype: float64

0    1.0
2    3.5
4    7.0
dtype: float64
</print>
</item>


<item>
<id>65</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Удаление отсутствующих данных DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = DataFrame([[1., 6.5, 3.], [1., np.nan, np.nan],
                   [np.nan, np.nan, np.nan], [np.nan, 6.5, 3.]])

print(data,end='\n\n')
print(data.dropna(),end='\n\n')

# how='all' will only drop rows that are all NA:
print(data.dropna(axis=0,how='all'),end='\n\n')
</content>
<print>
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
2  NaN  NaN  NaN
3  NaN  6.5  3.0

     0    1    2
0  1.0  6.5  3.0

     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
3  NaN  6.5  3.0
</print>
</item>


<item>
<id>66</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Восполнение отсутствующих данных </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = DataFrame([[1., 6.5, 3.], [1., np.nan, np.nan],
                   [np.nan, np.nan, np.nan], [np.nan, 6.5, 3.]])

print(data,end='\n\n')
print(data.fillna(0),end='\n\n')
</content>
<print>
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
2  NaN  NaN  NaN
3  NaN  6.5  3.0

     0    1    2
0  1.0  6.5  3.0
1  1.0  0.0  0.0
2  0.0  0.0  0.0
3  0.0  6.5  3.0
</print>
</item>


<item>
<id>67</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Иерархическое индексирование Series</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = Series(np.random.randn(10),
                  index=[['a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'd', 'd'],
                  [1, 2, 3, 1, 2, 3, 1, 2, 2, 3]])

print(data,end='\n\n')
print(data['b'],end='\n\n')
print(data['a':'c'],end='\n\n')
print(data['a':'c'],end='\n\n')
print(data.ix[['b', 'd']],end='\n\n')

# выборка с «внутреннего» уровня:
print(data[:,2],end='\n\n')
</content>
<print>
a  1    1.801573
   2   -2.077585
   3   -1.288899
b  1   -0.290470
   2   -0.583967
   3   -2.310463
c  1    1.994905
   2    0.000133
d  2    2.139078
   3    1.317171
dtype: float64

1   -0.290470
2   -0.583967
3   -2.310463
dtype: float64

a  1    1.801573
   2   -2.077585
   3   -1.288899
b  1   -0.290470
   2   -0.583967
   3   -2.310463
c  1    1.994905
   2    0.000133
dtype: float64

a  1    1.801573
   2   -2.077585
   3   -1.288899
b  1   -0.290470
   2   -0.583967
   3   -2.310463
c  1    1.994905
   2    0.000133
dtype: float64

b  1   -0.290470
   2   -0.583967
   3   -2.310463
d  2    2.139078
   3    1.317171
dtype: float64

a   -2.077585
b   -0.583967
c    0.000133
d    2.139078
dtype: float64
</print>
</item>


<item>
<id>68</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Иерархическое индексирование DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

frame = DataFrame(np.arange(12).reshape((4, 3)),
                      index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],
                      columns=[['Ohio', 'Ohio', 'Colorado'],
                               ['Green', 'Red', 'Green']])

print(frame,end='\n\n')

frame.index.names = ['key1', 'key2']
frame.columns.names = ['state', 'color']

print(frame,end='\n\n')
print(frame.swaplevel('key1','key2').sortlevel(1), end='\n\n')
</content>
<print>
     Ohio     Colorado
    Green Red    Green
a 1     0   1        2
  2     3   4        5
b 1     6   7        8
  2     9  10       11

state      Ohio     Colorado
color     Green Red    Green
key1 key2                   
a    1        0   1        2
     2        3   4        5
b    1        6   7        8
     2        9  10       11

state     Colorado  Ohio    
color        Green Green Red
key2 key1                   
1    a           2     0   1
2    a           5     3   4
1    b           8     6   7
2    b          11     9  10
</print>
</item>

<item>
<id>69</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Нахождение одинаковых значений в DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = DataFrame({'Qu1': [1, 3, 4, 3, 4],
                     'Qu2': [2, 3, 1, 2, 3],
                      'Qu3': [1, 5, 2, 4, 4]})

print(data,end='\n\n')
print(data.apply(pd.value_counts).fillna(0))
</content>
<print>
   Qu1  Qu2  Qu3
0    1    2    1
1    3    3    5
2    4    1    2
3    3    2    4
4    4    3    4

   Qu1  Qu2  Qu3
1  1.0  1.0  1.0
2  0.0  2.0  1.0
3  2.0  2.0  0.0
4  2.0  0.0  2.0
5  0.0  0.0  1.0
</print>
</item>


<item>
<id>70</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Сводная статистика по уровню DataFrame</title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

frame = DataFrame(np.arange(12).reshape((4, 3)),
                      index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],
                      columns=[['Ohio', 'Ohio', 'Colorado'],
                               ['Green', 'Red', 'Green']])

print(frame,end='\n\n')

frame.index.names = ['key1', 'key2']
frame.columns.names = ['state', 'color']

print(frame.sum(level='key2'),end='\n\n')
print(frame.sum(level='color', axis=1), end='\n\n')
</content>
<print>
     Ohio     Colorado
    Green Red    Green
a 1     0   1        2
  2     3   4        5
b 1     6   7        8
  2     9  10       11

state  Ohio     Colorado
color Green Red    Green
key2                    
1         6   8       10
2        12  14       16

color      Green  Red
key1 key2            
a    1         2    1
     2         8    4
b    1        14    7
     2        20   10
</print>
</item>

<item>
<id>71</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Работа со столбцами DataFrame </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

frame = DataFrame({'a': range(7), 'b': range(7, 0, -1),
                       'c': ['one', 'one', 'one', 'two', 'two', 'two', 'two'],
                       'd': [0, 1, 2, 0, 1, 2, 3]})

print(frame,end='\n\n')
print(frame.set_index(['c', 'd']),end='\n\n')

# По умолчанию столбцы удаляются из DataFrame,хотя их можно и оставить
print(frame.set_index(['c', 'd'],drop=False),end='\n\n')

# reset_index, делает прямо противоположное set_index;
print(frame.reset_index(),end='\n\n')
</content>
<print>
   a  b    c  d
0  0  7  one  0
1  1  6  one  1
2  2  5  one  2
3  3  4  two  0
4  4  3  two  1
5  5  2  two  2
6  6  1  two  3

       a  b
c   d      
one 0  0  7
    1  1  6
    2  2  5
two 0  3  4
    1  4  3
    2  5  2
    3  6  1

       a  b    c  d
c   d              
one 0  0  7  one  0
    1  1  6  one  1
    2  2  5  one  2
two 0  3  4  two  0
    1  4  3  two  1
    2  5  2  two  2
    3  6  1  two  3

   index  a  b    c  d
0      0  0  7  one  0
1      1  1  6  one  1
2      2  2  5  one  2
3      3  3  4  two  0
4      4  4  3  two  1
5      5  5  2  two  2
6      6  6  1  two  3
</print>
</item>

<item>
<id>72</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Изменение формы с помощью иерархического индексирования </title>
<content>
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = DataFrame(np.arange(6).reshape((2, 3)),
                    index=pd.Index(['Ohio', 'Colorado'], name='state'),
                     columns=pd.Index(['one', 'two', 'three'], name='number'))


print(data,end='\n\n')

'''
Метод stack поворачивает таблицу, так что столбцы оказываются строками, и в результате получается объект Series 
'''
print(data.stack(),end='\n\n')
print(data.unstack(),end='\n\n') 
</content>
<print>
number    one  two  three
state                    
Ohio        0    1      2
Colorado    3    4      5

state     number
Ohio      one       0
          two       1
          three     2
Colorado  one       3
          two       4
          three     5
dtype: int32

number  state   
one     Ohio        0
        Colorado    3
two     Ohio        1
        Colorado    4
three   Ohio        2
        Colorado    5
dtype: int32
</print>
</item>

<item>
<id>73</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Устранение дубликатов </title>
<content>
from pandas import Series, DataFrame

data = DataFrame({'k1': ['one'] * 3 + ['two'] * 4,
                     'k2': [1, 1, 2, 3, 3, 4, 4]})

print(data,end='\n\n')
print(data.duplicated(),end='\n\n')
print(data.drop_duplicates(),end='\n\n')
print(data.drop_duplicates(['k1','k2']),end='\n\n')
</content>
<print>
    k1  k2
0  one   1
1  one   1
2  one   2
3  two   3
4  two   3
5  two   4
6  two   4

0    False
1     True
2    False
3    False
4     True
5    False
6     True
dtype: bool

    k1  k2
0  one   1
2  one   2
3  two   3
5  two   4

    k1  k2
0  one   1
2  one   2
3  two   3
5  two   4
</print>
</item>

<item>
<id>74</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Дискретизация и раскладывание </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

# раскладывание возраста по категориям
ages = [20, 22, 25, 27, 21, 23, 37, 31, 61, 45, 41, 32]
bins = [18, 25, 35, 60, 100]
group_names = ['Youth', 'YoungAdult', 'MiddleAged', 'Senior']
cats = pd.cut(ages, bins, labels=group_names)

print(cats,end='\n\n')
print(cats.codes,end='\n\n')
print(pd.value_counts(cats),end='\n\n')
'''
Согласно принятой в математике нотации интервалов круглая скобка означает, что соответствующий конец не включается (открыт), а квадратная - что включается (замкнут). Чтобы сделать открытым правый конец, следует задать параметр right=False: 
'''
print(pd.cut(ages, [18, 26, 36, 61, 100], right=False),end='\n\n')
</content>
<print>
[Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, MiddleAged, YoungAdult]
Length: 12
Categories (4, object): [MiddleAged &lt; Senior &lt; YoungAdult &lt; Youth]

[3 3 3 2 3 3 0 2 1 0 0 2]

Youth         5
YoungAdult    3
MiddleAged    3
Senior        1
dtype: int64

[[18, 26), [18, 26), [18, 26), [26, 36), [18, 26), ..., [26, 36), [61, 100), [36, 61), [36, 61), [26, 36)]
Length: 12
Categories (4, interval[int64]): [[18, 26) &lt; [26, 36) &lt; [36, 61) &lt; [61, 100)]
</print>
</item>

<item>
<id>75</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Дискретизация и раскладывание(2)</title>
<content>
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

data = np.random.rand(20)

print(pd.cut(data, 4, precision=2),end='\n\n') 
</content>
<print>
[(0.096, 0.3], (0.096, 0.3], (0.3, 0.51], (0.51, 0.72], (0.096, 0.3], (0.72, 0.93]]
Categories (4, interval[float64]): [(0.096, 0.3] &lt; (0.3, 0.51] &lt; (0.51, 0.72] &lt; (0.72, 0.93]]
</print>
</item>

<item>
<id>76</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Дискретизация и раскладывание(3)</title>
<content> 
'''
Родственный метод qcut раскладывает данные, исходя из выборочных квантилей. Метод cut обычно создает ящики, содержащие разное число точек, - это всецело определяемся распределением данных. Но поскольку qcut пользуется выборочными квантилями, то по определению получаются ящики равного размера
'''
data = np.random.randn(10) # Normally distributed
cats = pd.qcut(data, 4) # Cut into quartiles

print(cats,end='\n\n')
print(pd.value_counts(cats),end='\n\n')
'''
Как и в случае cut, можно  задать величины кваптилей (числа от О до 1 включительно)самостоятельно
'''
print(pd.qcut(data, [0, 0.1, 0.5, 0.9, 1.]),end='\n\n')
</content>
<print>
[(0.52, 0.811], (-0.883, 0.199], (0.811, 1.582], (-0.883, 0.199], (0.811, 1.582], (0.199, 0.52], (0.811, 1.582], (-0.883, 0.199], (0.199, 0.52], (0.52, 0.811]]
Categories (4, interval[float64]): [(-0.883, 0.199] &lt; (0.199, 0.52] &lt; (0.52, 0.811] &lt; (0.811, 1.582]]

(0.811, 1.582]     3
(-0.883, 0.199]    3
(0.52, 0.811]      2
(0.199, 0.52]      2
dtype: int64

[(0.52, 1.524], (-0.714, 0.52], (1.524, 1.582], (-0.883, -0.714], (0.52, 1.524], (-0.714, 0.52], (0.52, 1.524], (-0.714, 0.52], (-0.714, 0.52], (0.52, 1.524]]
Categories (4, interval[float64]): [(-0.883, -0.714] &lt; (-0.714, 0.52] &lt; (0.52, 1.524] &lt; (1.524, 1.582]]
</print>
</item>

<item>
<id>77</id>
<menu>Pandas</menu>
<submenu>Базовые операции</submenu>
<title>Обнаружение и фильтрация выбросов </title>
<content> 
import numpy as np
import pandas as pd
from pandas import Series, DataFrame


np.random.seed(12345)
data = DataFrame(np.random.randn(1000, 4))

print(data.describe(),end='\n\n')
'''
Допустим, что мы хотим найти  в одном из столбцов значения, превышающие 3 по абсолютной величине
'''

col = data[3]

print(col[np.abs(col) > 3],end='\n\n')
'''
Чтобы выбрать все строки, в которых встречаются значения, по абсолютной величине превышающие 3, мы можем воспользоваться методом any для булева объекта DataFrame
'''
print(data[(np.abs(data) > 3).any(1)],end='\n\n')
'''
Можно также присваивать значения данным, удовлетворяющим этому критерию: Следующий код срезает значения, выходящие за границы интервала от -3 до 3:
'''
data[np.abs(data) > 3] = np.sign(data) * 3

print(data.describe(),end='\n\n')
</content>
<print>
                0            1            2            3
count  1000.000000  1000.000000  1000.000000  1000.000000
mean     -0.067684     0.067924     0.025598    -0.002298
std       0.998035     0.992106     1.006835     0.996794
min      -3.428254    -3.548824    -3.184377    -3.745356
25%      -0.774890    -0.591841    -0.641675    -0.644144
50%      -0.116401     0.101143     0.002073    -0.013611
75%       0.616366     0.780282     0.680391     0.654328
max       3.366626     2.653656     3.260383     3.927528

97     3.927528
305   -3.399312
400   -3.745356
Name: 3, dtype: float64

            0         1         2         3
5   -0.539741  0.476985  3.248944 -1.021228
97  -0.774363  0.552936  0.106061  3.927528
102 -0.655054 -0.565230  3.176873  0.959533
305 -2.315555  0.457246 -0.025907 -3.399312
324  0.050188  1.951312  3.260383  0.963301
400  0.146326  0.508391 -0.196713 -3.745356
499 -0.293333 -0.242459 -3.056990  1.918403
523 -3.428254 -0.296336 -0.439938 -0.867165
586  0.275144  1.179227 -3.184377  1.369891
808 -0.362528 -3.548824  1.553205 -2.186301
900  3.366626 -2.372214  0.851010  1.332846

                 0            1            2            3
count  1000.000000  1000.000000  1000.000000  1000.000000
mean     -0.067623     0.068473     0.025153    -0.002081
std       0.995485     0.990253     1.003977     0.989736
min      -3.000000    -3.000000    -3.000000    -3.000000
25%      -0.774890    -0.591841    -0.641675    -0.644144
50%      -0.116401     0.101143     0.002073    -0.013611
75%       0.616366     0.780282     0.680391     0.654328
max       3.000000     2.653656     3.000000     3.000000

</print>
</item>

<item>
<id>78</id>
<menu>Сортировка</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка выбором</title>
<content> 
def selection_sort(arrayToSort):
    a = arrayToSort
    for i in range(len(a)):
        idxMin = i
        for j in range(i+1, len(a)):
            if a[j] &lt; a[idxMin]:
                idxMin = j
        tmp = a[idxMin]
        a[idxMin] = a[i]
        a[i] = tmp
    return a

arr = [34,3,5,1,2,3,5,4,2,43,24]

print (selection_sort(arr))
</content>
<print>
[1, 2, 2, 3, 3, 4, 5, 5, 24, 34, 43]
</print>
</item> 

<item>
<id>79</id>
<menu>Сортировка</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка вставками</title>
<content> 
def insertion_sort(array):
    for i in range(1, len(array)):
        while i > 0 and array[i] &lt; array[i - 1]:
            array[i], array[i - 1] = array[i - 1], array[i]
            i -= 1
    return array

arr = [34,3,5,1,2,3,5,4,2,43,24]

print (insertion_sort(arr))
</content>
<print>
[1, 2, 2, 3, 3, 4, 5, 5, 24, 34, 43
</print>
</item> 

<item>
<id>80</id>
<menu>Сортировка</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка пузьрьком</title>
<content> 
def bubble_sort(arrayToSort):
    a = arrayToSort
    for i in range(len(a),0,-1):
        for j in range(1, i):
            if a[j-1] > a[j]:
                tmp = a[j-1]
                a[j-1] = a[j]
                a[j] = tmp
                # print (a)
    return a

arr = [5, 0, 10, 4, 1, 5, 8, 4, 3, 12, 41]

print (bubble_sort(arr))
</content>
<print>
[1, 2, 2, 3, 3, 4, 5, 5, 24, 34, 43]
</print>
</item> 

<item>
<id>81</id>
<menu>Сортировка</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка слиянием</title>
<content> 
def MergerSort(a):
    def MergerGroup(a, left, m, right):
        if left >= right: return None
        if m &lt; left or right &lt; m: return None
        t = left
        for j in range(m + 1, right + 1):  # подгруппа 2
            for i in range(t, j):  # цикл подгруппы 1
                if a[j] &lt; a[i]:
                    r = a[j]
                    # итерационно переставляем элементы, чтобы упорядочить
                    for k in range(j, i, -1):
                        a[k] = a[k - 1]
                    a[i] = r
                    t = i  # проджолжение вставки в группе 1
                    break  # к следующему узлу из подгруппы 2
    if len(a) &lt; 2: return None
    k = 1
    while k &lt; len(a):
        g = 0
        while g &lt; len(a):  # группы
            z = g + k + k - 1  # последний эл-т группы
            r = z if z &lt; len(a) else len(a) - 1  # последняя группа
            MergerGroup(a, g, g + k - 1, r)  # слияние
            g += 2 * k
        k *= 2
    return a
arr = [34,3,5,1,2,3,5,4,2,43,24]
print (MergerSort(arr))
</content>
<print>
[1, 2, 2, 3, 3, 4, 5, 5, 24, 34, 43]
</print>
</item> 

<item>
<id>82</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>Cтроки - упорядоченные последовательности символов, используемые для хранения и представления текстовой информации
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>83</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>Cтроки относятся к категории неизменяемых последовательностей, в том смысле, что символы, которые они содержат, имеют определенный порядок следования слева направо и сами строки невозможно изменить.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>84</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>
Пустые строки записываются как пара кавычек (или апострофов), между которыми ничего нет
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>85</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>
В Python 3.х существует три строковых типа: str – для представления текста Юникода (содержащего символы в кодировке ASCII и символы в других кодировках), bytes – для представления двоичных данных (включая кодированный текст) и bytearray – изменяемый вариант типа bytes
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>86</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>
Кавычки и апострофы, окружающие строки, в языке Python являются взаимозаменяемыми. То есть строковые литералы можно заключать как в апострофы, так и в кавычки – эти две формы представления строк ничем не отличаются, и обе они возвращают объект того же самого типа:
str =[‘shrubbery’, “shrubbery”]
print(str)
[‘shrubbery’, ‘shrubbery’]
str1,str2='knight""s', ""knight's""
print(str1+' '+str2)
knight”s  knight’s
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>87</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>
Python автоматически объединяет последовательности строковых литералов внутри выражения 
# Неявная конкатенация
title = ""Meaning "" 'of’' "" Life"" 
print(title)
Meaning of Life"
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>88</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>
Если добавить запятые между этими строками, будет получен кортеж, а не строка
str=""first"",""second""
print(str)
('first', 'second')"
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>89</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>
B языке Python нет символа,который служил бы признаком завершения строки
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>90</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>
Если требуется работать с файлами, содержащими двоичные данные, главное отличие в работе с ними заключается в том, что открывать их нужно в режиме двоичного доступа (добавляя к флагу режима открытия флаг b, например "rb", "wb")
</title>
<content> 
</content>
</item> 

<item>
<id>91</id>
<menu>Строки</menu>
<submenu>Заметки</submenu>
<title>
Если перед кавычкой, открывающей строку, стоит символ r (в верхнем или в нижнем регистре), он отключает механизм экранирования.
myfile = open(r'C:\new\text.dat', 'w')
или
myfile = open('C:\\new\\text.dat', 'w')
</title>
<content> 
</content>
<print>
</print>
</item> 


<item>
<id>92</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Длина строки - len()</title>
<content>
str = 'abcd'

print(len(str))
</content>
<print>
4
</print>
</item>

<item>
<id>93</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Конкатенация строк</title>
<content>
str = 'abc'+'def'

print(str)
</content>
<print>
abcdef
</print>
</item>

<item>
<id>94</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Повторение строк</title>
<content>
myjob = 'hacker' 
for c in myjob: 
	print(c, end=' ')
</content>
<print>
h a c k e r
</print>
</item>

<item>
<id>95</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Поиск в строке</title>
<content>
myjob = 'hacker'

print('k' in myjob)
</content>
<print>
true
</print>
</item>

<item>
<id>96</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Поиск в строке с возвратом позиции - find()</title>
<content>
myjob = 'hacker'

print(myjob.find('k'))
</content>
<print>
3
</print>
</item>

<item>
<id>97</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Обращение к элементу строки по индексу</title>
<content>
s = 'python'

print(s[0]+'  '+s[-2])
</content>
<print>
p  o
</print>
</item>

<item>
<id>98</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Срезы - извлечение подстроки</title>
<content>
s = 'python'

print(s[1:3]+'  '+s[1:]+'  '+s[:-1])
</content>
<print>
yt  ython  pytho
</print>
</item>

<item>
<id>99</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Срезы-извлечение подстроки(2)</title>
<content>
'''
Извлекает каждый 2-й элемент
последовательности в диапазоне от 1 до 9
'''
s='learning_python'  

print(s[1:10:2])
</content>
<print>
erigp
</print>
</item>

<item>
<id>100</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Срезы-извлечение подстроки(3)</title>
<content>
'''
Обратный срез извлекает каждый 2-й элемент 
последовательности в диапазоне от -2 до 1
'''
s = 'learning_python'

print(s[-2:1:-2])					
</content>
<print>
nhy_nna
</print>
</item>

<item>
<id>101</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Пребразование из/в строку</title>
<content>
s = int(""42""),str(17),float('1.5')

print(s)

s = '1.234E-10'

print(float(s))
</content>
<print>
(42, '17', 1.5)
1.234e-10
</print>
</item>

<item>
<id>102</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Преобразование одиночного символав его целочисленный код ASCII</title>
<content>
a = ord('s')

print(a)
</content>
<print>
115
</print>
</item>

<item>
<id>103</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Преобразование ASCII кода в символ</title>
<content>
a = chr(115)

print(a)
</content>
<print>
s
</print>
</item>

<item>
<id>104</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Замещение символов в строке - replace()</title>
<content>
s = 'python'
s = s.replace('py', 'kivy')

print(s)
</content>
<print>
kivython
</print>
</item>

<item>
<id>105</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Выражения форматирования строки - %</title>
<content>
'''
s - Строка (для объекта любого другого типа будет выполнен вызов функции str(X), чтобы получить строковое представление объекта)
r - s, но использует функцию repr, а не str
c - Символ
d - Десятичное целое число
i - Целое число
u - То же, что и d (устарел: больше не является представлением целого без знака)
o - Восьмеричное целое число
x - Шестнадцатеричное целое число
X - x, но шестнадцатеричные цифры возвращаются в верхнем регистре
e - Вещественное число в экспоненциальной форме
E - e, но алфавитные символы возвращаются в верхнем регистре
f - Вещественное число в десятичном представлении
F - Вещественное число в десятичном представлении
g - Вещественное число e или f
'''
print('That is %d %s bird!' % (1, 'dead'))
</content>
<print>
That is 1 dead bird!
</print>
</item>

<item>
<id>106</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Форматирование строк из словаря</title>
<content>
l = {'n':1, 'x':'spam'}
str = '%(n)d %(x)s'

print(str % l)
</content>
<print>
1 spam
</print>
</item>

<item>
<id>107</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Форматирование строк из словаря(2)</title>
<content>
reply = '''  
Greetings...
Hello %(name)s!
Your age squared is %(age)s
'''
values = {'name': 'Bob', 'age': 40} 

print (reply % values)
</content>
<print>
Greetings...
Hello Bob!
Your age squared is 40
</print>
</item>

<item>
<id>108</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Спецификаторы формата</title>
<content>
x = 1234

print("integers: ...%d...%6d...%-6d...%06d" % (x, x, x, x))
</content>
<print>
integers: ...1234...  1234...1234  ...001234
</print>
</item>

<item>
<id>109</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Спецификаторы формата(2)</title>
<content>
x = 1.23456789

print('%e | %f | %g' % (x, x, x))
</content>
<print>
1.234568e+00 | 1.234568 | 1.23457
</print>
</item>

<item>
<id>110</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Спецификаторы формата(3)</title>
<content>
x = 1.23456789

print('%-6.2f|%05.2f|%+06.1f' % (x, x, x))
</content>
<print>
1.23  |01.23|+001.2
</print>
</item>

<item>
<id>111</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Метод форматирования строки - format()</title>
<content>
print('That is {0} {1} bird!'.format(1, 'dead'))
</content>
<print>
That is 1 dead bird!
</print>
</item>

<item>
<id>112</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Метод форматирования строки(2) - format()</title>
<content>
template = '{0}, {1} and {2}'

print(template.format('spam', 'ham', 'eggs'))
</content>
<print>
spam, ham and eggs
</print>
</item>

<item>
<id>113</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Метод форматирования строки(3) - format()</title>
<content>
template = '{motto}, {pork} and {food}'

print(template.format(motto = 'spam', pork = 'ham', food = 'eggs'))
</content>
<print>
spam, ham and eggs
</print>
</item>

<item>
<id>114</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Метод форматирования строки(4) - format()</title>
<content>
import sys
str = 'My {1[spam]} runs {0.platform}'.format(sys, {'spam': 'laptop'})

print(str)

str = 'My {config[spam]} runs {sys.platform}'.format(sys = sys,config = {'spam': 'laptop'})

print(str)
</content>
<print>
My laptop runs win32
My laptop runs win32
</print>
</item>

<item>
<id>115</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Метод форматирования строки(5) - format()</title>
<content>
l = list('SPAM')

print('first = {0[0]}, third = {0[2]}'.format(l))

parts = l[0], l[-1], l[1:3]

print('first = {0}, last = {1}, middle = {2}'.format(*parts))
</content>
<print>
first = S, third = A
first = S, last = M, middle = ['P', 'A']
</print>
</item>

<item>
<id>116</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Метод форматирования строки - выравнивание</title>
<content>
import sys

print('|{0.platform:&gt;10}| = |{1[item]:&lt;10}|'.format(sys, dict(item = 'laptop')))
</content>
<print>
|     win32| = |laptop    |
</print>
</item>

<item>
<id>117</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Метод форматирования строки (7) - format()</title>
<content>
print('{0:e}, {1:.3e}, {2:g}'.format(3.14159, 3.14159, 3.14159))
print('{0:f}, {1:.2f}, {2:06.2f}'.format(3.14159, 3.14159, 3.14159))
</content>
<print>
3.141590e+00, 3.142e+00, 3.14159
3.141590, 3.14, 003.14
</print>
</item>

<item>
<id>118</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Метод форматирования вывода цифр - format()</title>
<content>
print('{:,d}'.format(9999999999))
print('{:,.2f}'.format(296999.2567))
</content>
<print>
9,999,999,999
296,999.26
</print>
</item>

<item>
<id>119</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Длина строки - len()</title>
<content>
str = 'hello'

print(len(str))
</content>
<print>
5
</print>
</item>

<item>
<id>120</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Вставка кавычек и апострофов в строку</title>
<content>
str = "first\"s",'second\'s'

print(str)
</content>
<print>
('firs"t', "second's")
</print>
</item>

<item>
<id>121</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Преобразование строки в список -></title>
<content>
s = 'spammy'
l = list(s)

print(l)
</content>
<print>
['s', 'p', 'a', 'm', 'm', 'y']
</print>
</item>

<item>
<id>122</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>-> и обратно</title>
<content>
s = 'spammy'
l = list(s)
l[3] = 'x'
l[4] = 'x'
s = ''.join(l)

print(s)
</content>
<print>
spaxxy
</print>
</item>

<item>
<id>123</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Строка-разделитель - join()</title>
<content>
s = '-|-'.join(['I','like','python'])

print(s)
</content>
<print>
I-|-like-|-python
</print>
</item>

<item>
<id>124</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Строковый метод - split()</title>
<content>
line = 'bob,hacker,40'
print(line.split(','))
</content>
<print>
['bob', 'hacker', '40']
</print>
</item>

<item>
<id>125</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Удаление пустых символов с конца строки - rstrip()</title>
<content>
line="The knights who say Ni!\n"

print(line.rstrip())
</content>
<print>
The knights who say Ni!
</print>
</item>

<item>
<id>126</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Пребразование символов в заглавные - upper()</title>
<content>
line="The knights who say Ni!\n"

print(line.upper())
</content>
<print>
THE KNIGHTS WHO SAY NI!
</print>
</item>

<item>
<id>127</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Проверка символов на принадлежность к буквам - isalpha()</title>
<content>
line="The knights who say Ni!\n"

print(line.isalpha())
</content>
<print>
False
</print>
</item>

<item>
<id>128</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Проверка окончания строки - endswith()</title>
<content>
line="The knights who say Ni!\n"

print(line.endswith('Ni!\n'))
#Выполняется быстрее

print(line[-4:] == "Ni!\n")
</content>
<print>
True
True
</print>
</item>

<item>
<id>129</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Удаление символов из строки</title>
<content>
line="The knights who say Ni!\n"
line = line.translate({ord(c): None for c in '!@#$'})

print(line)

import re
line = re.sub('[!@#$]', '', line)

print(line)
</content>
<print>
The knights who say Ni
The knights who say Ni
</print>
</item>

<item>
<id>130</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Проверка начала строки - startswith()</title>
<content>
line="The knights who say Ni!\n"

print(line.startswith('The'))
#Выполняется быстрее

print(line[:3]=="The")
</content>
<print>
True
True
</print>
</item>

	
<item>
<id>131</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Сравнивание строк</title>
<content>
s1 = 'hello'
s2 = 'hello'
'''
Оператор == проверяет равенство значений. Интерпретатор выполняет
проверку на равенство, рекурсивно сравнивая все вложенные объекты.
'''
print(s1 == s2)
'''
Оператор is проверяет идентичность объектов. Интерпретатор проверяет,
являются ли сравниваемые объекты одним и тем же объектом (то есть расположены ли они по одному и тому же адресу в памяти).
'''
print(s1 is s2)

s3 = 'abc'
s4 = 'adc'

print(s1 > s2)
</content>
<print>
True
True
False
</print>
</item>

<item>
<id>132</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Модуль re</title>
<content>
import re
'''
Конструкция (.*) означает ноль или более (*) любых символов (.), которые должны
сохраняться в виде подстроки совпадения (())
'''
S = 'Bugger all down here on earth!'
B = b'Bugger all down here on earth!' 
a = re.match('(.*) down (.*) on (.*)', S).groups() 
b = re.match(b'(.*) down (.*) on (.*)', B).groups() 

print(a)
print(b)
</content>
<print>
('Bugger all', 'here', 'earth!')
(b'Bugger all', b'here', b'earth!')
</print>
</item>

<item>
<id>133</id>
<menu>Строки</menu>
<submenu>Базовые операции</submenu>
<title>Разбор XML</title>
<content>
'''
myfile.xml
&lt;books>
    &lt;date>2009&lt;/date>
    &lt;title>Learning Python&lt;/title>
    &lt;title>Programming Python&lt;/title>
    &lt;title>Python Pocket Reference&lt;/title>
	&lt;publisher>O’Reilly Media&lt;/publisher>
&lt;/books>
'''
from xml.dom.minidom import parse, Node
xmltree = parse('myfile.xml')
for node1 in xmltree.getElementsByTagName('title'):
    for node2 in node1.childNodes:
        if node2.nodeType == Node.TEXT_NODE:
            print(node2.data)
</content>
<print>
Learning Python
Programming Python
Python Pocket Reference
</print>
</item>


<item>
<id>134</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Вывод текущей даты/времени</title>
<content> 
import datetime
now = datetime.datetime.now()
today = now.date()
moment = now.time()

print(now) 
print(today)
print(moment)
</content>
<print>
2017-05-28 00:41:30.637869
2017-05-28
00:41:30.637869
</print>
</item> 


<item>
<id>135</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Вывод текущей даты/времени(2)</title>
<content> 
import datetime
today = datetime.date.today()
moment = datetime.datetime.now().time()
now = datetime.datetime.combine(today, moment)

print(now)
print(today)
print(moment)
</content>
<print>
2017-06-04 20:01:47.695016
2017-06-04
20:01:47.695016
</print>
</item> 


<item>
<id>136</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>timedelta - суммирование или вычитание количества дней</title>
<content> 
import datetime
today = datetime.date.today()
yesterday = today - datetime.timedelta(1)
delta = yesterday - today

print(today)
print(yesterday)
print(delta)
</content>
<print>
2017-05-28
2017-05-27
-1 day, 0:00:00
</print>
</item> 


<item>
<id>137</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Объекты даты</title>
<content> 
import datetime
my_date = datetime.date(1984, 6, 24)

print(my_date)

my_date = datetime.date(day=24, year=1984, month=6)

print(my_date)
</content>
<print>
1984-06-24
1984-06-24
</print>
</item> 


<item>
<id>138</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Объекты времени</title>
<content> 
import datetime
my_time = datetime.time()

print(my_time)

my_time = datetime.time(1,34) # Час, Минута

print(my_time)

my_time = datetime.time(hour=2, minute=15)

print(my_time)
</content>
<print>
00:00:00
01:34:00
02:15:00
</print>
</item> 


<item>
<id>139</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Изменение даты/времени</title>
<content> 
import datetime
datetime = datetime.datetime.now()

print(datetime)

another_datetime = datetime.replace(year=2014, month=1, day=10,
                                    hour=10, minute=20, second=15)

print(another_datetime)
</content>
<print>
2017-05-28 01:02:03.618275
2014-01-10 10:20:15.618275
</print>
</item>


<item>
<id>140</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Получение объекта datetime, представляющий эпоху 01-01-1970</title>
<content> 
import datetime
epoch = datetime.datetime.utcfromtimestamp(0)

print(epoch)

# 60 секунд с начала 
epoch = datetime.datetime.utcfromtimestamp(60)

print(epoch)

# 1000 000 секунд с начала
epoch = datetime.datetime.utcfromtimestamp(1000000)

print(epoch)
</content>
<print>
1970-01-01 00:00:00
1970-01-01 00:01:00
1970-01-12 13:46:40
</print>
</item>


<item>
<id>141</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Получение времени между эпохой и сейчас</title>
<content> 
import datetime
now = datetime.datetime.now()
epoch = datetime.datetime.utcfromtimestamp(0)
delta = now - epoch

print(delta)

days = delta.days

print(days)

seconds = delta.seconds	# секунды с 00:00:00 текущего дня

print(seconds)

total_seconds = delta.total_seconds()

print(total_seconds)
</content>
<print>
17314 days, 1:16:42.140123
17314
4602
1495934202.140123
</print>
</item>


<item>
<id>142</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Восстановление даты со строки</title>
<content> 
import datetime
string_date = '2017-05-28'
my_date = datetime.date(*[int(i) for i in string_date.split("-")])

print(my_date)
</content>
<print>
2017-05-28
</print>
</item> 


<item>
<id>143</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Форматирование строки отображения даты</title>
<content> 
import datetime
my_date = datetime.datetime.now()
string_date =  my_date.strftime('%m / %d / %Y ')

print(string_date)
</content>
<print>
05 / 28 / 2017
</print>
</item> 

<item>
<id>144</id>
<menu>Время</menu>
<submenu>Базовые операции</submenu>
<title>Парсинг Даты</title>
<content>
from dateutil.parser import parse

print(parse('2011-01-03'),end='\n\n')
print(parse('Jan 31, 1997 10:45 PM'),end='\n\n')
print(parse('6/12/2011', dayfirst=True) ,end='\n\n') 
</content>
<print>
2011-01-03 00:00:00

1997-01-31 22:45:00

2011-12-06 00:00:00
</print>
</item>


<item>
<id>145</id>
<menu>Время</menu>
<submenu>Заметки</submenu>
<title>
Типы в модуле datetime 

date 		Хранит дату (год, месяц, день) по григорианскому календарю 

time 		Хранит время суток (часы, минуты, секунды и микросекунды)
datetime 	Хранит дату и время

timedelta 	Представляет разность между двумя значениями типа datetime (дни, секунды и микросекунды) 
</title>
<content> 

</content>
<print>
</print>
</item>


<item>
<id>146</id>
<menu>Время</menu>
<submenu>Заметки</submenu>
<title>
'''
%a 	Weekday as locale’s abbreviated name. 	
%A 	Weekday as locale’s full name. 	
%w 	Weekday as a decimal number, where 0 is Sunday and 6 is Saturday. 	 
%d 	Day of the month as a zero-padded decimal number.  	 
%b 	Month as locale’s abbreviated name. 	
%B 	Month as locale’s full name. 	
%m 	Month as a zero-padded decimal number. 	 	 
%y 	Year without century as a zero-padded decimal number. 	 
%Y 	Year with century as a decimal number. 	
%H 	Hour (24-hour clock) as a zero-padded decimal number. 	 
%I 	Hour (12-hour clock) as a zero-padded decimal number. 	 
%p 	Locale’s equivalent of either AM or PM. 	
%M 	Minute as a zero-padded decimal number. 	 
%S 	Second as a zero-padded decimal number.
%f 	Microsecond as a decimal number, zero-padded on the left. 	
%z 	UTC offset in the form +HHMM or -HHMM (empty string if the object is naive). 
%Z 	Time zone name (empty string if the object is naive). 		 
%j 	Day of the year as a zero-padded decimal number. 		 
%U 	Week number of the year (Sunday as the first day of the week) as a zero padded decimal number. All days in a new year preceding the first Sunday are considered to be in week 0.
%W 	Week number of the year (Monday as the first day of the week) as a decimal number. All days in a new year preceding the first Monday are considered to be in week 0.
%c 	Locale’s appropriate date and time representation. 	
%x 	Locale’s appropriate date representation. 	
%X 	Locale’s appropriate time representation. 	
%% 	A literal '%' character.
'''</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>147</id>
<menu>Кортежи</menu>
<submenu>Заметки</submenu>
<title>
Кортежи – коллекции объектов, которые не могут изменяться
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>148</id>
<menu>Кортежи</menu>
<submenu>Заметки</submenu>
<title>
Это упорядоченные коллекции объектов произвольных типов
Подобно строкам и спискам, кортежи являются коллекциями объектов,
упорядоченных по позициям (то есть они обеспечивают упорядочение своего содержимого слева направо). Подобно спискам, они могут содержать объекты любого типа.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>149</id>
<menu>Кортежи</menu>
<submenu>Заметки</submenu>
<title>
Обеспечивают доступ к элементам по смещению
Подобно строками и спискам, доступ к элементам кортежей осуществляется по смещению (а не по ключу) – они поддерживают все операции, которые
основаны на использовании смещения, такие как индексирование и извлечение среза.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>150</id>
<menu>Кортежи</menu>
<submenu>Заметки</submenu>
<title>Относятся к категории неизменяемых последовательностей
Подобно строкам и спискам, кортежи являются последовательностями
и поддерживают многие операции над последовательностями. Однако, подобно строкам, кортежи являются неизменяемыми объектами, поэтому
они не поддерживают никаких операций непосредственного изменения, которые применяются к спискам.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>151</id>
<menu>Кортежи</menu>
<submenu>Заметки</submenu>
<title>
Имеют фиксированную длину, гетерогенны и поддерживают произвольное число уровней вложенности
Поскольку кортежи являются неизменяемыми объектами, вы не можете
изменить размер кортежа, минуя процедуру создания копии. С другой стороны, кортежи могут хранить другие составные объекты (то есть списки,
словари и другие кортежи), а следовательно, поддерживают произвольное
число уровней вложенности.
</title>
<content> 
</content>
<print>
</print>
</item> 


<item>
<id>152</id>
<menu>Кортежи</menu>
<submenu>Заметки</submenu>
<title>Массивы ссылок на объекты.
Подобно спискам, кортежи проще представлять, как массивы ссылок на
объекты, – кортежи хранят указатели (ссылки) на другие объекты, а операция индексирования над кортежами выполняется очень быстро.
</title>
<content> 
</content>
<print>
</print>
</item> 


<item>
<id>153</id>
<menu>Кортежи</menu>
<submenu>Базовые операции</submenu>
<title>Инициализация кортежей</title>
<content> 
# Пустой кортеж
t = ()	
# Кортеж из одного элемента
t = (0,)	

print(t)

# Кортеж из 4-х элементов
t = (0, 'HI', 1.2, 3)	

print(t)

# Кортеж из 4-х элементов
t = 0, 'HI', 1.2, 3		

print(t)
</content>
<print>
(0,)
(0, 'HI', 1.2, 3)
(0, 'HI', 1.2, 3)
</print>
</item> 

<item>
<id>154</id>
<menu>Кортежи</menu>
<submenu>Базовые операции</submenu>
<title>Конкатенация кортежей</title>
<content> 
t1 = (1, 2)
t2 = (3, 4)

print(t1 + t2)
</content>
<print>
(1, 2, 3, 4)
</print>
</item> 

<item>
<id>155</id>
<menu>Кортежи</menu>
<submenu>Базовые операции</submenu>
<title>Повторение кортежей</title>
<content> 
t1 = (1, 2)

print(t1 * 2)
</content>
<print>
(1, 2, 1, 2)
</print>
</item> 

<item>
<id>156</id>
<menu>Кортежи</menu>
<submenu>Базовые операции</submenu>
<title>Индексирование,извлечение среза</title>
<content> 
t = (1, 2, 3, 4)

print(t[0])
print(t[1:3])
</content>
<print>
1
(2, 3)
</print>
</item> 

<item>
<id>157</id>
<menu>Кортежи</menu>
<submenu>Базовые операции</submenu>
<title>Методы кортежей - index(), count()</title>
<content> 
T = (1, 2, 4, 2, 4, 2) 

# Первое вхождение находится в позиции 2
print(T.index(2)) 

# Следующее вхождение за позицией 2
print(T.index(2, 2)) 

# Определить количество 4 в кортеже
print(T.count(4)) 
</content>
<print>
1
3
2
</print>
</item> 

<item>
<id>158</id>
<menu>Кортежи</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка кортежей</title>
<content> 
t = ('cc', 'aa', 'dd', 'bb')
# Создать список из элементов кортежа
tmp = list(t) 
# Отсортировать списка
tmp.sort() 

print(tmp)

# Создать кортеж из элементов списка
t1 = tuple(tmp) 

print(t1)

# Или использовать встроенную функцию sorted
t2 = sorted(t)  

print(t2) 
</content>
<print>
['aa', 'bb', 'cc', 'dd']
('aa', 'bb', 'cc', 'dd')
['aa', 'bb', 'cc', 'dd']
</print>
</item> 

<item>
<id>159</id>
<menu>Кортежи</menu>
<submenu>Базовые операции</submenu>
<title>Упаковка/распаковка кортежей</title>
<content> 
X = (1, 2)
Y = (3, 4)
# Упаковать кортежи: возвратит итерируемый объект
L = list(zip(X, Y)) 

print(L)

# Распаковать упакованные кортежи!
A, B = zip(*zip(X, Y)) 

print(A)
print(B)
</content>
<print>
[(1, 3), (2, 4)]
(1, 2)
(3, 4)
</print>
</item> 

<item>
<id>160</id>
<menu>Время</menu>
<submenu>Таймеры</submenu>
<title>Таймер для измерения времени операции</title>
<content> 
import time

def timer(func, *pargs, **kargs):
    start = time.clock()
    ret = func(*pargs, **kargs)
    elapsed = time.clock() - start
    return (elapsed, ret)


# Использование

import sys
reps = 1000000
repslist = range(reps) 


def forLoop():
    res = []
    for x in repslist:
        res.append(abs(x))
    return res

	
def listComp():
    return [abs(x) for x in repslist]

	
def mapCall():
    return list(map(abs, repslist))    

	
def genExpr():
    return list(abs(x) for x in repslist) 

	
def genFunc():
    def gen():
        for x in repslist:
            yield abs(x)
    return list(gen())

print(sys.version)

for test in (forLoop, listComp, mapCall, genExpr, genFunc):
    elapsed, result = timer(test)
    print('-' *33)
    print(' % -9s: % .5f = > [ % s... % s]' %
    (test.__name__, elapsed, result[0], result[-1]))
</content>
<print>
3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)]
---------------------------------
 forLoop  :  0.92299 = > [ 0... 999999]
---------------------------------
 listComp :  0.53183 = > [ 0... 999999]
---------------------------------
 mapCall  :  0.27382 = > [ 0... 999999]
---------------------------------
 genExpr  :  0.70114 = > [ 0... 999999]
---------------------------------
 genFunc  :  0.63332 = > [ 0... 999999]
</print>
</item> 

<item>
<id>161</id>
<menu>Разное</menu>
<submenu>shelve/picke</submenu>
<title>pickle</title>
<content> 
'''
Модуль pickle преобразует объекты, находящиеся в памяти, в последовательности байтов (в действительности – в строки), которые можно
сохранять в файлах, передавать по сети и так далее. При извлечении объектов происходит обратное преобразование: из последовательности
байтов в идентичные объекты в памяти.
'''
class someClass:
    name = 'someClassName'

import pickle

filename = 'data.txt'
object = someClass()

# Создать внешний файл
file   = open(filename, 'wb') 

# Сохранить объект в файле
pickle.dump(object, file)     
file = open(filename, 'rb')

# Позднее извлечь обратно
object = pickle.load(file)

print(object)
</content>
<print>
&lt;__main__.someClass object at 0x009A1690>
</print>
</item> 

<item>
<id>162</id>
<menu>Разное</menu>
<submenu>shelve/picke</submenu>
<title>shelve</title>
<content> 
class someClass:
    name = 'someClassName'

    def __str__(self):
        return str(self.__class__) + ' ' + self.name


import shelve
filename = 'data.txt'
object = someClass()
dbase  = shelve.open('filename')

# Сохранить под ключом key
dbase['key'] = object          
dbase  = shelve.open('filename')

# Позднее извлечь обратно
object = dbase['key'] 

print(object)
</content>
<print>
&lt;class '__main__.someClass'> someClassName
</print>
</item>


<item>
<id>163</id>
<menu>Словари</menu>
<submenu>Заметки</submenu>
<title>
Словари относятся к категории «изменяемых отображений».Словари могут изменяться непосредственно с использованием операции индексирования (они являются изменяемыми), но они не поддерживают операции над последовательностями, которые поддерживаются строками и списками. Словари представляют собой неупорядоченные коллекции,поэтому операции, которые основаны на использовании фиксированного порядка следования элементов (например, конкатенация, извлечение среза), не имеют смысла для словарей. Словари – это единственный встроенный представитель объектов-отображений (объекты, которые отображают ключи на значения).
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>164</id>
<menu>Словари</menu>
<submenu>Заметки</submenu>
<title>
Переменная длина,гетерогенность и произвольное число уровней вложенности.Подобно спискам словари могут увеличиваться и уменьшаться непосредственно (то есть без создания новых копий). Они могут содержать объекты любых типов и поддерживают возможность создания произвольного числа уровней вложенности (они могут содержать списки, другие словари и так далее).
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>165</id>
<menu>Словари</menu>
<submenu>Заметки</submenu>
<title>
Неупорядоченные коллекции произвольных объектов.В отличие от списков, элементы словарей хранятся в неопределенном порядке. В действительности, интерпретатор вносит элемент случайности в порядок следования элементов для обеспечения более быстрого поиска.Ключи описывают символическое (не физическое) местоположение элементов в словаре.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>166</id>
<menu>Словари</menu>
<submenu>Заметки</submenu>
<title>
Доступ к элементам по ключу, а не по индексу.Иногда словари называют ассоциативными массивами, или хешами. Они определяют взаимосвязь между значениями и ключами, поэтому для извлечения элементов словаря можно использовать ключи, под которыми эти элементы были сохранены в словаре. Для получения элементов словаря используется та же самая операция доступа по индексу, как и в списке, только индекс приобретает форму ключа, а не смещения относительно начала.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>167</id>
<menu>Словари</menu>
<submenu>Заметки</submenu>
<title>
Таблицы ссылок на объекты (хеш-таблицы).Если списки – это массивы ссылок на объекты, которые поддерживают возможность доступа к элементам по их позициям, то словари – это неупорядоченные таблицы ссылок на объекты, которые поддерживают доступ к элементам по ключу. Внутри словари реализованы как хеш-таблицы (структуры данных, которые обеспечивают очень высокую скорость поиска), изначально небольшого размера и увеличивающиеся по мере необходимости. Более того, интерпретатор Python использует оптимизированные алгоритмы хеширования для обеспечения максимально высокой скорости поиска ключей. Подобно спискам, словари хранят ссылки на объекты (а не их копии).
</title>
<content> 
</content>
<print>
</print>
</item> 


<item>
<id>168</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Создание словаря</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}

print(d)
print(dict([('one', 1), ('two', 2), ('three', 3)]))
print(dict('one' = 1, 'two' = 2, 'three' = 3))
print(dict(one = 1, two = 2,three = 3))
</content>
<print>
{'one': 1, 'two': 2, 'three': 3}
{'one': 1, 'two': 2, 'three': 3}
{'one': 1, 'two': 2, 'three': 3}
{'one': 1, 'two': 2, 'three': 3}
</print>
</item> 

<item>
<id>169</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Извлечение по ключу</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}

print(d['two'])
</content>
<print>
2
</print>
</item> 

<item>
<id>170</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Создание списка ключей</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}

print(list(d.keys()))
</content>
<print>
['one', 'two', 'three']
</print>
</item> 

<item>
<id>171</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Проверка на вхождение</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}

print('two' in d)
</content>
<print>
True
</print>
</item> 

<item>
<id>172</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Изменение элемента</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}
d['one'] = ['four', 'five']

print(d)
</content>
<print>
{'one': ['four', 'five'], 'two': 2, 'three': 3}
</print>
</item> 

<item>
<id>173</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Удаление элемента</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}
del d['two']

print(d)
</content>
<print>
{'one': 1, 'three': 3}
</print>
</item> 

<item>
<id>174</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Добавление элемента</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}
d['four'] = 4

print(d)
</content>
<print>
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
</print>
</item> 

<item>
<id>175</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Список значений элементов - values()</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}
l = list(d.values())

print(l)
</content>
<print>
[1, 2, 3]
</print>
</item> 

<item>
<id>176</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Метод - items()</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}

print(d.items()))
</content>
<print>
2
None
4
</print>
</item> 

<item>
<id>177</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Объединенние словарей - update()</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}
e = {'four': 4, 'five': 5, 'six': 6}
d.update(e)

print(d)
</content>
<print>
{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6}
</print>
</item> 

<item>
<id>178</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Удаление и возврат значения - pop()</title>
<content> 
d = {'one': 1, 'two': 2, 'three': 3}

print(d.pop('one'))
print(d)
</content>
<print>
1{'two': 2, 'three': 3}
</print>
</item> 

<item>
<id>179</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Структуры разреженных данных</title>
<content> 
'''
Здесь словарь использован для представления трехмерного массива, в котором только два элемента, (2,3,4) и (7,8,9), имеют определенные значения. Ключами словаря являются кортежи, определяющие координаты непустых элементов.Благодаря этому вместо трехмерной матрицы, объемной и по большей части пустой, оказалось достаточно использовать словарь из двух элементов. В такой ситуации попытка доступа к пустым элементам будет приводить к возбуждению исключения, так как эти элементы физически отсутствуют
'''
m={}
m[(2, 3, 4)]=88
m[(7, 8, 9)]=99
x=2;y=3;z=4

print(m[(x, y, z)])
print(m)
</content>
<print>
88
{(2, 3, 4): 88, (7, 8, 9): 99}
</print>
</item> 

<item>
<id>180</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Объединенние ключей и значений</title>
<content> 
# Объединить ключи и значения
L=list(zip(['a', 'b', 'c'], [1, 2, 3]))  

print(L)

# Создать словарь из результата
D = dict(L)

print(D)
</content>
<print>
{'a': 1, 'b': 2, 'c': 3}
</print>
</item> 

<item>
<id>181</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Инициализация с помощью fromkeys</title>
<content>
d = dict.fromkeys(['a', 'b', 'c'],0)

print(d)

d = dict.fromkeys('spam')

print(d)
</content>
<print>
{'a': 0, 'b': 0, 'c': 0}
{'s': None, 'p': None, 'a': None, 'm': None}
</print>
</item> 

<item>
<id>182</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Инициализация с помощью генератора</title>
<content> 
d =  {k: None for k in 'spam'}

print(d)

d = dict.fromkeys('spam')

print(d)
</content>
<print>
{'s': None, 'p': None, 'a': None, 'm': None}
{'s': None, 'p': None, 'a': None, 'm': None}
</print>
</item> 

<item>
<id>183</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Создание списков из keys, values, items</title>
<content> 
d =  {'a': 1, 'b': 2, 'c': 3}
k = list(d.keys())
v = list(d.values())
i = list(d.items())

print(k)
print(v)
print(i)
</content>
<print>
dict_keys(['a', 'b', 'c'])
dict_values([1, 2, 3])
dict_items([('a', 1), ('b', 2), ('c', 3)])
</print>
</item> 

<item>
<id>184</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>JSON в объект словаря</title>
<content> 
import json
path = r'path to file'
records = [json.loads(line) for line in open(path)]

print(records[0]["some json key in file"])
</content>
<print>
</print>
</item> 

<item>
<id>185</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Сравнивание словарей</title>
<content> 
D1 = {'a': 1, 'b': 2}
D2 = {'a': 1, 'b': 3}

print(D1 == D2)
print(sorted(D1.items()) &lt; sorted(D2.items()))
</content>
<print>
False
True
</print>
</item> 

<item>
<id>186</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Как избежать появления ошибок обращения к несуществующему ключу</title>
<content> 
m={}
m[(2, 3, 4)]=88
m[(7, 8, 9)]=99

if(2, 3, 6) in m:
	print(m[(2, 3, 6)])
else:
	print ("if/else")

try:
	print(m[(2, 3, 6)])
except KeyError:
	print("try/except")

print("m.get(2, 3, 4) = ", m.get((2, 3, 4)))
print("m.get(2, 3, 6) = ", m.get((2, 3, 6)))
</content>
<print>
if/else
try/except
m.get(2, 3, 4) =  88
m.get(2, 3, 6) =  None
</print>
</item> 

<item>
<id>187</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка ключей словаря</title>
<content> 
D = {'a':2, 'c':1, 'b':3}
k = D.keys()
l = list(k)
l.sort()
for k in l:
    print(k,D[k])
</content>
<print>
a 2
b 3
c 1
</print>
</item> 

<item>
<id>188</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Создание словарей из списков</title>
<content> 
l = [1,2,3]
n = ['one','two','three']
d=dict(zip(l, n))

print(d)
</content>
<print>
{1: 'one', 2: 'two', 3: 'three'}
</print>
</item> 

<item>
<id>189</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Проверка наличия ключей </title>
<content> 
d =  {'a': 1, 'b': 2, 'c': 3}
if 'c' in d:
	print('present', d['c'])

print(d.get('c'))
print(d.get('d'))

if d.get('c') != None:
	print('present',d['c'])
</content>
<print>
present 3
3
None
present 3
</print>
</item> 

<item>
<id>190</id>
<menu>Исключения</menu>
<submenu>Заметки</submenu>
<title>try/except
Перехватывает исключения, возбужденные интерпретатором или вашим программным кодом, и выполняет восстановительные операции.
try/finally
Выполняет заключительные операции независимо от того, возникло исключение или нет.
raise
Дает возможность возбудить исключение программно.
assert
Дает возможность возбудить исключение программно, при выполнении определенного условия.
with/as
Реализует менеджеры контекста в версиях Python 2.6 и 3.0 (в версии 2.5 является дополнительным расширением).</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>191</id>
<menu>Исключения</menu>
<submenu>Заметки</submenu>
<title>
# Сначала выполняются эти действия
try:
	statements    
	
# Запускается, если в блоке try возникло исключение name1
except name1:
	statements
# Запускается, если возникло любое из этих исключений
except (name2, name3):
	statements	   
'''	
Запускается в случае исключения name4 и получает экземпляр исключения
'''
except name4 as data:
    statements     
'''
Запускается для всех (остальных) возникших исключений
'''
except:
    statements     
'''
Запускается, если в блоке try не возникло исключения
'''
else:
    statements     
# Запускается в любом случае
finally:
	statements	   
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>192</id>
<menu>Исключения</menu>
<submenu>Заметки</submenu>
<title>
# Перехватывает все (остальные) типы исключений.
except: 				
# Перехватывает только указанное исключение.
except name: 			
# Перехватывает указанное исключение и получает соответствующий экземпляр.
except name as value: 	
# Перехватывает любое из перечисленных исключений.
except (name1, name2): 	
# Перехватывает любое из перечисленных исключений и получает соответствующий экземпляр.
except (name1, name2) as value:	
# Выполняется, если не было исключений.
else:					
# Этот блок выполняется всегда.
finally: 				
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>193</id>
<menu>Исключения</menu>
<submenu>Заметки</submenu>
<title>
Инструкция with/as может использоваться как альтернатива известной идиомы try/finally  подобно этой инструкции она предназначена для выполнения заключительных операций независимо от того, возникло ли исключение на этапе выполнения основного действия. Однако, в отличие от инструкции try/finally, инструкция with поддерживает более богатый возможностями протокол, позволяющий определять как предварительны 
with open(r'C:\misc\data') as myfile:
    for line in myfile:
print(line)
Вызываемая функция open возвращает объект файла, который присваивается имени myfile. Применительно к переменной myfile мы можем использовать обычные средства, предназначенные для работы с файлами, – в данном случае с помощью итератора выполняется чтение строки за строкой в цикле for. Однако данный объект поддерживает протокол управления контекстом, используемый инструкцией with. После того как инструкция with начнет выполнение, механизм управления контекстом гарантирует, что объект файла, на который ссылается переменная myfile, будет закрыт автоматически, даже если в цикле for во время обработки файла произойдет исключение.
</title>
<content> 
</content>
<print>
</print>
</item> 


<item>
<id>194</id>
<menu>Исключения</menu>
<submenu>Базовые операции</submenu>
<title>Обработка исключений</title>
<content> 
def fetcher(x):
    return x/0
try:
    fetcher(1)
	
# Перехватывает и обрабатывает исключение
except ZeroDivisionError as msg: 
    print(msg)
</content>
<print>
division by zero
</print>
</item>

<item>
<id>195</id>
<menu>Исключения</menu>
<submenu>Базовые операции</submenu>
<title>Возбуждение исключений</title>
<content> 
try:
	# Возбуждает исключение вручную
	raise IndexError 
	
except IndexError:
    print('got exception')
</content>
<print>
got exception
</print>
</item> 

<item>
<id>196</id>
<menu>Исключения</menu>
<submenu>Базовые операции</submenu>
<title>Пользовательские исключения</title>
<content> 
# Пользовательское исключение
class Bad(Exception): 
    pass
def doomed():
	# Вызывает экземпляр исключения
	raise Bad() 
try:
    doomed()
	
# Перехватить исключение по имени класса
except Bad: 
    print('got Bad')
</content>
<print>
got Bad
</print>
</item> 

<item>
<id>197</id>
<menu>Исключения</menu>
<submenu>Базовые операции</submenu>
<title>Заключительные операции - finally</title>
<content> 
def fetcher(x):
    return x/0
try:
    fetcher(1)
	
# Перехватывает и обрабатывает исключение
except ZeroDivisionError as msg: 
    print(msg)
finally:
    print('after except')
</content>
<print>
division by zero
after except
</print>
</item> 

<item>
<id>198</id>
<menu>Исключения</menu>
<submenu>Базовые операции</submenu>
<title>Запись ошибки в файл</title>
<content> 
class FormatError(Exception):
    logfile = 'formaterror.txt'
    
	def __init__(self, line, file):
		self.line = line
		self.file = file
    
	def logerror(self):
        log = open(self.logfile, 'a')
		print('Error at', self.file, self.line, file=log)

def parser():
    raise FormatError(40, 'spam.txt')

try:
    parser()
except FormatError as exc:
    exc.logerror()
</content>
<print>
#in formaterror.txt
Error at spam.txt 40
</print>
</item> 

<item>
<id>199</id>
<menu>Исключения</menu>
<submenu>Расширеный функционал</submenu>
<title>Нахождение файлов в папке</title>
<content> 
onlyfiles = [f for f in listdir(path_to_folder) if isfile(join(path, f))]
</content>
<print>
</print>
</item>

<item>
<id>200</id>
<menu>Файлы</menu>
<submenu>Заметки</submenu>
<title>
Чтобы открыть файл, программа должна вызвать функцию open, передав ей имя внешнего файла и режим работы. Обычно в качестве режима используется строка 'r', когда файл открывается для чтения (по умолчанию), 'w' – когда файл открывается для записи или 'a' – когда файл открывается на запись в конец 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>201</id>
<menu>Файлы</menu>
<submenu>Заметки</submenu>
<title>
Для чтения строк лучше использовать итераторы файлов.Cамый лучший,пожалуй, способ чтения строк из файла на сегодняшний день состоит в том, чтобы вообще не использовать операцию чтения из файла, файлы имеют итератор, который автоматически читает информацию из файла строку за строкой в контексте цикла for, в генераторах списков и в других итерационных контекстах.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>202</id>
<menu>Файлы</menu>
<submenu>Заметки</submenu>
<title>
Содержимое файлов находится в строках, а не в объектах. Обратите внимание: что данные, получаемые из файла,всегда попадают в сценарий в виде строки, поэтому необходимо будет выполнять преобразование данных в другие типы объектов языка Python,если эта форма представления вам не подходит. Точно так же, при выполнении операции записи данных в файл, в отличие от инструкции print,интерпретатор Python не выполняет автоматическое преобразование объектов в строки – вам необходимо передавать методам уже сформированные строки. Поэтому при работе с файлами вам пригодятся инструменты преобразования данных из строкового представления в числовое и наоборот (например, int, float, str, а также выражения форматирования строк и метод format). Кроме того, в состав Python входят дополнительные стандартные библиотечные инструменты, предназначенные для работы с универсальным объектом хранилища данных (например, модульpickle) и обработки упакованных двоичных данных в файлах (например,модуль struct).
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>203</id>
<menu>Файлы</menu>
<submenu>Заметки</submenu>
<title>
Менеджеры контекста файлов позволяют обертывать программный код,выполняющий операции с файлами, дополнительным слоем логики, который гарантирует, что после выхода за пределы блока инструкций менеджера файл будет закрыт автоматически, и позволяет не полагаться на автоматическое закрытие файлов механизмом сборки мусора 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>204</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Открытие,запись в файл</title>
<content> 
# Открывает файл (создает/очищает)
myfile = open('myfile.txt', 'w') 

# Записывает строку текста
myfile.write('hello text file\n') 
myfile.write('goodbye text file\n')

# Выталкивает выходные буферы на диск
myfile.close() 

# Открывает файл: 'r' – по умолчанию
myfile = open('myfile.txt')

# Читает строку 
str = myfile.readline() 

print(str)

str1 = myfile.readline()

print(str1)

# Пустая строка: конец файл
str2 = myfile.readline() 

print(str2)
</content>
<print>
hello text file
goodbye text file
</print>
</item> 

<item>
<id>205</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Чтение файла</title>
<content> 
# Прочитать файл целиком в строку
str = open('myfile.txt').read() 

print(str)
</content>
<print>
hello text file
goodbye text file
</print>
</item> 

<item>
<id>206</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Построчное чтение файла</title>
<content> 
# Используйте итераторы, а не методы чтения
for line in open(r'\myfile.txt',encoding='utf-8'): 
    print(line, end='')
</content>
<print>
hello text file
goodbye text file
</print>
</item> 

<item>
<id>207</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Сохранение и интерпретация объектов Python в файлах</title>
<content> 
'''
Объекты языка Python должны
записываться в файл только в виде строк
'''
X, Y, Z = 43, 44, 45 
S = 'Spam' 
D = {'a': 1, 'b': 2}
L = [1, 2, 3]

# Создает файл для записи
F = open('datafile.txt', 'w')

# Строки завершаются символом \n
F.write(S + '\n') 

# Преобразует числа в строки
F.write('%s,%s,%s\n' % (X, Y, Z))

# Преобразует и разделяет символом $
F.write(str(L) + '$' + str(D) + '\n') 
F.close()
F = open('datafile.txt').read()

print(F)
</content>
<print>
Spam
43,44,45
[1, 2, 3]${'a': 1, 'b': 2}
</print>
</item> 

<item>
<id>208</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Восстановление объектов из файла</title>
<content> 
# Открыть файл
F = open('datafile.txt')

# Прочитать одну строку
line = F.readline()         

print(line)

line = F.readline()

# Разбить на подстроки по запятым и преобразовать в список целых чисел
l = [int(x) for x in line.split(',')]

print(l)
line = F.readline()

# Разбить на строки по символу $
m = line.split('$')        

# Преобразовать строку в объект 
l = eval(m[0])             

print(l)

d = eval(m[1])

print(d)
</content>
<print>
Spam
[43, 44, 45]
[1, 2, 3]
{'a': 1, 'b': 2}
</print>
</item> 

<item>
<id>209</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Запись/чтение объектов Python с помощью модуля pickle</title>
<content> 
D = {'a': 1, 'b': 2}
F = open('datafile.txt', 'wb')

import pickle

# Модуль pickle запишет в файл любой объект
pickle.dump(D, F)   
F.close()
F = open('datafile.txt', 'rb')

# Загружает любые объекты из файла
E = pickle.load(F)  

print(E)
</content>
<print>
{'a': 1, 'b': 2}
</print>
</item> 

<item>
<id>210</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Сохранение и интерпретация упакованных двоичных данных в файлах
</title>
<content> 
import struct

# Открыть файл для записи в двоичном режиме
F = open('data.bin', 'wb') 
values = (1, 5, 2.7,2.5,b'hgf')

# формат 2 int,2 float,строка из 3-х символов
data = struct.pack('&lt;2i2f3s',*values)    

# Записать строку байтов
F.write(data) 
F.close()
F = open('data.bin', 'rb')

# Получить упакованные двоичные данные
data = F.read() 
values = struct.unpack('&lt;2i2f3s', data)

print(values)
</content>
<print>
spam...99...['eggs']|..
</print>
</item>

<item>
<id>211</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Перенаправление потока в файл</title>
<content> 
import sys

# Перенаправить вывод в файл
sys.stdout = open('log.txt', 'a') 

while True:
    reply =input()
    print(reply)
    if reply == 'stop':break
</content>
<print>
</print>
</item>

<item>
<id>212</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Посимвольное чтение файла</title>
<content> 
x, y, z = 'spam', 99, ['eggs']

print(x, y, z, sep='...', end='|..\n',file=open('data.txt', 'w'))
file = open('data.txt')

while True:
	# Читать по одному символу
    char = file.read(1)
    if not char: break
    print(char, end='')

for char in open('data.txt').read():
    print(char, end='')
</content>
<print>
spam...99...['eggs']|..
spam...99...['eggs']|..
</print>
</item>

<item>
<id>213</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Чтение файла построчно</title>
<content> 
x, y, z = 'spam', 99, ['eggs']

print(x, y, z, sep='...', end='|..\n',file=open('data.txt', 'w'))
file = open('data.txt')

while True:
	# Читать строку за строкой
    line = file.readline() 
    if not line: break
	
	# Прочитанная строка уже содержит символ \n
    print(line, end=' ')   

file = open('data.txt', 'rb')

while True:
	# Читать блоками по 10 байтов
    chunk = file.read(10)  
    if not chunk: break
    print(chunk)
</content>
<print>
spam...99...['eggs']|..
 b'spam...99.'
b"..['eggs']"
b'|..\r\n'
</print>
</item>

<item>
<id>214</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Чтение файла построчн (2)о</title>
<content> 
x, y, z = 'spam', 99, ['eggs']

print(x, y, z, sep='...', end='|..\n',file=open('data.txt', 'w'))
'''
Метод файлов readlines загружает файл целиком в список строк, тогда как при использовании итератора файла в каждой итерации загружается только одна строка
'''

for line in open('data.txt').readlines():
    print(line, end='')
'''
Использование итератора: лучший способ чтения текста
'''
for line in open('data.txt'): 	
    print(line, end='') 		
</content>
<print>
spam...99...['eggs']|..
spam...99...['eggs']|..
</print>
</item>

<item>
<id>215</id>
<menu>Встроеные функции</menu>
<submenu>Заметки</submenu>
<title>
lambda функции
Выражение lambda создает объект и возвращает его в виде результата.Функции могут также создаваться с помощью выражения lambda. Это позволяет создавать встроенные определения функций там, где синтаксис языка не позволяет использовать инструкцию def 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>216</id>
<menu>Встроеные функции</menu>
<submenu>Заметки</submenu>
<title>
yield передает объект результата вызывающей программе и запоминает,где был произведен возврат. Функции, известные как генераторы, для передачи возвращаемого значения могут также использовать инструкцию yield и сохранять свое состояние так, чтобы работа функции могла быть возобновлена позднее 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>217</id>
<menu>Встроеные функции</menu>
<submenu>Заметки</submenu>
<title>
nonlocal объявляет переменные, находящиеся в области видимости объемлющей функции, без присваивания им значений. В Python 3 появилась новая инструкция nonlocal, позволяющая функциям присваивать значения переменным, находящимся в области видимости синтаксически объемлющей функции. Это позволяет использовать объемлющие функции, как место хранения информации о состоянии – информация восстанавливается в момент вызова функции, при этом отпадает необходимость использовать глобальные переменные. 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>218</id>
<menu>Встроеные функции</menu>
<submenu>Заметки</submenu>
<title>
lambda – это выражение, а не инструкция. По этой причине ключевое слово lambda может появляться там, где синтаксис языка Python не позволяет использовать инструкцию def, – внутри литералов или в вызовах функций, например. Кроме того, lambda-выражение возвращает значение (новую функцию), которое при желании можно присвоить переменной, в противовес инструкции def, которая всегда связывает функцию с именем в заголовке, а не возвращает ее в виде результата. 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>219</id>
<menu>Встроеные функции</menu>
<submenu>Заметки</submenu>
<title>
Тело lambda – это не блок инструкций, а единственное выражение. Тело lambda-выражения сродни тому, что вы помещаете в инструкцию return внутри определения def, – вы просто вводите результат в виде выражения вместо его явного возврата. Вследствие этого ограничения lambda-выражения менее универсальны, чем инструкция def – в теле lambda-выражения может быть реализована только логика, не использующая такие инструкции, как if. Такая реализация предусмотрена заранее – она ограничивает возможность создания большого числа уровней вложенности программ: lambdaвыражения предназначены для создания простых функций, а инструкции def – для решения более сложных задач. 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>220</id>
<menu>Pandas</menu>
<submenu>Операции с файлами</submenu>
<title>Переформатирование пробелов</title>
<content> 
result =pd.read_taЫe('ch06/ex3.txt',  sep='\s+') 
</content>
<print>
</print>
</item>

<item>
<id>221</id>
<menu>Pandas</menu>
<submenu>Операции с файлами</submenu>
<title>Пропуск строк в начале файла</title>
<content>
pd.read_csv('ch06/ex4.csv',skiprows=[0,2,3])
</content>
<print>
</print>
</item>

<item>
<id>222</id>
<menu>Pandas</menu>
<submenu>Операции с файлами</submenu>
<title>Чтение файла порциями</title>
<content> 
# 5 строк
pd.read_csv( 'ch06/ex6.csv', nrows=5) 

# 1000 строк
pd.read_csv('ch06/ex6.csv', chunksize=l000) 
</content>
<print>
</print>
</item>

<item>
<id>223</id>
<menu>Pandas</menu>
<submenu>Операции с файлами</submenu>
<title>Вывод данных в файл </title>
<content>
# с разделителем
data.to_csv(data,sep='|',na_rep='NULL)

# Отсутствующие значения представлены пустыми строками
data.to_csv(data,sep='|',na_rep='NULL)  

# Удалить метки строк и столбцов
data.to_csv(sys.stdout, index=False, header=False) 

# Можно также вывести лишь подмножество столбцов, задав их порядок
data.to_csv(sys.stdout,index=False, cols=['a', 'b',  'с')) 
</content>
<print>
</print>
</item>

<item>
<id>224</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
SERIES (1D)

One-dimensional array-like object containing an array of data (of any NumPy data type) and an associated array of data labels, called its “index”. If index of data is not specified, then a default one consisting of the integers 0 through N-1 is created.
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>225</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
Create Series 

series1  = pd.Series ([1, 2], index = ['a', 'b'])
series1 = pd.Series(dict1)

* 
Can think of Series as a fixed-length, ordered dict. Series can be substitued into many functions that expect a dict
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>226</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
# Get Series Values
series1.values


# Get Values by Index
series1['a'] 
series1[['b','a']]


# Get Series Index
series1.index


# Get Name Attribute(None is default)
series1.name
series1.index.name


# Common Index Values are Added
series1 + series2
#Auto-align differently-indexed data in arithmetic operations


# Unique But Unsorted
series2 = series1.unique() 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>227</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
DATAFRAME (2D)

Tabular data structure with ordered collections of columns, each of which can be different value type.Data Frame (DF) can be thought of as a dict of Series.
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>228</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
#Create DF (from a dict of equal-length lists or NumPy arrays)
dict1 = {'state': ['Ohio', 'CA'], 'year': [2000, 2010]}
df1 = pd.DataFrame(dict1)

# columns are placed in sorted order 
df1 = pd.DataFrame(dict1,index = ['row1', 'row2']))

# specifying index
df1 = pd.DataFrame(dict1,columns = ['year', 'state'])

# columns are placed in your given order (from nested dict of dicts) 
# The inner keys as row indices
dict1= {'col1':{'row1': 1, 'row2': 2}, 'col2': {'row1': 3, 'row2': 4}}
df1 = pd.DataFrame(dict1)
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>229</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
# Get Columns and Row Names
df1.columns
df1.index

# Get Name Attribute (None is default)
df1.columns.name
df1.index.name

# Get Values
df1.values
# returns the data as a 2D ndarray, the dtype will be chosen to accomandate all of the columns

# Get Column as Series ** 
df1['state'] or df1.state

# Get Row as Series **
df1.ix['row2'] or df1.ix[1]
**  
Data returned is a ‘view’ on the underlying data, NOT a copy. Thus, any in-place modificatons to the data will be reflected in df1.

# Assign a column that doesn’t exist will create a new column
df1['eastern'] = df1.state == 'Ohio'

# Delete a column 
del df1['eastern']

# Switch Columns and Rows
df1.T
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>230</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
HIERARCHICAL INDEXING
Multiple index levels on an axis : A way to work with higher dimensional data in a lower dimensional form.
MultiIndex : 

series1 = Series(np.random.randn(6), 
		index = [['a', 'a', 'a', 'b', 'b', 'b'], [1, 2, 3, 1, 2, 3]])
series1.index.names = ['key1', 'key2']

# Series Partial Indexing
# Outer Level
series1['b']  

# Inner Level
series1[:, 2] 

# DF Partial Indexing
df1['outerCol3','InnerCol2']               
Or
df1['outerCol3']['InnerCol2']
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>231</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
Swaping and Sorting Levels

#Swap Level (level interchanged) *
swapSeries1 = series1.swaplevel('key1', 'key2')
* 
The order of the rows do not change. Only the two levels got swapped.

# Sort Level
# sorts according to first inner level
series1.sortlevel(1) 

# Common Ops : Swap and Sort **
series1.swaplevel(0, 1).sortlevel(0)
# the order of rows also change
**  
Data selection performance is much better if the index is sorted starting with the outermost level, as a result of calling sortlevel(0) or sort_index(). 
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>232</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
Summary Statistics by Level
# Most stats functions in DF or Series have a “level” option that you can specify the level you want on an axis. 

# Sum rows (that have same ‘key2’ value)
df1.sum(level = 'key2')

# Sum columns ..
df1.sum(level = 'col3', axis = 1)
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>233</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
DataFrame’s Columns as Indexes
# DF’s “set_index” will create a new DF using one or more of its columns as the index

New DF using columns as index
df2 = df1.set_index(['col3', 'col4']) * 

# col3 becomes the outermost index, col4 becomes inner index. Values of col3, col4 become the index values.
# By default, 'col3' and 'col4' will be removed from the DF, though you can leave them by option : 'drop = False'

</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>234</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
Missing  DATA

---Use pd.isnull(),pd.notnull() or series1/df1.isnull() to detect missing data. 

dropna() returns with ONLY non-null data, source data NOT modified.

# drop any row containing missing value
df1.dropna() 


# drop any column containing missing values
df1.dropna(axis = 1)  

  
# drop row that are all missing
df1.dropna(how = 'all') 


# drop any row containing &lt; 3 number of observations
df1.dropna(thresh = 3)  
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>235</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
FILLING IN MISSING DATA

# fill all missing data with 0 
df2 = df1.fillna(0)    

# modify in-place
df1.fillna('inplace = True') 


# Use a different fill value for each column :
df1.fillna({'col1' : 0, 'col2' : -1})


# Only forward fill the 2 missing values in front :
df1.fillna(method = 'ffill', limit = 2)
i.e. for column1, if row 3-6 are missing. so 3 and 4 get filled 
with the value from 2, NOT 5 and 6.
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>236</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
INDEXING (SLICING/SUBSETTING)

# Index by Column(s)
df1['col1']            
df1[ ['col1', 'col3'] ]

#Index by Row(s)
df1.ix['row1']          
df1.ix[ ['row1', 'row3'] ] 

# Index by Both Column(s) and Row(s)
df1.ix[['row2', 'row1'], 'col3']

# Boolean Indexing
df1[ [True, False] ]
df1[df1['col2'] > 6] * 
# returns df that has col2 value > 6
# Note that df1['col2'] > 6 returns a boolean Series, with each True/False value determine whether the respective row in the result.NoteAvoid integer indexing since it might introduce subtle bugs (e.g. series1[-1]). If have to use position-based indexing, use "iget_value()" from Series and "irow/icol()" from DF instead of integer indexing.
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>237</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
DROPPING ROWS/COLUMNS

# Drop operation returns a new object (i.e. DF) :
# Remove Row(s) (axis = 0 is default) 
df1.drop('row1')            
df1.drop(['row1', 'row3'])

# Remove Column(s)
df1.drop('col2', axis = 1) 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>238</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
REINDEXING

Create a new object with rearraging data conformed to a new index, introducing missing values if any index values were not already present. 

# Change df1 Date Index Values to the New Index Values 
date_index = pd.date_range('01/23/2010', periods = 10, freq = 'D')

# (ReIndex default is row index) 
df1.reindex(date_index)

# Replace Missing Values (NaN) with 0
df1.reindex(date_index, fill_value = 0) 

# ReIndex Columns
df1.reindex(columns = ['a', 'b'])

# ReIndex Both Rows and Columns
df1.reindex(index = [..], columns = [..])

# Succinct ReIndex
df1.ix[[..], [..]]
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>239</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
ARITHMETIC AND DATA ALIGNMENT
 
• df1 + df2 : For indices that don’t overlap, internal data alignment introduces NaN

# Instead of NaN, replace with 0 for the indice that is not found in th df :   
df1.add(df2, fill_value = 0)    
   
# Useful Operations :   
df1 - df1.ix[0] 
# subtract every row in df1 by first row
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>240</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
SORTING AND RANKING
Sort Index/Column 

sort_index() returns a new, sorted object. Default is “ascending = True”.
Row index are sorted by default, “axis = 1” is used for sorting column.
Sorting Index/Column means sort the row/column labels, not sorting the data.

Sort Data 
Missing values (np.nan) are sorted to the end of the Series by default

# Series Sorting
sortedS1 = series1.order()

# In-place sort
series1.sort() 

DF Sorting
# sort by col2 first then col1
df1.sort_index(by = ['col2', 'col1']) 

Ranking 
Break rank ties by assigning each tie-group the mean rank. (e.g. 3, 3 are tie as the 5th place; thus, the result is 5.5 for each)

# Output Rank of Each Element 
series1.rank()

# (Rank start from 1)
df1.rank(axis = 1)        
# rank each row’s value
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>241</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
FUNCTION APPLICATIONS

NumPy works fine with pandas objects : np.abs(df1)

# Applying a Function to Each Column or Row(Default is to apply to each column : axis = 0)
# return a scalar value
f = lambda x: x.max() - x.min() 

def f(x): return 
# return multiple values
Series([x.max(), x.min()]) 
df1.apply(f)    


# Applying a Function Element-Wise
f = lambda x: '%.2f' %x
df1.applymap(f)           
# format each entry to 2-decimals
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>242</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
GROUPBY (SPLIT-APPLY-COMBINE)
- Similar to SQL groupby

# Compute Group Mean       
df1.groupby('col2').mean()

# GroupBy More Than One Key
# result in hierarchical index consisting of unique pairs of keys
df1.groupby([df1['col2'], df1['col3']]).mean()

# “GroupBy” Object :(ONLY computed intermediate data about the group key - df1['col2']
grouped = df1['col1'].groupby(df1['col2'])
# gets the mean of each group formed by 'col2'
grouped.mean() 

# Indexing “GroupBy” Object       
# select ‘col1’ for aggregation : 
df1.groupby('col2')['col1'] 
or
df1['col1'].groupby(df1['col2']) 

Note
Any missing values in the group are excluded 
from the result


1. Iterating over GroupBy object
“GroupBy” object supports iteration : generating a sequence of 2-tuples containing the group name along with the chunk of data.

for name, groupdata in df1.groupby('col2'):
# name is single value, groupdata is filtered DF contains data only match that single value.
for (k1, k2), groupdata in df1.groupby(['col2', 'col3']):
# If groupby multiple keys : first element in the tuple is a tuple 
of key values


# Convert Groups to Dict  
# col2 unique values will be keys of dict     
dict(list(df1.groupby('col2'))) 


# Group Columns by “dtype”
grouped = df1.groupby([df1.dtypes, axis = 1)
# separates data Into different types
dict(list(grouped))            

2. Grouping with functions
Any function passed as a group key will be called once per (default is row index) value, with the return values being used as the group names. (This assumes row index are named)

# returns a DF with row index that are length of the names. Thus, names of same length will sum their values. Column names retain.
df1.groupby(len).sum()
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>243</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
DATA AGGREGATION 
Data aggregation means any data transformation that produces scalar values from arrays, such as “mean”, “max”, etc

# Use Self-Defined Function def func1(array): ...
grouped.agg(func1)

# Get DF with Column Names as Fuction Names
grouped.agg([mean, std])

# Get DF with Self-Defined Column Names 
grouped.agg([('col1', mean), ('col2', std)])

# Use Different Fuction Depending on the Column   
grouped.agg({'col1' : [min, max], 'col3' : sum})
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>244</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
GROUP-WISE OPERATIONS AND TRANSFORMATIONS
Agg() is a special case of data transformation, aka reduce a one-dimensional array to scalar

Transform() is a specialized data transformation : 
• It applies a function to each group, if it produces a scalar value, the value will be placed in every row  of the group. Thus, if DF has 10 rows, after “transform()”, there will be still 10 rows, each one with the scalar value from its respective group’s value from the function. 
• The passed function must either produce a scalar value or a transformed array of same size.

General purpose transformation : apply()

# your func ONLY need to return a pandas object or a scalar.
df1.groupby('col2').apply(your_func1)


# Example 1 : Yearly Correlations with SPX  
# “close_price” is DF with stocks and SPX closed price columns and dates index 
returns = close_price.pct_change().dropna()
by_year = returns.groupby(lambda x : x.year) 
spx_corr = lambda x : x.corrwith(x['SPX'])by_year.apply(spx_corr)

# Example 2 : Exploratory Regression
import statsmodels.api as sm
def regress(data, y, x):
	Y = data[y]; 
	X = data[x]
	X['intercept'] = 1
	result = sm.OLS(Y, X).fit()
	return result.params    
by_year.apply(regress, 'AAPL', ['SPX'])
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>245</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
COMBINING AND MERGING DATA

1. pd.merge() akadatabase “join” : connects rows in DF based on one or more keys.

Merge via Column (Common)
df3  = pd.merge(df1, df2, on = 'col2') * 
# INNER join is default Or use option : how = 'outer/left/right'
# the indexes of df1 and df2 are discarded in df3
Use ALL overlapping column names as the keys to merge. Good practice is to specify the keys :on = [‘col2’, ‘col3’]
If different key name in df1 and df2, use option : left_on=’lkey’, right_on=’rkey’

Merge via Row (Uncommon)
df3 = pd.merge(df1, df2, left_index = True, right_index = True)
# Use indexes as merge key : aka rows with same index 
value are joined together

2. pd.concat(): glues or stacks objects along an axis (default is along “rows : axis = 0”)
df3 = pd.concat([df1, df2], ignore_index = True) 
# ignore_index = True : Discard indexes in df3
# If df1 has 2 rows, df2 has 3 rows, then df3 has 5 rows

3. combine_first(): combine data with overlap, patching missing value.
df3 = df1.combine_first(df2) 
# df1 and df2 indexes overlap in full or part. If a row NOT exist in df1 but in df2, it will be in df3. If row1 of df1 and row3 of df2 have the same index value, but row1’s col3 value is NA, df3 get this row with the col3 data from df2
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>246</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
RESHAPING AND PIVOTING

1. Reshaping with Hierarchical Indexing
series1  = df1.stack()
# Rotates (innermost level *) columns to rows as innermost index level, resulted in Series with hierarchical index.
df1 = series1.unstack()
# Rotates (innermost level *) rows to columns as innermost column level.
 *
Default is to stack/unstack innermost level. If want a different level, i.e.stack(level = 0) - the outermost level.  Note : Unstacking might introduce missing data if not all of the values in the level aren’t found in each of the subgroups. Stacking filters out missing data by default, i.e. data.unstack().stack()


2. Pivoting
• Common format of storing multiple “time series” in databases and CSV is :Long/Stacked Format :“date, stock_name, price”
• However, a DF with these 3 columns data like above will be difficult to work with. Thus, “wide” format is prefered : ‘date’ as row index, ‘stock_name’ as columns, ‘price’ as DF data values.
# Example pivotedDf2 
pivotedDf2  = df1.pivot('date', 'stock_name', 'price')

#                          AAPL     IBM       JD
#  2003-06-01     120.2    100.1     20.8
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>247</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
COMMON OPERATIONS

1. Removing Duplicate Rows
#  Boolean series1 indicating whether each row is a duplicate or not.
series1 = df1.duplicated() 

# Duplicates has been dropped in df2 
df2  = df1.drop_duplicates()

2.  Add New Column Based On Value of Column(s)

# Maps col2 value as dict1‘s key, gets dict1‘s value
df1['newCol'] = df1['col2'].map(dict1)  

# Apply a function to each col2 value
df1['newCol'] = df1['col2'].map(func1)  

3. Replacing Values

# Replace is NOT In-Place
df2 = df1.replace(np.nan, 100)

# Replace Multiple Values At Once
df2 = df1.replace([-1, np.nan], 100) 
df2 = df1.replace([-1, np.nan], [1, 2])

# Argument Can Be a Dict As Well
df2 = df1.replace({-1: 1, np.nan : 2})

4. Renaming Axis Indexes

# Convert Index to Upper Case
df1.index = df1.index.map(str.upper)

# Rename ‘row1’ to ‘newRow1’
df2 = df1.rename(index = {'row1' : 'newRow1'}, columns = str.upper) 
# Optionally inplace = True

5. Discretization and Binning
• Continuous data is often discretized into “bins” for analysis.
# Divide Data Into 2 Bins of Number (18 - 26], (26 - 35]  ‘]’ means inclusive, ‘)’ is NOT inclusive

bins = [18, 26, 35]

# cat is “Categorical” object.
cat = pd.cut(array1, bins,  labels=[..])  
pd.value_counts(cat)

# Compute equal-length bins based on min and max values in array1
cat = pd.cut(array1, numofBins) 

# Bins the data based on sample quantiles - roughly equal-size bins
cat = pd.qcut(array1, numofBins)

6. Detecting and Filtering Outliers
• any() test along an axis if any element is “True”. 
Default is test along column (axis = 0).

# Select all rows having a value &gt; 3 or &lt; -3.
df1[(np.abs(df1) > 3).any(axis = 1)]    

# Another useful function : 
np.sign() returns 1 or -1.

7. Permutation and Random Sampling
randomOrder = np.random.permutation(df1.shape[0]) 
df2 = df1.take(randomOrder)

8. Computing Indicator/Dummy Variables
• If a column in DF has “K” distinct values, derive a “indicator” DF containing K columns of 0s and 1s.1 means exist, 0 means NOT exist

# Add prefix to the K column names
dummyDf = pd.get_dummies(df1['col2'], prefix = 'col-')

</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>248</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
TEXT FORMAT (CSV)

df1 = pd.read_csv(file/URL/file-like-object, sep = ',', header = None)

# Type-Inference : do NOT have to specify which columns are numeric, integer, boolean or string.
# In Pandas, missing data in the source data is usually empty string, NA, -1, #IND or NULL. You can specify missing values via option i.e. : na_values = ['NULL'].
# Default delimiter is comma.
# Default is first row is the column header.
df1 = pd.read_csv(.., names = [..])

# Explicitly specify column header, also imply first row is data
df1 = pd.read_csv(.., names = [.., 'date'], index_col = 'date')

# Want 'date' column to be row index of the returned DF
df1.to_csv(filepath/sys.stdout, sep = ',')

# Missing values appear as empty strings in the output. Thus, It is better to add option i.e. : na_rep = 'NULL'
# Default is row and column labels are written. Disabled by options : index = False, header = False
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>249</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
JSON (JAVASCRIPT OBJECT NOTATION) DATA
One of the standard formats for sending data by HTTP request between web browsers and other applications.It is much more flexible data format than tabular text from like CSV.

# Convert JSON string to Python form
data = json.load(jsonObj)

# Convert Python object to JSON
asJson = json.dumps(data)

# Create DF from JSON
df1 = pd.DataFrame(data['name'], columns = ['field1'])
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>250</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
XML AND HTML DATA

HTML : 
doc  = lxml.html.parse(urlopen('http://..')).getroot()
tables = doc.findall('.//table')         
rows = tables[1].findall('.//tr')

XML :                                                                                
lxml.objectify.parse(open(filepath)).getroot()
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>251</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
Descriptive Statistics Methods

Compared with equivalent methods of ndArray, descriptive statistics methods in Pandas are built from the ground up to exclude missing data.NA (i.e. NaN) values are excluded. This can be disabled using the "skipna = False" option. 

# Column Sums  (Use axis = 1 to sum over rows)   
series1 = df1.sum()

# Returns Index Labels Where Min/Max Values are Attained 
df1.idxmin()  or  df1.idxmax()

# Mutiple Summary Statistics (i.e. count, mean, std) On Non-Numeric Data, Alternate Statistics (i.e. count, unique)
df1.describe()
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>252</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
CORRELATION AND COVARIANCE

• cov(), corr()
• corrwith() - pairwise correlations : aka compute a DF with a Series. If input is not Series, but another DF, it will compute the correlations of matching column names. i.e. returns.corrwith(volumes)

# Example : Correlation 
import pandas_datareader.data as web
data = {}
for ticker in ['AAPL', 'JD']:
	data[ticker] = web.get_data_yahoo(ticker, '1/1/2000', '1/1/2010')
	prices = pd.DataFrame({ticker : d['Adj Close'] for ticker, d in data.iteritems()})    
	volumes = ...
returns = prices.pct_change()
returns.AAPL.corr(returns.JD)
# Series corr() computes correlation of overlapping, non-NA, aligned-by-index values in two Series
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>253</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
TIME SERIES

• Python standard library data types for date and time :   “datetime”, “time”, “calendar”. 
• Pandas data type for date and time : “Timestamp”. *
“datetime” is widely used, it stores both the date and time down to microsecond.“Timestamp” object can be substituted anywhere you would use “datetime” object.

# Convert String to DateTime
from datetime import datetime
datetime.strptime('8/8/2008','%m/%d/%Y')

#Get Time Now
now = datetime.now()

# DateTime Arithmetic
from datetime import timedelta
# Timedelta represents temporal difference between two datetime objects.
datetime(2011, 1, 8) + timedelta(12) => 2011-01-20

# Convert String to Pandas Timestamp Type
timestamps = pd.to_datetime(['8/8/2008', ..])

# NaT (Not a Time) is Pandas NA Value for Timestamp Data
pd.to_datetime('') => NaT  
pd.isnull(NaT) => True
# Missing value (i.e. empty string)
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>254</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
PANDA TIME SERIES 

Create Time Series
ts1 = pd.Series(np.random.randn(8), index = [ datetime(2011, 1, 2), .. ])
ts1 = pd.Series(..., index = pd.date_range('1/1/2000', periods = 1000)) 
# ts1.index is "DatetimeIndex" Panda class

Index value ts1.index[0] is Panda “Timestamp” object which stores timestamp using NumPy’s “datetime64” type at the nanoseond resolution.  Further, Timestamp class stores the frequency information as well as timezone.ts1.index.dtype => datetime64[ns]
Indexing (Slicing/Subsetting)
Argument can be a string date, datetime or Timestamp. 

# Select Year of 2001
ts1['2001'] 
df1.ix['2001']

# Select June 2001
ts1['2001-06']

# Select From 2001-01-01 to 2001-08-01
ts1['1/1/2001':'8/1/2001'] 

# Select From 2001-01-08 On
ts1[datetime(2001, 1, 8):]

Common Operations

# Get Time Series Data Before 2011-01-09
ts1.truncate(after = '1/8/2011')
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>255</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
DATE RANGES, FRQUENCIES AND SHIFTING
Generic time series in Pandas are assumed to be irregular, aka have no fixed frequency. However, we prefer to work with fixed frequency, i.e. daily, monthly, etc.

# Take a Look at “Resampling” Section 
# Convert to Fixed Daily Frequency.              
# Introduce Missing Value (NaN) If Needed
ts1.resample('D', how = ..)

1. Frequencies and Date Offsets

• Frequencies in Pandas are composed of a base frequency and a multiplier. Base frequencies are typically referred to by a string alias, like ‘M’ for monthly or ‘H’ for hourly.
# Standard US equity option monthly expirataion, every third Friday of the month : freq = 'WOM-3FRI'
freq = '4H'                
freq = '1h30min'

2. Generating Date Ranges

# Default Frequency is Daily
pd.date_range(begin, end)  
pd.date_range(begin or end, periods = n)
# Option freq = 'BM' means last business day at end of the month 

3. Shifting (Leading and Lagging) Data
• Shifting refers to moving data backward and forward through time. 
• Series and DF “shift()” does naive shift, aka index does not shift, only value. *

# ts1 is Daily Data
ts1.shift(1) 

# move yesterday’s value to today, today value to tomorrow, etc.
# ts1 is Any Time Series Data. Shift Data By 3 Days
ts1.shift(3, freq = 'D') 
ts1.shift(1, freq = '3D')

# Common Use of Shift : To Computer % Change
ts1 / ts.shift(1) - 1
* In the return result from shift(), some data value might be NaN.


• Other ways to shift data :from pandas.tseries.offsets import Day, MonthEnd
datetime(2008, 8, 8) + 3*Day() => 2008-08-11
datetime(2008, 8, 8) + MonthEnd(2) => 2008-09-30
MonthEnd().rollforward(datetime(2008, 8, 8)) => 2008-08-31
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>256</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
TIME ZONE HANDLING
• Daylight saving time (DST) transitions are a common source of complication.
• UTC is the current international standard. Time zones are expressed as offsets from UTC. 

1. Python Time Zone (From 3rd-party pytz library)

# Get List of Timezone Names
pytz.common_timezones

# Get a Timezone Object
pytz.timezone('US/Eastern')

2. Localization and Conversion

#Time Series By Default is Time Zone Naive
ts1.index.tz => None

# Specify Time Zone When Create Time Series
Use option : tz = 'UTC' in pd.date_range()

# Localization From Naive
ts1_utc = ts1.tz_localize('UTC')

# Convert to Another Time Zone Once Time Series Been Localized
ts1_eastern = ts1_utc.tz_convert('US/Eastern')

3. ** Time Zone-aware Timestamp Objects
stamp_utc = pd.Timestamp('2008-08-08 03:00', tz = 'UTC')
stamp_eastern = stamp_utc.tz_convert(...)

# Panda’s Time Arithmetic - Daylight Savings Time Transitions Are Respected :
stamp = pd.Timestamp('2012-11-04 00:30', tz = 'US/Eastern') => 2012-11-04-00:30:00 -400 EDT
stamp + 2 * Hour() => 2012-11-04-01:30:00 -500 EST
** If two time series with different time zones are combined, i.e. ts1 + ts2, the timestamps will auto-align with respect to time zone. The result will be in UTC.

</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>257</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
RESAMPLING
Process of converting a time series from one frequency to another frequency :
1. Downsampling -  Aggregating higher frequency 
data to lower frequency.
* ts1.resample('M', how = 'mean') => Index : 2000-01-31,  2000-02-29,  ... 
ts1.resample('M', ..., kind ='period')  
# 'period' - Use time-span representation
=> Index : 2000-01,  2000-02,  ... 
# ts1 is one minute data of value 1 to 100 of time : 
00:00:00,  00:01:00,   ...
ts1.resample('5min', how = 'sum') 
=> 
00:00:00      15      (aka : 1 + 2 + 3 + 4 + 5)                                                               
00:05:00      40

# Default is left bin edge is inclusive, thus 00:00:00 value in 
included in the 00:00:00 to 00:05:00 interval.

# Option : closed = 'right' change interval to right inclusive. Also include option abel =  'right' as well :  
00:00:00      1                                                                     
00:05:00      20     (aka : 2 + 3 + 4 + 5 + 6)

# returns a DF with 4 columns - open, high, low , close
ts1.resample('5min', how = 'ohlc')      
* Alternate way to downsample :  ts1.groupby(lamba x : x.month).mean()


2. Upsampling and Interpolation * -
 Interpolate low frequency to higher frequency. By default missing values (NaN) are introduced.
df1.resample('D', fill_method = 'ffill')   

# Forward fills values : i.e. missing value index such as 
index 3 will copy value from index 2. 
* Interpoation will ONLY apply row-wise.
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>258</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
TIME SERIES PLOTTING
# Example : Source Data Format - First Column is Date. 
Use first column as the Index, then parse the index values as 

Date.prices = pd.read_csv(.., parse_date = True, index_col = 0)
px = prices[['AAPL', 'IBM']]              
px = px.resample('B', fill_method = 'ffill')
px['AAPL'].plot() 
px['AAPL'].ix['01-2008':'03-2012'].plot()
px.ix['2008'].plot()
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>259</id>
<menu>Pandas</menu>
<submenu>Шпаргалки(англ.)</submenu>
<title>
MOVING WINDOW FUNCTIONS
Like other statistical functions, these functions also 
automatically exclude missing data
.pd.rolling_mean(px.AAPL, 200).plot() 
pd.rolling_std(px.AAPL.pct_change(), 22, min_periods = 20).plot()
pd.rolling_corr(px.AAPL.pct_change(), px.IBM.pct_change(), 22).plot()

PERFORMANCE
• Since “Timestamps” is represented as 64-bit integers using NumPy’s datetime64 type, it means for each data point, there is an associated 8 bytes of memory per timestamp.
• “Creating views” on existing time series or DF do not cause any more memory to be used.
• Indexes for lower frequencies (daily and up) are stored in a central cache, so any fixed-frequency index is a view on the date cache.Thus, low-frequency indexes memory footprint is not significant.
• Performance-wise, Pandas has been highly optimized for data alignment operations (i.e. ts1 + ts2) and resampling
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>260</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>Вычитание классов и чисел - __del__</title>
<content> 
class Number:
	# Вызов Number(start)
    def __init__(self, start):           
        self.data = start
		
	# Выражение: экземпляр - other
    def __sub__(self, other):            
		# Результат – новый экземпляр
        return Number(self.data - other)
		# Результат – число
		#return self.data - other 
		
# Number.__init__(X, 5)
X = Number(5)

# Number.__sub__(X, 2) 
Y = X - 2 

# Y - новый экземпляр класса Number
print(Y.data) 

# Результат – число
#print(X - 2) 
</content>
<print>
3
</print>
</item> 

<item>
<id>261</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>Вычитание классов - __del__</title>
<content>
class Number:
	# Вызов Number(start)
    def __init__(self, start):           
        self.data = start
		
		
	# Выражение: экземпляр - other
    def __sub__(self, other):            
		# Результат – новый экземпляр
        #return Number(self.data - other.data)
		# Результат – число
        return self.data - other.data 	 
		
		
# Number.__init__(X, 5)
X = Number(5) 
Y = Number(3)
Z = X - Y

# Z - новый экземпляр класса Number
#print(Z.data)	

# Результат – число
print(X - Y)	
</content>
<print>
1 4 9 16 25 
</print>
</item> 

<item>
<id>262</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>Проверка на вхождение:__contains__, __iter__ и __getitem__</title>
<content> 
class Iters:
    def __init__(self, value):
        self.data = value
		
	'''
	Крайний случай для итераций
	А также для индексирования и срезов
	'''
    def __getitem__(self, i):           
        print('get[%s]:' % i, end='')   
        return self.data[i]
		
	'''
	Предпочтительный для итераций
	Возможен только 1 активный итератор
	'''
    def __iter__(self):                 
        print('iter=> ', end='')        
        self.ix = 0
        return self
		
		
    def __next__(self):
        print('next:', end='')
        if self.ix == len(self.data): raise StopIteration
        item = self.data[self.ix]
        self.ix += 1
        return item
	
	# Предпочтительный для оператора 'in'
    def __contains__(self, x):         
        print('contains: ', end='')
        return x in self.data
		
		
# Создать экземпляр
X = Iters([1, 2, 3, 4, 5])   
          
# Проверка на вхождение
print(3 in X)        
                  
for i in X:                            
    print(i, end=' | ')
	
print()
print([i ** 2 for i in X])             
print( list(map(bin, X)) )

'''
Обход вручную (именно так действуют
другие итерационные контексты)
'''
I = iter(X)   
                          
while True:                             
    try:
        print(next(I), end=' @ ')
    except StopIteration:
        break
</content>
<print>
contains: True
iter=> next:1 | next:2 | next:3 | next:4 | next:5 | next:
iter=> next:next:next:next:next:next:[1, 4, 9, 16, 25]
iter=> next:next:next:next:next:next:['0b1', '0b10', '0b11', '0b100', '0b101']
iter=> next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:
</print>
</item> 

<item>
<id>263</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>Обращения к атрибутам: __getattr__ и __setattr__</title>
<content> 
class Privacy:
	# Вызывается self.attrname = value
    def __setattr__(self, attrname, value): 
            print('Setting: ' + attrname + '->' , value)
			
			# Self.attrname = value
            self.__dict__[attrname] = value 
	
	'''
	__getattr__(self, name) будет вызван в случае,
	если запрашиваемый атрибут не найден обычным механизмом 
	(в __dict__ экземпляра, класса и т.д.)
	'''
    def __getattr__(self, item):    
        print('Getting: ' + item)    
        return item
		
		
    def __str__(self):
        return str(self.age)+ ' '+ self.name
		
class Test1(Privacy):
    pass
	
x = Test1()
x.age = 40
x.name = 'Bob'

print(x)
print(x.new_attr)
</content>
<print>
Setting: age-> 40
Setting: name-> Bob
40 Bob
Getting: new_attr
new_attr
</print>
</item> 

<item>
<id>264</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>
Строковое представление объектов: __repr__ и __str__
</title>
<content> 
class adder:
	# Инициализировать атрибут data
    def __init__(self, value=0):
        self.data = value 
	'''
	__repr__ используется везде, за исключением функций print и st
	Однако, если метод __str__ отсутствует, операции вывода будут
	использовать метод __repr__, но не наоборот
	'''
	class addrepr(adder): # Наследует __init__, __add__
	
	# Добавляет строковое представление
	def __repr__(self): 
		# Преобразует в строку программного кода
        return 'addrepr(%s)' % self.data 
                          
						  
	# есть __str__, но нет __repr__
    # def __str__(self):  
		# Преобразовать в красивую строку
    #     return '[Value: % s]' % self.data  
	
# Формат отображения по умолчанию
x = adder() 

print(x)

# Вызовет __init__
x = addrepr(2)

# Вызовет __str__ , если нет __str__ вызовет __repr__ 
print(x) 
</content>
<print>
add 88 1
radd 99 1
add 88 __main__.Commuter object at 0x005113F0
radd 99 88
</print>
</item> 

<item>
<id>265</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>Комбинированная операция сложения __iadd__</title>
<content> 
class Number:
    def __init__(self, val):
        self.val = val
		
	# __iadd__ явно реализует операцию x += y
    def __iadd__(self, other): 
        self.val += other 
		
		# Обычно возвращает self
        return self
		
		
x = Number(5)
x += 1
x += 1

print(x.val)

class Number:
    def __init__(self, val):
        self.val = val
	
	# __add__ - как крайнее средство: x=(x + y)
	def __add__(self, other): 
        return Number(self.val + other) 
		
		
x = Number(5)
x += 1
x += 1

print(x.val)
</content>
<print>
Called: (1, 2, 3) {}
Called: (1, 2, 3) {'x': 4, 'y': 5}
</print>
</item> 

<item>
<id>266</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>Сравнение: __lt__, __gt__ и другие</title>
<content> 
class C:
    data = 'spam'
	
    def __gt__(self, other):
        print('__gt__')
        return self.data > other
		
		
    def __lt__(self, other):
        print('__lt__')
        return self.data &lt; other
		
		
X = C()

# Выведет True (вызовет __gt__)
print(X > 'ham')             
  
# Выведет False (вызовет __lt__)
print(X &lt; 'ham')               
</content>
<print>
__gt__
True
__lt__
False
</print>
</item> 

<item>
<id>267</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>Проверка логического значения:__bool__ и __len__</title>
<content> 
'''
Интерпретатор сначала пытается напрямую получить логическое значение с помощью метода __bool__ и только потом, если этот метод не реализован, пытается вызвать метод __len__ , чтобы выяснить истинность объекта, исходя из его длины
'''
class Truth:
    data = [1, 2, 3, 4]
	
	# первым выполняется __bool__
	# если нет __bool__ выполняется __len__
    def __bool__(self):
        return False        
                            
	'''
	находится длина строки и определяется инстинность либо
	просто находится длина объекта
	'''
    def __len__(self):
        return len(self.data)
                            
                            
X = Truth()
if not X:
	print('Not X')

print(len(X))
</content>
<print>
Not X
4
</print>
</item> 

<item>
<id>268</id>
<menu>ООП</menu>
<submenu>Перегрузка операторов</submenu>
<title>Уничтожение объектов: __del__</title>
<content> 
class Life:
    def __init__(self, name='unknown'):
        print ('Hello', name)
        self.name = name
        
    def __del__(self):
        print('Goodbye', self.name)
brian = Life('Brian')
brian = None
</content>
<print>
Hello Brian
Goodbye Brian
</print>
</item>


<item>
<id>269</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Порождающие шаблон - Абстрактная фабрика</title>
<content> 
"""
Абстрактная фабрика (Abstract factory, Kit) - паттерн, порождающий объекты.
Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов,
не специфицируя их конкретных классов.
Классы абстрактной фабрики часто реализуются фабричными методами,
но могут быть реализованы и с помощью паттерна прототип.
"""
class AbstractFactory(object):
    def create_drink(self):
        raise NotImplementedError()
		
    def create_food(self):
        raise NotImplementedError()
		
		
class Drink(object):
    def __init__(self, name):
        self._name = name
		
    def __str__(self):
        return self._name
		
		
class Food(object):
    def __init__(self, name):
        self._name = name
		
    def __str__(self):
        return self._name
		
		
class ConcreteFactory1(AbstractFactory):
    def create_drink(self):
        return Drink('Coca-cola')
		
    def create_food(self):
        return Food('Hamburger')
		
		
class ConcreteFactory2(AbstractFactory):
    def create_drink(self):
        return Drink('Pepsi')
		
    def create_food(self):
        return Food('Cheeseburger')
		
		
def get_factory(ident):
    if ident == 0:
        return ConcreteFactory1()
    elif ident == 1:
        return ConcreteFactory2()
		
factory = get_factory(1)

print (factory.create_drink()) 
print (factory.create_food())
</content>
<print>
Pepsi
Cheeseburger
</print>
</item> 

<item>
<id>270</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Порождающие шаблон - Фабричный метод</title>
<content> 
"""
Фабричный метод (Factory Method) - паттерн, порождающий классы.
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать.
Позволяет делегировать инстанцирование подклассам.
Абстрактная фабрика часто реализуется с помощью фабричных методов.
Фабричные методы часто вызываются внутри шаблонных методов.
"""
class Document(object):
    def show(self):
        raise NotImplementedError()
		
		
class ODFDocument(Document):
    def show(self):
        print ('Open document format')
		
		
class MSOfficeDocument(Document):
    def show(self):
        print ('MS Office document format')
		
		
class Application(object):
    def create_document(self, type_):
        # параметризованный фабричный метод 
        raise NotImplementedError()
		
		
class MyApplication(Application):
    def create_document(self, type_):
        if type_ == 'odf':
            return ODFDocument()
        elif type_ == 'doc':
            return MSOfficeDocument()
			
			
app = MyApplication()
app.create_document('odf').show() 
app.create_document('doc').show() 
</content>
<print>
Open document format
MS Office document format
</print>
</item> 

<item>
<id>271</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Порождающие шаблон - Строитель</title>
<content> 
"""
Строитель (Builder) - паттерн, порождающий объекты.
Отделяет конструирование сложного объекта от его представления,
так что в результате одного и того же процесса конструирования могут получаться разные представления.
От абстрактной фабрики отличается тем, что делает акцент на пошаговом конструировании объекта.
Строитель возвращает объект на последнем шаге, тогда как абстрактная фабрика возвращает объект немедленно.
Строитель часто используется для создания паттерна компоновщик.
"""
class Builder(object):
    def build_body(self):
        raise NotImplementedError()
		
    def build_lamp(self):
        raise NotImplementedError()
		
    def build_battery(self):
        raise NotImplementedError()
		
    def create_flashlight(self):
        raise NotImplementedError()
		
		
class Flashlight(object):
    """Карманный фонарик"""
    def __init__(self, body, lamp, battery):
        self._shine = False  # излучать свет
        self._body = body
        self._lamp = lamp
        self._battery = battery
		
    def on(self):
        self._shine = True
		
    def off(self):
        self._shine = False
		
    def __str__(self):
        shine = 'on' if self._shine else 'off'
        return 'Flashlight [%s]' % shine
		
		
class Lamp(object):
    """Лампочка"""
	
	
class Body(object):
    """Корпус"""
	
	
class Battery(object):
    """Батарея"""
	
	
class FlashlightBuilder(Builder):
    def build_body(self):
        return Body()
		
    def build_battery(self):
        return Battery()
		
    def build_lamp(self):
        return Lamp()
		
    def create_flashlight(self):
        body = self.build_body()
        lamp = self.build_lamp()
        battery = self.build_battery()
        return Flashlight(body, lamp, battery)
		
		
builder = FlashlightBuilder()
flashlight = builder.create_flashlight()
flashlight.on()

print (flashlight) # Flashlight [on]
</content>
<print>
Flashlight [on]
</print>
</item> 

<item>
<id>272</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Порождающие шаблон - Прототип</title>
<content> 
"""
Прототип - паттерн, порождающий объекты.
Задает виды создаваемых объектов с помощью экземпляра-прототипа
и создает новые объекты путем копирования этого прототипа.
"""
import copy
class Prototype(object):
    def __init__(self):
        self._objects = {}
		
    def register(self, name, obj):
        self._objects[name] = obj
		
    def unregister(self, name):
        del self._objects[name]
		
    def clone(self, name, attrs):
        obj = copy.deepcopy(self._objects[name])
        obj.__dict__.update(attrs)
        return obj
		
		
class Bird(object):
    """Птица"""
	
	
prototype = Prototype()
prototype.register('bird', Bird())
owl = prototype.clone('bird', {'name': 'Owl'})

# class '__main__.Bird' Owl
print (type(owl), owl.name)  

duck = prototype.clone('bird', {'name': 'Duck'})

# class '__main__.Bird' Duck
print (type(duck), duck.name) 
</content>
<print>
class '__main__.Bird' Owl
class '__main__.Bird' Duck
</print>
</item> 

<item>
<id>273</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Порождающие шаблон - Синглтон</title>
<content> 
"""
Одиночка (Singleton) - паттерн, порождающий объекты.
Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
С помощью паттерна одиночка могут быть реализованы многие паттерны (абстрактная фабрика, строитель, прототип).
"""
class SingletonMeta(type):
    def __init__(cls, *args, **kwargs):
        cls._instance = None
        # глобальная точка доступа `Singleton.get_instance()`
        cls.get_instance = classmethod(lambda c: c._instance)
        super(SingletonMeta, cls).__init__(*args, **kwargs)
		
    def __call__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(SingletonMeta, cls).__call__(*args, **kwargs)
        return cls._instance
		
		
class Singleton(object):
    __metaclass__ = SingletonMeta
    def __init__(self, name):
        self._name = name
		
    def get_name(self):
        return self._name
		
		
obj1 = Singleton('MyInstance 1')

print (obj1.get_name())  # MyInstance 1

obj2 = Singleton('MyInstance 2')

print (obj2.get_name())  # MyInstance 1
print (obj1 is obj2 is Singleton.get_instance()) 
</content>
<print>
MyInstance 1
MyInstance 1
True
</print>
</item> 

<item>
<id>274</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Структурные шаблон - Адаптер </title>
<content> 
"""
Адаптер - паттерн, структурирующий классы и объекты.
Преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты.
Адаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которая без него была бы невозможна.
"""
class Dog(object):
    def __init__(self, name):
        self._name = name
		
    def bark(self):
        return '%s: гав-гав!' % self._name
		
		
class Cat(object):
    def __init__(self, name):
        self._name = name
		
    def meow(self):
        return '%s: мяу-мяу!' % self._name
		
		
class CatAdapter(Dog):
    '''
	благодаря адаптеру мы можем использовать
    интерфейс класса `Dog`, а реализацию класса `Cat`.
	'''
    def __init__(self, name):
        super(CatAdapter, self).__init__(name=name)
        self._cat = Cat(name=name)
		
    def bark(self):
        # запрос `bark` преобразуется в запрос `meow`
        return self._cat.meow()
		
		
dog = Dog('Spike')

print (dog.bark())  

dog = CatAdapter('Spike')

print (dog.bark())</content>
<print>
Spike: woof-woof!
Spike: Meow meow!
</print>
</item> 

<item>
<id>275</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Структурные шаблон - Мост </title>
<content> 
"""
Мост (Bridge) - паттерн, структурирующий объекты.
Основная задача - отделить абстракцию от её реализации так,
чтобы то и другое можно было изменять независимо.
"""
class TVBase(object):
    """Абстрактный телевизор"""
    def tune_channel(self, channel):
        raise NotImplementedError()
		
class SonyTV(TVBase):
    """Телевизор Sony"""
    def tune_channel(self, channel):
        print('Sony TV: выбран %d канал' % channel)
		
		
class SharpTV(TVBase):
    """Телевизор Sharp"""
    def tune_channel(self, channel):
        print('Sharp TV: выбран %d канал' % channel)
		
		
class RemoteControlBase(object):
    """Абстрактный пульт управления"""
    def __init__(self):
        self._tv = self.get_tv()
		
    def get_tv(self):
        raise NotImplementedError()
		
    def tune_channel(self, channel):
        self._tv.tune_channel(channel)
		
		
class RemoteControl(RemoteControlBase):
    """Пульт управления"""
    def __init__(self):
        super(RemoteControl, self).__init__()
        self._channel = 0  # текущий канал
		
    def get_tv(self):
        return SharpTV()
		
    def tune_channel(self, channel):
        super(RemoteControl, self).tune_channel(channel)
        self._channel = channel
		
    def next_channel(self):
        self._channel += 1
        self.tune_channel(self._channel)
		
    def previous_channel(self):
        self._channel -= 1
        self.tune_channel(self._channel)
		
		
remote_control = RemoteControl()
remote_control.tune_channel(5)  # Sharp TV: выбран 5 канал
remote_control.next_channel() # Sharp TV: выбран 6 канал
</content>
<print>
Sharp TV: выбран 5 канал
Sharp TV: выбран 6 канал
</print>
</item> 

<item>
<id>276</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Структурные шаблон - Компоновщик </title>
<content> 
"""
Компоновщик (Composite) - паттерн, структурирующий объекты.
Компонует объекты в древовидные структуры для представления иерархий часть-целое.
Позволяет клиентам единообразно трактовать индивидуальные и составные объекты.
"""
# Класс представляющий одновременно примитивы и контейнеры
class Graphic(object):
    def draw(self):
        raise NotImplementedError()
		
    def add(self, obj):
        raise NotImplementedError()
		
    def remove(self, obj):
        raise NotImplementedError()
		
    def get_child(self, index):
        raise NotImplementedError()
		
		
class Line(Graphic):
    def draw(self):
        print ('Линия')
		
		
class Rectangle(Graphic):
    def draw(self):
        print ('Прямоугольник')
		
		
class Text(Graphic):
    def draw(self):
        print ('Текст')
		
		
class Picture(Graphic):
    def __init__(self):
        self._children = []
		
    def draw(self):
        print ('Изображение')
        # вызываем отрисовку у вложенных объектов
        for obj in self._children:
            obj.draw()
			
    def add(self, obj):
        if isinstance(obj, Graphic) and not obj in self._children:
            self._children.append(obj)
			
    def remove(self, obj):
        index = self._children.index(obj)
        del self._children[index]
		
    def get_child(self, index):
        return self._children[index]
		
		
pic = Picture()
pic.add(Line())
pic.add(Rectangle())
pic.add(Text())
pic.draw()
line = pic.get_child(0)
line.draw() 
</content>
<print>
Изображение
Линия
Прямоугольник
Текст
Линия
</print>
</item> 

<item>
<id>277</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Структурные шаблон - Декоратор </title>
<content> 
"""
Декоратор (Decorator, Wrapper) - паттерн, структурирующий объекты.
Динамически добавляет объекту новые обязанности.
Является гибкой альтернативой порождению подклассов с целью расширения функциональности.
"""
class Man(object):
    """Человек"""
    def __init__(self, name):
        self._name = name
		
    def say(self):
        print ('Привет! Меня зовут %s!' % self._name)
		
		
class Jetpack(object):
    """Реактивный ранец"""
    def __init__(self, man):
        self._man = man
		
    def __getattr__(self, item):
        return getattr(self._man, item)
		
    def fly(self):
        # расширяем функциональность объекта добавляя возможность летать
        print ('%s летит на реактивном ранце!' % self._man._name)
		
		
man = Man('Виктор')
man_jetpack = Jetpack(man)
man_jetpack.say()  # Привет! Меня зовут Виктор!
man_jetpack.fly() # Виктор летит на реактивном ранце!
</content>
<print>
Hello! My name Viktor!
Viktor fly by jetpack!
</print>
</item> 

<item>
<id>278</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Структурные шаблон - Фасад </title>
<content> 
"""
Фасад (Facade) - паттерн, структурирующий объекты.
Предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы.
Фасад определяет интерфейс более высокого уровня, который упрощает использование подсистемы.
"""
class Paper(object):
    """Бумага"""
    def __init__(self, count):
        self._count = count
		
    def get_count(self):
        return self._count
		
    def draw(self, text):
        if self._count > 0:
            self._count -= 1
            print (text)
			
			
class Printer(object):
    """Принтер"""
    def error(self, msg):
        print ('Error: %s' % msg)
		
    def print_(self, paper, text):
        if paper.get_count() > 0:
            paper.draw(text)
        else:
            self.error('Paper is over')
			
class Facade(object):
    def __init__(self):
        self._printer = Printer()
        self._paper = Paper(1)
		
    def write(self, text):
        self._printer.print_(self._paper, text)
		
		
f = Facade()
f.write('Hello world!')
f.write('Hello world!') 
</content>
<print>
Hello world!
Error: Paper is over
</print>
</item> 

<item>
<id>279</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Структурные шаблон - Приспособленец  </title>
<content> 
"""
Приспособленец (Flyweight) - паттерн, структурирующий объекты.
Использует разделение для эффективной поддержки множества мелких объектов.
"""
import weakref
class Color(object):
    """Приспособленец"""
    def __init__(self, name):
        self._name = name
		
    def __str__(self):
        return self._name
		
class ColorFactory(object):
    """Фабрика приспособленцев"""
    _colors = weakref.WeakValueDictionary()
    @classmethod
    def get_color(cls, name):
        value = cls._colors.get(name)
        if value is None:
            value = Color(name)
            cls._colors[name] = value
        return value
		
		
class Placemark(object):
    """Метка на карте"""
    def __init__(self, latitude, longitude, color_name):
        # координаты - внутреннее состояние (т.к. они уникальны для каждой метки)
        self._latitude = latitude
        self._longitude = longitude
        # цвет - внешнее состояние которое может быть общим у разных меток
        self._color = ColorFactory.get_color(color_name)
		
		
    def __str__(self):
        args = (self._color, self._latitude, self._longitude)
        return 'Color: %s; Coordinates: (%0.4f, %0.4f)' % args
		
		
plmrk0 = Placemark(-74.007121, 40.714551, 'green')  # Нью-Йорк
plmrk1 = Placemark(37.617761, 55.755773, 'green')  # Москва

print (plmrk0)  # Цвет: green; Координаты: (-74.0071, 40.7146)
print (plmrk1)  # Цвет: green; Координаты: (37.6178, 55.7558)
print (plmrk0._color is plmrk1._color) # True
</content>
<print>
Color: green; Coordinates: (-74.0071, 40.7146)
Color: green; Coordinates: (37.6178, 55.7558)
True
</print>
</item> 

<item>
<id>280</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Структурные шаблон - Заместитель</title>
<content> 
"""
Заместитель (Proxy, Surrogate) - паттерн, структурирующий объекты.
Является суррогатом другого объекта и контролирует доступ к нему.
"""
from functools import partial
from abc import ABCMeta, abstractmethod
class ImageBase(metaclass=ABCMeta):
    """Абстрактное изображение"""
    def create(cls, width, height):
        """Создает изображение"""
        return cls(width, height)
		
    @abstractmethod
    def draw(self, x, y, color):
        """Рисует точку заданным цветом"""
        raise NotImplementedError()
		
    @abstractmethod
    def fill(self, color):
        """Заливка цветом"""
        raise NotImplementedError()
		
    @abstractmethod
    def save(self, filename):
        """Сохраняет изображение в файл"""
        raise NotImplementedError()
		
		
class Image(ImageBase):
    """Изображение"""
    def __init__(self, width, height):
        self._width = int(width)
        self._height = int(height)
		
    def draw(self, x, y, color):
        print ('Drawing dot; coordinates: (%d, %d); color: %s' % (x, y, color))
		
    def fill(self, color):
        print ('Fill color %s' % color)
		
    def save(self, filename):
        print ('Saving image in %s' % filename)
		
		
class ImageProxy(ImageBase):
    """
    Заместитель изображения.
    Откладывает выполнение операций над изображением до момента его сохранения.
    """
    def __init__(self, *args, **kwargs):
        self._image = Image(*args, **kwargs)
        self.operations = []
		
    def draw(self, *args):
        func = partial(self._image.draw, *args)
        self.operations.append(func)
		
    def fill(self, *args):
        func = partial(self._image.fill, *args)
        self.operations.append(func)
		
    def save(self, filename):
        # выполняем все операции над изображением
        list(map(lambda f: f(), self.operations))
        self._image.save(filename)
		
img = ImageProxy(200, 200)
img.fill('gray')
img.draw(0, 0, 'green')
img.draw(0, 1, 'green')
img.draw(1, 0, 'green')
img.draw(1, 1, 'green')
img.save('image.png')
</content>
<print>
Fill color gray
Drawing dot; coordinates: (0, 0); color: green
Drawing dot; coordinates: (0, 1); color: green
Drawing dot; coordinates: (1, 0); color: green
Drawing dot; coordinates: (1, 1); color: green
Saving image in image.png
</print>
</item> 

<item>
<id>281</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Цепочка обязанностей</title>
<content> 
"""
Цепочка обязанностей (Chain of Responsibility) - паттерн поведения объектов.
Позволяет избежать привязки отправителя запроса к его получателю,
давая шанс обработать запрос нескольким объектам. Связывает объекты-получатели в цепочку
и передает запрос вдоль этой цепочки, пока его не обработают.
"""
class HttpHandler(object):
    """Абстрактный класс обработчика"""
    def handle(self, code):
        raise NotImplementedError()
		
		
class Http404Handler(HttpHandler):
    """Обработчик для кода 404"""
    def handle(self, code):
        if code == 404:
            return 'Page not found'
			
			
class Http500Handler(HttpHandler):
    """Обработчик для кода 500"""
    def handle(self, code):
        if code == 500:
            return 'Server error'
			
			
class Client(object):
    def __init__(self):
        self._handlers = []
		
    def add_handler(self, h):
        self._handlers.append(h)
		
    def response(self, code):
        for h in self._handlers:
            msg = h.handle(code)
            if msg:
                print ('Response: %s' % msg)
                break
        else:
            print ('Response not handled')
			
			
client = Client()
client.add_handler(Http404Handler())
client.add_handler(Http500Handler())
client.response(400)  
client.response(404)  
client.response(500)
</content>
<print>
Response not handled
Response: Page not found
Response: Server error
</print>
</item> 

<item>
<id>282</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Команда </title>
<content> 
"""
Команда (Command, Action, Transaction) - паттерн поведения объектов.
Инкапсулирует запрос как объект, позволяя тем самым задавать параметры клиентов
для обработки соответствующих запросов, ставить запросы в очередь или протоколировать их,
а также поддерживать отмену операций.
"""
class Light(object):
    def turn_on(self):
        print ('Light on')
		
    def turn_off(self):
        print ('Light off')
		
		
class CommandBase(object):
    def execute(self):
        raise NotImplementedError()
		
		
class LightCommandBase(CommandBase):
    def __init__(self, light):
        self.light = light
		
		
class TurnOnLightCommand(LightCommandBase):
    def execute(self):
        self.light.turn_on()
		
		
class TurnOffLightCommand(LightCommandBase):
    def execute(self):
        self.light.turn_off()
		
		
class Switch(object):
    def __init__(self, on_cmd, off_cmd):
        self.on_cmd = on_cmd
        self.off_cmd = off_cmd
		
    def on(self):
        self.on_cmd.execute()
		
    def off(self):
        self.off_cmd.execute()
		
		
light = Light()
switch = Switch(on_cmd=TurnOnLightCommand(light),
                off_cmd=TurnOffLightCommand(light))
switch.on()  
switch.off() 
</content>
<print>
Light on
Light off
</print>
</item> 

<item>
<id>283</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Интерпретатор </title>
<content> 
# coding: utf-8
"""
Интерпретатор (Interpreter) - паттерн поведения классов.
Для заданного языка определяет представление его грамматики,
а также интерпретатор предложений этого языка.
"""
class RomanNumeralInterpreter(object):
    """Интерпретатор римских цифр"""
    def __init__(self):
        self.grammar = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }
		
    def interpret(self, text):
        numbers = list(map(self.grammar.get, text))  # строки в значения
        if None in numbers:
            raise ValueError('Error statement: %s' % text)
        result = 0  # накапливаем результат
        temp = None  # запоминаем последнее значение
        while numbers:
            num = numbers.pop(0)
            if temp is None or temp >= num:
                result += num
            else:
                result += (num - temp * 2)
            temp = num
        return result
		
		
interp = RomanNumeralInterpreter()

print (interp.interpret('MMMCMXCIX') == 3999)  # True
print (interp.interpret('MCMLXXXVIII') == 1988) # True
</content>
<print>
True
True
</print>
</item> 

<item>
<id>284</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Итератор </title>
<content> 
# coding: utf-8
"""
Итератор (Iterator) - паттерн поведения объектов.
Предоставляет способ последовательного доступа ко всем элементам составного объекта,
не раскрывая его внутреннего представления.
"""
class IteratorBase(object):
    """Базовый класс итератора"""
    def first(self):
        """Возвращает первый элемент коллекции.
        Если элемента не существует возбуждается исключение IndexError."""
        raise NotImplementedError()
		
    def last(self):
        """Возвращает последний элемент коллекции.
        Если элемента не существует возбуждается исключение IndexError."""
        raise NotImplementedError()
		
    def next(self):
        """Возвращает следующий элемент коллекции"""
        raise NotImplementedError()
		
    def prev(self):
        """Возвращает предыдущий элемент коллекции"""
        raise NotImplementedError()
		
    def current_item(self):
        """Возвращает текущий элемент коллекции"""
        raise NotImplementedError()
		
    def is_done(self, index):
        """Возвращает истину если элемент с указанным индексом существует, иначе ложь"""
        raise NotImplementedError()
		
    def get_item(self, index):
        """Возвращает элемент коллекции с указанным индексом, иначе возбуждает исключение IndexError"""
        raise NotImplementedError()
		
		
class Iterator(IteratorBase):
    def __init__(self, list_=None):
        self._list = list_ or []
        self._current = 0
		
    def first(self):
        return self._list[0]
		
    def last(self):
        return self._list[-1]
		
    def current_item(self):
        return self._list[self._current]
		
    def is_done(self, index):
        last_index = len(self._list) - 1
        return 0  &lt;= index &lt;= last_index
		
    def next(self):
        self._current += 1
        if not self.is_done(self._current):
            self._current = 0
        return self.current_item()
		
    def prev(self):
        self._current -= 1
        if not self.is_done(self._current):
            self._current = len(self._list) - 1
        return self.current_item()
		
    def get_item(self, index):
        if not self.is_done(index):
            raise IndexError('There is no element with such index: %d' % index)
        return self._list[index]
		
it = Iterator(['one', 'two', 'three', 'four', 'five'])

print ([it.prev() for i in range(5)])  
print ([it.next() for i in range(5)]) 
</content>
<print>
['five', 'four', 'three', 'two', 'one']
['two', 'three', 'four', 'five', 'one']
</print>
</item> 

<item>
<id>285</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Посредник </title>
<content> 
# coding: utf-8
"""
Посредник (Mediator) - паттерн поведения объектов.
Определяет объект, инкапсулирующий способ взаимодействия множества объектов.
Посредник обеспечивает слабую связанность системы, избавляя объекты от необъодимости явно ссылаться друг на друга
и позволяя тем самым независимо изменять взаимодействия между ними.
"""
class WindowBase(object):
    def show(self):
        raise NotImplementedError()
		
    def hide(self):
        raise NotImplementedError()
		
class MainWindow(WindowBase):
    def show(self):
        print ('Show MainWindow')
		
    def hide(self):
        print ('Hide MainWindow')
		
		
class SettingWindow(WindowBase):
    def show(self):
        print ('Show SettingWindow')
		
    def hide(self):
        print ('Hide SettingWindow')
		
		
class HelpWindow(WindowBase):
    def show(self):
        print ('Show HelpWindow')
		
    def hide(self):
        print ('Hide HelpWindow')
		
		
class WindowMediator(object):
    def __init__(self):
        self.windows = dict.fromkeys(['main', 'setting', 'help'])
		
    def show(self, win):
        for window in self.windows.values():
            if not window is win:
                window.hide()
        win.show()
		
    def set_main(self, win):
        self.windows['main'] = win
		
    def set_setting(self, win):
        self.windows['setting'] = win
		
    def set_help(self, win):
        self.windows['help'] = win
		
		
main_win = MainWindow()
setting_win = SettingWindow()
help_win = HelpWindow()
med = WindowMediator()
med.set_main(main_win)
med.set_setting(setting_win)
med.set_help(help_win)
main_win.show()

print('-'*10)

med.show(setting_win)

print('-'*10)

med.show(help_win)
</content>
<print>
Show MainWindow
----------
Hide MainWindow
Hide HelpWindow
Show SettingWindow
----------
Hide MainWindow
Hide SettingWindow
Show HelpWindow
</print>
</item> 

<item>
<id>286</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Хранитель </title>
<content> 
# coding: utf-8
"""
Хранитель (Memento) - паттерн поведения объектов.
Не нарушая инкапсуляции, фиксирует и выносит за пределы объекта его внутреннее состояние так,
чтобы позднее можно было восстановить в нем объект.
"""
class Memento(object):
    """Хранитель"""
    def __init__(self, state):
        self._state = state
		
    def get_state(self):
        return self._state
		
		
class Caretaker(object):
    """Опекун"""
    def __init__(self):
        self._memento = None
		
    def get_memento(self):
        return self._memento
		
    def set_memento(self, memento):
        self._memento = memento
		
		
class Originator(object):
    """Создатель"""
    def __init__(self):
        self._state = None
		
    def set_state(self, state):
        self._state = state
		
    def get_state(self):
        return self._state
		
    def save_state(self):
        return Memento(self._state)
		
    def restore_state(self, memento):
        self._state = memento.get_state()
		
		
originator = Originator()
caretaker = Caretaker()
originator.set_state('on')

print ('Originator state:', originator.get_state())  # Originator state: on

caretaker.set_memento(originator.save_state())
originator.set_state('off')

print ('Originator change state:', originator.get_state())  # Originator change state: off

originator.restore_state(caretaker.get_memento())

print ('Originator restore state:', originator.get_state()) # Originator restore state: on
</content>
<print>
Originator state: on
Originator change state: off
Originator restore state: on
</print>
</item> 

<item>
<id>287</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Наблюдатель</title>
<content> 
# coding: utf-8
"""
Наблюдатель (Observer, Dependents, Publish-Subscribe) - паттерн поведения объектов.
Определяет зависимость типа "один ко многим" между объектами таким образом,
что при изменении состояния одного объекта все зависящие от него оповещаются об этом
и автоматически обновляются.
"""
class Subject(object):
    """Субъект"""
    def __init__(self):
        self._data = None
        self._observers = set()
		
    def attach(self, observer):
        # подписаться на оповещение
        if not isinstance(observer, ObserverBase):
            raise TypeError()
        self._observers.add(observer)
		
    def detach(self, observer):
        # отписаться от оповещения
        self._observers.remove(observer)
		
    def get_data(self):
        return self._data
		
    def set_data(self, data):
        self._data = data
        self.notify(data)
		
    def notify(self, data):
        # уведомить всех наблюдателей о событии
        for observer in self._observers:
            observer.update(data)
			
			
class ObserverBase(object):
    """Абстрактный наблюдатель"""
    def update(self, data):
        raise NotImplementedError()
		
		
class Observer(ObserverBase):
    """Наблюдатель"""
    def __init__(self, name):
        self._name = name
		
    def update(self, data):
        print ('%s: %s' % (self._name, data))
		
		
subject = Subject()
subject.attach(Observer('Observer 1'))
subject.attach(Observer('Observer 2'))
subject.set_data('data for observer')
</content>
<print>
Observer 1: data for observer
Observer 2: data for observer
</print>
</item> 

<item>
<id>288</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Состояние </title>
<content> 
# coding: utf-8
"""
Состояние (State) - паттерн поведения объектов.
Позволяет объекту варьировать свое поведение в зависимости от внутреннего состояния.
Извне создается впечатление, что изменился класс объекта.
"""
class LampStateBase(object):
    """Состояние лампы"""
    def get_color(self):
        raise NotImplementedError()
		
		
class GreenLampState(LampStateBase):
    def get_color(self):
        return 'Green'
		
		
class RedLampState(LampStateBase):
    def get_color(self):
        return 'Red'
		
		
class BlueLampState(LampStateBase):
    def get_color(self):
        return 'Blue'
		
		
class Lamp(object):
    def __init__(self):
        self._current_state = None
        self._states = self.get_states()
		
    def get_states(self):
        return [GreenLampState(), RedLampState(), BlueLampState()]
		
    def next_state(self):
        if self._current_state is None:
            self._current_state = self._states[0]
        else:
            index = self._states.index(self._current_state)
            if index &lt; len(self._states) - 1:
                index += 1
            else:
                index = 0
            self._current_state = self._states[index]
        return self._current_state
		
    def light(self):
        state = self.next_state()
        print (state.get_color())
		
lamp = Lamp()
[lamp.light() for i in range(3)]
</content>
<print>
Green
Red
Blue
</print>
</item> 

<item>
<id>289</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Стратегия </title>
<content> 
# coding: utf-8
"""
Стратегия (Strategy) - паттерн поведения объектов.
Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.
"""
class ImageDecoder(object):
    @staticmethod
    def decode(filename):
        raise NotImplementedError()
		
		
class PNGImageDecoder(ImageDecoder):
    @staticmethod
    def decode(filename):
        print ('PNG decode')
		
		
class JPEGImageDecoder(ImageDecoder):
    @staticmethod
    def decode(filename):
        print ('JPEG decode')
		
		
class GIFImageDecoder(ImageDecoder):
    @staticmethod
    def decode(filename):
        print ('GIF decode')
		
		
class Image(object):
    @classmethod
    def open(cls, filename):
        ext = filename.rsplit('.', 1)[-1]
        if ext == 'png':
            decoder = PNGImageDecoder
        elif ext in ('jpg', 'jpeg'):
            decoder = JPEGImageDecoder
        elif ext == 'gif':
            decoder = GIFImageDecoder
        else:
            raise RuntimeError('Can not decode file %s' % filename)
        byterange = decoder.decode(filename)
        return cls(byterange, filename)
		
    def __init__(self, byterange, filename):
        self._byterange = byterange
        self._filename = filename
		
		
Image.open('picture.png')  
Image.open('picture.jpg')  
Image.open('picture.gif') 
</content>
<print>
PNG decode
JPEG decode
GIF decode
</print>
</item> 

<item>
<id>290</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Шаблонный метод</title>
<content> 
# coding: utf-8
"""
Шаблонный метод (Template method) - паттерн поведения классов.
Шаблонный метод определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма,
не изменяя его структуру в целом.
"""
class ExampleBase(object):
    def template_method(self):
        self.step_one()
        self.step_two()
        self.step_three()
		
    def step_one(self):
        raise NotImplementedError()
		
    def step_two(self):
        raise NotImplementedError()
		
    def step_three(self):
        raise NotImplementedError()
		
		
class Example(ExampleBase):
    def step_one(self):
        print ('First step')
		
    def step_two(self):
        print ('Second step')
		
    def step_three(self):
        print ('Third step')
		
		
example = Example()
example.template_method()
</content>
<print>
First step
Second step
Third step
</print>
</item> 

<item>
<id>291</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Постетитель </title>
<content> 
# coding: utf-8
"""
Постетитель (Visitor) - паттерн поведения объектов.
Описывает операцию, выполняемую с каждым объектом из некоторой структуры.
Паттерн посетитель позволяет определить новую операцию, не изменяя классы этих объектов.
"""
class FruitVisitor(object):
    """Посетитель"""
    def draw(self, fruit):
        methods = {
            Apple: self.draw_apple,
            Pear: self.draw_pear,
        }
        draw = methods.get(type(fruit), self.draw_unknown)
        draw(fruit)
		
    def draw_apple(self, fruit):
        print ('Apple')
		
    def draw_pear(self, fruit):
        print ('Pineapple')
		
    def draw_unknown(self, fruit):
        print ('Friut')
		
		
class Fruit(object):
    """Фрукты"""
    def draw(self, visitor):
        visitor.draw(self)
		
		
class Apple(Fruit):
    """Яблоко"""
	
	
class Pear(Fruit):
    """Груша"""
	
	
class Banana(Fruit):
    """Банан"""
	
	
visitor = FruitVisitor()
apple = Apple()
apple.draw(visitor)
pear = Pear()
pear.draw(visitor)
banana = Banana()
banana.draw(visitor)
</content>
<print>
Apple
Pineapple
Friut
</print>
</item> 

<item>
<id>292</id>
<menu>ООП</menu>
<submenu>Шаблоны</submenu>
<title>Поведенческие шаблон - Классная доска</title>
<content> 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import abc
import random
class Blackboard(object):
    def __init__(self):
        self.experts = []
        self.common_state = {
            'problems': 0,
            'suggestions': 0,
            'contributions': [],
            'progress': 0   # percentage, if 100 -> task is finished
        }
		
    def add_expert(self, expert):
        self.experts.append(expert)
		
		
class Controller(object):
    def __init__(self, blackboard):
        self.blackboard = blackboard
		
    def run_loop(self):
        while self.blackboard.common_state['progress'] %lt; 100:
            for expert in self.blackboard.experts:
                if expert.is_eager_to_contribute:
                    expert.contribute()
        return self.blackboard.common_state['contributions']
		
		
class AbstractExpert(object):
    __metaclass__ = abc.ABCMeta
    def __init__(self, blackboard):
        self.blackboard = blackboard
		
    @abc.abstractproperty
    def is_eager_to_contribute(self):
        raise NotImplementedError('Must provide implementation in subclass.')
		
    @abc.abstractmethod
    def contribute(self):
        raise NotImplementedError('Must provide implementation in subclass.')
		
		
class Student(AbstractExpert):
    @property
    def is_eager_to_contribute(self):
        return True
		
    def contribute(self):
        self.blackboard.common_state['problems'] += random.randint(1, 10)
        self.blackboard.common_state['suggestions'] += random.randint(1, 10)
        self.blackboard.common_state['contributions'] += [self.__class__.__name__]
        self.blackboard.common_state['progress'] += random.randint(1, 2)
		
		
class Scientist(AbstractExpert):
    @property
    def is_eager_to_contribute(self):
        return random.randint(0, 1)
		
    def contribute(self):
        self.blackboard.common_state['problems'] += random.randint(10, 20)
        self.blackboard.common_state['suggestions'] += random.randint(10, 20)
        self.blackboard.common_state['contributions'] += [self.__class__.__name__]
        self.blackboard.common_state['progress'] += random.randint(10, 30)
		
		
class Professor(AbstractExpert):
    @property
    def is_eager_to_contribute(self):
        return True if self.blackboard.common_state['problems'] > 100 else False
		
    def contribute(self):
        self.blackboard.common_state['problems'] += random.randint(1, 2)
        self.blackboard.common_state['suggestions'] += random.randint(10, 20)
        self.blackboard.common_state['contributions'] += [self.__class__.__name__]
        self.blackboard.common_state['progress'] += random.randint(10, 100)
		
		
if __name__ == '__main__':
    blackboard = Blackboard()
    blackboard.add_expert(Student(blackboard))
    blackboard.add_expert(Scientist(blackboard))
    blackboard.add_expert(Professor(blackboard))
    c = Controller(blackboard)
    contributions = c.run_loop()
    from pprint import pprint
pprint(contributions)
</content>
<print>
['Student',
 'Scientist',
 'Student',
 'Scientist',
 'Student',
 'Student',
 'Student',
 'Student',
 'Scientist',
 'Student',
 'Student',
 'Scientist',
 'Student',
 'Scientist',
 'Professor']
</print>
</item> 

<item>
<id>293</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Создание и вызов класса</title>
<content> 
# Создать и связать класс C1
class C1():                     
	# Присвоить: C1.setname
    def setname(self, who):     
		# self – либо I1, либо I2
        self.name = who 
        
# Создать два экземпляра
I1 = C1()                       
I2 = C1()

# Записать ‘bob’ в I1.name
I1.setname('bob')        
       
# Записать ‘mel’ в I2.name
I2.setname('mel')         
      
print(I1.name)
print (I2.name)
</content>
<print>
bob
mel
</print>
</item> 

<item>
<id>294</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Наследование</title>
<content> 
class SecondClass:
	# Изменяет display
    def display(self):  
        print('Current value = " % s"' % self.data)
		
# Наследует SecondClass
class ThirdClass(SecondClass): 
	# Вызывается из ThirdClass(value)
    def __init__(self, value): 
        self.data = value
	
	# Для выражения “self + other”
    def __add__(self, other): 
        return ThirdClass(self.data + other)
	
	# Вызывается из print(self), str()
    def __str__(self): 
        return '[ThirdClass: %s]' % self.data
		
	# Изменяет сам объект: обычный метод
    def mul(self, other):  
        self.data *= other
		
		
# Вызывается новый метод __init__
a = ThirdClass('abc')

# Унаследованный метод  
a.display()  
value = "abc"

# __str__: возвращает строку
print(a)  

# Новый __add__: создается новый экземпляр
b = a + 'xyz'  
b.display()
value = 'abcxyz'

# __str__: возвращает строку
print(b)  

# mul: изменяется сам экземпляр
a.mul(3)  

print(a)
</content>
<print>
Current value = " abc"
[ThirdClass: abc]
Current value = " abcxyz"
[ThirdClass: abcxyz]
[ThirdClass: abcabcabc]
</print>
</item> 

<item>
<id>295</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Добавление атрибутов в класс</title>
<content> 
class Rec: 
    pass
	
	
Rec.name = 'name'
y = Rec()

print(y.name)
</content>
<print>
name
</print>
</item> 

<item>
<id>296</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Присваивание функции атрибуту класса</title>
<content> 
class Rec:
    pass
	
	
# функция вне класса
def upperName(self):
    return self.name.upper()
	
# создаем атрибут
Rec.name = 'name'

# создаем экземпляр
y = Rec()

# присваиваем функцию атрибуту класса
Rec.method = upperName

# в каждом созданом экземплре будет атрибут name
print(y.name)

#теперь можно вызывать метод экземпляра
print(y.method())

#либо метод класса,передав ему экземпляр - self
print(Rec.method(y))
</content>
<print>
name
NAME
NAME
</print>
</item> 

<item>
<id>297</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Переопределение методов</title>
<content> 
class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay
		
    def lastName(self):
        return self.name.split()[-1]
		
    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))
		
    def __str__(self):
        return '[Person: %s, %s]' % (self.name, self.pay)
		
		
class Manager(Person):
	'''
	Переопределение метода вызов версии из класса Person
	'''
    def giveRaise(self, percent, bonus=.10):    
        Person.giveRaise(self, percent + bonus) 
                                                
												
if __name__ == '__main__':
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job='dev', pay=100000)
	
    print(bob)
    print(sue)
    print(bob.lastName(), sue.lastName())
	
    sue.giveRaise(.10)
	
    print(sue)
	
# Экземпляр Manager: __init__
tom = Manager('Tom Jones', 'mgr', 50000)

# Вызов адаптированной версии 
tom.giveRaise(.10) 

# Вызов унаследованного метода
print(tom.lastName()) 
print(tom)
</content>
<print>
[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]
</print>
</item> 

<item>
<id>298</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Переопределение конструкторов</title>
<content> 
class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay
        
    def lastName(self):
        return self.name.split()[-1]
    
    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))
		
    def __str__(self):
            return '[Person: % s, % s]' % (self.name, self.pay)
			
			
class Manager(Person):
	# Переопределенный конструктор
    def __init__(self, name, pay):
		'''
		Вызов оригинального конструктора со значением
		'mgr' в аргументе job
        '''
		Person.__init__(self, name, 'mgr', pay)  
      
        def giveRaise(self, percent, bonus=.10):
            Person.giveRaise(self, percent + bonus)
			
			
if __name__ == '__main__':
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job ='dev', pay = 100000)
	
    print(bob)
    print(sue)
    print(bob.lastName(), sue.lastName())
    
	sue.giveRaise(.10)
    
	print(sue)
    
	tom = Manager('Tom Jones', 50000)  
    tom.giveRaise(.10)  
    
	print(tom.lastName())  
    print(tom)
</content>
<print>
[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 55000]
</print>
</item>

<item>
<id>299</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Абстрактные методы</title>
<content> 
class Class1(object):
	# Абстрактный метод
    def test(self, x):     
        # Возбуждаем исключение с помощью raise
        raise NotImplementedError("raise - You need override method")
		
		# Возбуждаем исключение с помощью assert
        #assert False, "assert - You need override method"
		
		
# Наследуем абстрактный метод
class Class2(Class1):      
	# Переопределяем метод
    def test(self, x):     
        print(x)
		
		
# Класс не переопределяет метод
class Class3(Class1):      
    pass
	
	
c2 = Class2()
c2.test(50)               
c3 = Class3()

try:                       	
    c3.test(50)            
except NotImplementedError as msg:
    print(msg)              
except AssertionError as msg:
    print(msg)              
</content>
<print>
50
raise - You need override method
</print>
</item>

<item>
<id>300</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Абстрактные классы</title>
<content> 
from abc import ABCMeta, abstractmethod
class Class1(metaclass=ABCMeta):
	# Абстрактный метод
    @abstractmethod
    def test(self, x):     
        pass
		
		
# Наследуем абстрактный метод
class Class2(Class1):      
	# Переопределяем метод
    def test(self, x):     
        print(x)
		
		
# Класс не переопределяет метод
class Class3(Class1):      
    pass
	
	
c2 = Class2()
c2.test(50)                
c3 = Class3()
c3.test(50)
</content>
<print>
50
TypeError: Can't instantiate abstract class Class3 with abstract methods test
</print>
</item>

<item>
<id>301</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>ООП и композиция: взаимосвязи типа «является»</title>
<content>
class Employee:
    def __init__(self, name, salary=0):
        self.name = name
        self.salary = salary
		
    def giveRaise(self, percent):
        self.salary = self.salary + (self.salary * percent)
		
    def work(self):
        print(self.name, 'does stuff')
		
    def __repr__(self):
        return '&lt; Employee: name = % s, salary = % s >' % (self.name, self.salary)
		
		
class Chef(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 50000)
		
    def work(self):
        print(self.name, 'makes food')
		
		
class Server(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 40000)
		
    def work(self):
        print(self.name, 'interfaces with customer')
		
		
class PizzaRobot(Chef):
    def __init__(self, name):
        Chef.__init__(self, name)
		
    def work(self):
        print(self.name, 'makes pizza')
		
if __name__ == '__main__':
    bob = PizzaRobot('bob')
	
    print(bob)  
    
	bob.work()  
    bob.giveRaise(0.20)  
    
	print(bob);
    print()
    
	for klass in Employee, Chef, Server, PizzaRobot:
        obj = klass(klass.__name__)
        obj.work()
 
</content>
<print>
 Employee: name = bob, salary = 50000 
bob makes pizza
 Employee: name = bob, salary = 60000.0 
Employee does stuff
Chef makes food
Server interfaces with customer
PizzaRobot makes pizza
</print>
</item>

<item>
<id>302</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>ООП и композиция: взаимосвязи типа «имеет»</title>
<content> 
class Employee:
    def __init__(self, name, salary=0):
        self.name = name
        self.salary = salary
		
    def giveRaise(self, percent):
        self.salary = self.salary + (self.salary * percent)
		
    def work(self):
        print(self.name, 'does stuff')
		
    def __repr__(self):
        return '&lt; Employee: name = % s, salary = % s >' % (self.name, self.salary)
		
class Chef(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 50000)
		
    def work(self):
        print(self.name, 'makes food')
		
		
class Server(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 40000)
		
    def work(self):
        print(self.name, 'interfaces with customer')
		
		
class PizzaRobot(Chef):
    def __init__(self, name):
        Chef.__init__(self, name)
		
    def work(self):
        print(self.name, 'makes pizza')
		
		
class Customer:
    def __init__(self, name):
        self.name = name
        
    def order(self, server):
        print(self.name, 'orders from', server)
        
    def pay(self, server):
        print(self.name, 'pays for item to', server)
		
		
class Oven:
    def bake(self):
        print('oven bakes')
		
		
class PizzaShop:
    def __init__(self):
        self.server = Server('Pat')        
        self.chef   = PizzaRobot('Bob')    
        self.oven  = Oven()
		
    def order(self, name):
        customer = Customer(name)          
        customer.order(self.server)        
        self.chef.work()
        self.oven.bake()
        customer.pay(self.server)
		
		
if __name__ == '__main__':
    scene = PizzaShop()                    
    scene.order('Homer')                   
    print('...')
    scene.order('Shaggy')                  
	
'''
Класс PizzaShop – это контейнер и контроллер – это конструктор, который создает и встраивает экземпляры классов работников, а также экземпляры класса Oven.Когда вызываетcz метод order класса PizzaShop, встроенным объектам предлагается приступить к выполнению своих обязанностей. Для каждого клиента создается новый экземпляр класса Customer и передаем встроенный объект Server(официант) методам класса Customer (клиент) – клиенты приходят и уходят,а официант остается частью пиццерии. Кроме того, работники по-прежнему вовлечены во взаимосвязи наследования –композиция и наследование – это взаимодополняющие инструменты.
'''
</content>
<print>
Homer orders from  Employee: name = Pat, salary = 40000 
Bob makes pizza
oven bakes
Homer pays for item to  Employee: name = Pat, salary = 40000 
...
Shaggy orders from  Employee: name = Pat, salary = 40000 
Bob makes pizza
oven bakes
Shaggy pays for item to  Employee: name = Pat, salary = 40000 
</print>
</item>

<item>
<id>303</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Связаные методы</title>
<content> 
class Spam:
    def doit(self, message):
        print(message)
		
		
object1 = Spam()

# Обычная ситуация
object1.doit('hello world') 
object1 = Spam()

# Объект связанного метода: экземпляр+функция
x = object1.doit 

# То же, что и object1.doit(‘...’)
x('hello world')  
</content>
<print>
hello world
hello world
</print>
</item>

<item>
<id>304</id>
<menu>ООП</menu>
<submenu>Базовые операции</submenu>
<title>Статические методы - staticmethod</title>
<content>
class Class1(object):
	# Статический метод
    @staticmethod
    def sum1(x, y):  
        print(x + y)
	
	# Обычный метод в классе
    def sum2(self, x, y):  
        print( x + y)
	
	# Вызов из метода класса
    def sum3(self, x, y):
        return Class1.sum1(x, y)  
		
		
# Вызываем статический метод
Class1.sum1(10, 20)  
c1 = Class1()

# Вызываем метод класса
c1.sum2(15, 6)  

# Вызываем статический метод
# через экземпляр класса
c1.sum1(50, 12)  

# Вызываем статический метод
# внутри класса
c1.sum3(23, 5)  
</content>
<print>
30
21
62
28
</print>
</item>


<item>
<id>305</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>
Классы – это основные инструменты объектно-ориентированного программирования (ООП) в языке Python
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>306</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>
Экземпляры представляют конкретные элементы программы. Их атрибуты хранят данные, которые могут отличаться в конкретных объектах
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>307</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>
Методы класса
__name__ — имя класса;
__module__ — имя модуля;
__dict__ — словарь атрибутов класса, можно изменять этот словарь напрямую;
__bases__ — кортеж базовых классов в порядке их следования;
__doc__ — строка документации класса.
__dict__ — словарь атрибутов класса, можно изменять этот словарь напрямую;
__class__ — объект-класс, экземпляром которого является данный инстанс;
__init__ — конструктор. Если в базовом классе есть конструктор, конструктор производного класса должен вызвать его;
__del__ — деструктор. Если в базовом классе есть деструкор, деструктор производного класса должен вызвать его;
__cmp__ — вызывается для всех операций сравнения;
__hash__ — возвращает хеш-значение объекта, равное 32-битному числу;
__getattr__ — возвращает атрибут, недоступный обычным способом;
__setattr__ — присваивает значение атрибуту;
__delattr__ — удаляет атрибут;
__call__ — срабатывает при вызове экземпляра класса.
__len__ — возвращает длину последовательности;
__getitem__ — получение элемента по индексу или ключу;
__setitem__ — присваивание элемента с данным ключом или индексом;
__delitem__ — удаление элемента с данным ключом или индексом;
__getslice__ — возвращает вложенную последовательность;
__setslice__ — заменяет вложенную последовательность;
__delslice__ — удаляет вложенную последовательность;
__contains__ — реализует оператор in.
__repr__ — возвращает формальное строковое представление объекта;
__str__ — возвращает строковое представление объекта;
__oct__ , __hex__ , __complex__ , __int__ , __long__ , __float__ — возвращают строковое представление в соответствующей системе счисления.</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>308</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>
__init__			
Конструктор 	
При создании объекта:X = Class(args)
__del__				
Деструктор 		
При уничтожении объекта
__add__				
Оператор + 		
X + Y, X += Y,если отсутствует метод __iadd__ 
__or__ 				
Оператор | (побитовое ИЛИ) 		
X | Y, X |= Y,если отсутствует метод __ior__
__repr__,
__str__				
Вывод, преобразование	
print(X), repr(X), str(X)
__call__ 			
Вызовы функции 			
X(*args, **kargs)
__getattr__ 		
Обращение к атрибуту 	
X.undefined
__setattr__ 		
Присваивание атрибуту	
X.any = value
__delattr__ 		
Удаление атрибута 		
del X.any
__getattribute__	
Обращение к атрибуту	
X.any
__getitem__			
Доступ к элементу по индексу, извлечение среза, итерации			
X[key], X[i:j], циклы for и другие конструкции итерации, при отсутствии метода __iter__
__setitem__ 		
Присваивание элементу по индексу или срезу
X[key] = value, X[i:j] = sequence
__delitem__ 		
Удаление элемента по индексу или среза
del X[key], del X[i:j]
__len__
Длина 					
len(X), проверка истинности, если отсутствует метод __bool__
											
__bool__
Проверка логического значения	
bool(X) , проверка истинности
					
__lt__, __gt__,		 
__le__, __ge__,								
__eq__, __ne__
Сравнивание				
X &lt; Y, X &gt; Y, X &lt;= Y, X >= Y,X == Y, X != Y
__radd__ 			
Правосторонний	оператор +		
Не_экземпляр + X
					
__iadd__ 			
Добавление(увеличение)				
X += Y (в ином случае __add__)
					
__iter__,						 
__next__							 
Итерационный контекст		
I=iter(X), next(I)  циклы for,оператор in (если не определен метод	__contains__), все типы генераторов,map(F, X) и другие
											
__contains__ 		
Проверка на вхождение	
item in X (где X – любой итерируемый объект)
					
__index__ 			
Целое число 			
hex(X), bin(X) , oct(X) , O[X] , O[X:] 
	
__enter__,			
__exit__
Менеджеры контекстов	
with obj as var:
__get__, 			
__set__,
__delete__
Дескрипторы атрибутов	
X.attr, X.attr = value, del X.attr
__new__ 			
Создание 				
Вызывается при создании объектов,перед вызовом метода __init__
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>309</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>Инициализатор __init__, вызывается автоматически всякий раз, когда создается новый экземпляр.
# Добавим инициализацию полей записи
class Person:
	# Конструктор принимает 3 аргумента
	def __init__(self, name, job, pay):
		# Заполняет поля при создании
		self.name = name		
		self.job = job 
		self.pay = pay
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>310</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>
Наследование
# Общий суперкласс
class BaseClass:                  
	# Общее поведение
    def computeSalary(self): ...  
	
    def giveRaise(self): ...
	
    def promote(self): ...
	
    def retire(self): 
	
	
# Наследуемый класс
class DerivedClass(BaseClass):        
	# Особенная реализация
    def computeSalary(self): ... 	  	
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>311</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>
Чтобы получить доступ к классу, нам необходимо обратиться к модулю, как
обычно:
import person # Импортировать модуль
x = person.Person()  # Класс внутри модуля
Хотя этот способ может показаться избыточным, он совершенно необходим:
имя person.person ссылается на класс person внутри модуля person. Если использовать просто имя person, мы обратимся к модулю, а не к классу кроме случая,
когда используется инструкция from:
from person import Person # Получить класс из модуля
x = Person() 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>312</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>
# Базовый класс для класса Class2
class Class1:         
    def f_func1(self):
        print ("Метод f_func1() класса Class1")
 
# Класс Class2 наследует класс Class1
class Class2(Class1): 
    def f_func2(self):
        print ("Метод f_func2() класса Class2")
		
		
# Класс Class3 наследует класс Class1
class Class3(Class1): 
    def f_func1(self):
        print ("Метод f_func1() класса Class3")
		
    def f_func2(self):
        print ("Метод f_func2() класса Class3")
		
    def f_func3(self):
        print ("Метод f_func3() класса Class3")
		
    def f_func4(self):
        print ("Метод f_func4() класса Class3")
 
 
# Множественное наследование
class Class4(Class2, Class3): 
    def f_func4(self):
        print ("Метод f_func4() класса Class4")
 
# Создаем экземпляр класса Class4
c1 = Class4()           
  
# Выведет: Метод f_func1() класса Class1
c1.f_func1()              

# Выведет: Метод f_func2() класса Class2
c1.f_func2()       
       
# Выведет: Метод f_func3() класса Class3
c1.f_func3()      
        
# Выведет: Метод f_func4() класса Class4
c1.f_func4()     
         
метод f_func1() определен в двух классах - Class1 и Class3. Так как класс Class2 стоит первым в списке базовых классов, вначале просматривается этот класс, а затем все его базовые классы. Поэтому метод f_func1() будет найден в классе Class1, а не в классе Class3.
Метод f_func2() также определен в двух классах - Class2 и Class3. Так как класс Class2 стоит первым в списке базовых классов, то метод будет найден именно в этом классе. Чтобы наследовать метод из класса Class3, следует указать это явным образом. Передаем определение класса Class4 из предыдущего примера и наследуем метод f_func2() из класса Class3.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>313</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>
# Множественное наследование
class Class4(Class2, Class3): 
    # Наследуем f_func2() из класса Class3, а не из класса Class2
    f_func2 = Class3.f_func2
	
    def f_func4(self):
        print ("Метод f_func4() класса Class4")
		
		
Метод f_func3() определен только в классе Class3, поэтому метод наследуется от этого класса. Метод f_func4(), определенный в классе Class3, переопределяется в производном классе. Если метод найден в производном классе, то вся иерархия наследования просматривается не будет.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>314</id>
<menu>ООП</menu>
<submenu>Заметки</submenu>
<title>Не возможно выполнить перегрузку операторов ,так как инструкция def
просто присваивает объект некоторому имени в области видимости класса, сохранено будет только последнее определение метода (это все равно, что записать две инструкции подряд: X = 1, а затем X = 2, в результате чего X будет иметь
значение 2).
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>315</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Создание массива</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]

print(np.array(l), end='\n\n')

# 5x5 array of 0 with 1 on diagonal (Identity matrix)
print(np.eye(3), end='\n\n')

# Array of 6 evenly divided values from 0 to 100
print(np.linspace(0,100,6), end='\n\n')

# Array of values from 0 to less than 10 with step 3 (eg [0,3,6,9])
print(np.arange(0,10,3), end='\n\n')

# 2x3 array with all values 8
print(np.full((2,3),8), end='\n\n')

# 4x5 array of random floats between 0-1
print(np.random.rand(4,5), end='\n\n')

# 6x7 array of random floats between 0-100
print(np.random.rand(6,7)*100, end='\n\n')

# 2x3 array with random ints between 0-4
print(np.random.randint(5,size=(2,3)), end='\n\n')	
</content>
<print>
[[1 2 3]
 [4 5 6]
 [7 8 9]]

[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]

[   0.   20.   40.   60.   80.  100.]

[0 3 6 9]

[[8 8 8]
 [8 8 8]]

[[ 0.29928396  0.06315335  0.64033318  0.97863473  0.79617336]
 [ 0.79365916  0.59151206  0.40507363  0.35153041  0.56312282]
 [ 0.3628814   0.90452425  0.83524625  0.44267742  0.11130935]
 [ 0.75545246  0.10732077  0.92437714  0.17048936  0.43289407]]

[[ 49.53256711  96.25683949  22.08137577  17.06758755   8.23851769
   92.51528802  25.14358391]
 [ 18.8659442   20.17249083  40.40941696  60.58138608  25.27922709
   11.6171955   68.53556058]
 [ 21.63283898  14.3734345   53.31605609  68.54694795  19.01524829
   49.62365485  53.94686967]
 [ 84.49603708  99.58293612  37.90762162  68.76291173  36.29537677
   51.08262505  89.50430767]
 [ 47.610246    27.8549196   38.59021787  72.52472523  20.65317676
   98.49013554  95.24076754]
 [ 58.43417929  93.3890169   75.10964881  27.18040356  52.60338476
   89.731735    30.47528516]]

[[0 0 3]
 [1 2 4]]
</print>
</item> ,


<item>
<id>316</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Добавление элемента в массив</title>
<content> 
import numpy as np

arr = np.arange(6)

print(arr)
print(np.append(arr,8), end='\n\n')

l =[[1,2,3],
    [4,5,6]]
arr = np.array(l)

print(arr, end='\n\n')
print(np.append(arr,[[7,8,9]],axis=0))
</content>
<print>
[0 1 2 3 4 5]
[0 1 2 3 4 5 8]

[[1 2 3]
 [4 5 6]]

[[1 2 3]
 [4 5 6]
 [7 8 9]]
</print>
</item>


<item>
<id>317</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Вставка элемента в массив</title>
<content> 
import numpy as np

arr = np.arange(6)

print(arr)
print(np.insert(arr,1,8), end='\n\n')

l =[[1,2,3],
    [4,5,6]]
arr = np.array(l)

print(arr, end='\n\n')
print(np.insert(arr,1,[[7,8,9]],axis=0))
</content>
<print>
[0 1 2 3 4 5]
[0 8 1 2 3 4 5]

[[1 2 3]
 [4 5 6]]

[[1 2 3]
 [7 8 9]
 [4 5 6]]
</print>
</item>


<item>
<id>318</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Удаление элемента</title>
<content> 
import numpy as np

arr = np.arange(6)

print(arr)
print(np.delete(arr,1), end='\n\n')

l =[[1,2,3],
    [4,5,6]]
arr = np.array(l)

print(arr, end='\n\n')
print(np.delete(arr,1,axis=0))
</content>
<print>
[0 1 2 3 4 5]
[0 2 3 4 5]

[[1 2 3]
 [4 5 6]]

[[1 2 3]]
</print>
</item>


<item>
<id>319</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Создание 1-мерного массива с элементами = 0</title>
<content> 
import numpy as np

print(np.zeros(5))
</content>
<print>
[ 0.  0.  0.  0.  0.]
</print>
</item> 


<item>
<id>320</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Создание 2-мерного массива с элементами = 1</title>
<content> 
import numpy as np

m = np.ones((3,3))

print(m)
</content>
<print>
[[ 1.  1.  1.]
 [ 1.  1.  1.]
 [ 1.  1.  1.]]
</print>
</item> 


<item>
<id>321</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Создание 3-мерного пустого массива</title>
<content> 
import numpy as np

m = np.empty((3,3,3))

print(m)
</content>
<print>
</print>
</item> 



<item>
<id>322</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Создание единичной матрицы</title>
<content> 
import numpy as np

m = np.eye(3)

print(m)

m = np.identity(3)

print(m)
</content>
<print>
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
</print>
</item> 



<item>
<id>323</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Создание массива из диапазона</title>
<content> 
import numpy as np

m = np.arange(1,10)

print(m)
</content>
<print>
[1 2 3 4 5 6 7 8 9]
</print>
</item> 


<item>
<id>324</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Создание случайного массива с нормальным распределением</title>
<content> 
import numpy as np
from numpy.random import randn

samples = np.random.normal(size=(4,  4))

print(samples,end='\n\n')

m = np.array(randn(4,4))

print(m)
</content>
<print>
[[ 0.69025459  1.4201234  -1.32006384 -0.96131418]
 [-0.27814437  0.28476788  0.98531921 -0.1125125 ]
 [ 0.74259321  0.63883014  1.67319572 -0.82196822]
 [-0.81783597 -0.35058113 -0.44138494 -0.9560704 ]]

[[ 2.13923377 -0.05994462 -1.18426935  0.38287268]
 [-0.29313235 -1.3717357  -0.0932126  -0.65992727]
 [-0.99600499 -0.93796508  0.62710265  0.25870525]
 [ 0.96231533  1.07340669  1.50766356  1.49105333]]
</print>
</item> 


<item>
<id>325</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Получить размерность массива</title>
<content>
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
m = np.array(l)

print(m.ndim) 
</content>
<print>
2
</print>
</item> 



<item>
<id>326</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Получить форму массива</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
m = np.array(l)

print(m.shape)
</content>
<print>
(3, 3)
</print>
</item> 



<item>
<id>327</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Получить тип данных массива</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
m = np.array(l)

print(m.dtype)
</content>
<print>
int32
</print>
</item> 



<item>
<id>328</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Явное преобразование массива</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
m = np.array(l)
'''
При вызове astype всегда создается новый массив (данные копируют­ся), даже если новый dtype не отличается от старого
'''
n = m.astype(np.float64)

print(n)
print(n.dtype)
</content>
<print>
int64
</print>
</item> 



<item>
<id>329</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Получение срезов</title>
<content> 
# -*- coding:utf-8 -*-
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
m = np.array(l)


print(m[1:])
print(m[0][1:],end="\n\n")

# Данные копируются,
print(m[2:].copy())
print(m[1][2:].copy())
</content>
<print>
[[4 5 6]
 [7 8 9]]
[2 3]

[[7 8 9]]
[6]
</print>
</item> 



<item>
<id>330</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Доступ к элементам массива</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
m = np.array(l)

print(m[0][2])
print(m[0,2])
</content>
<print>
3
3
</print>
</item> 



<item>
<id>331</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Математические операции над массивами</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
m = np.array(l)

print(m + m, end='\n\n')
print(m - m, end='\n\n')
print(m * m, end='\n\n')
print(m / m, end='\n\n')
</content>
<print>
[[ 2  4  6]
 [ 8 10 12]
 [14 16 18]]

[[0 0 0]
 [0 0 0]
 [0 0 0]]

[[ 1  4  9]
 [16 25 36]
 [49 64 81]]

[[ 1.  1.  1.]
 [ 1.  1.  1.]
 [ 1.  1.  1.]]
</print>
</item> 



<item>
<id>332</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Булевое индексирование</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
m = np.array(l)
names =  np.array(['Bob', 'Joe', 'Will'])

# Ключевые слова Python and и or с булевыми 
# массивами не работают. 
n = (names=='Joe') | (names=='Will')

print(n)
print(m[n])
</content>
<print>
[False  True  True]
[[4 5 6]
 [7 8 9]]
</print>
</item> 



<item>
<id>333</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Изменение формы</title>
<content>
import numpy as np

m = np.arange(16)

print(m,end='\n\n')
print(m.reshape(4,4)) 
print(m.ravel())

# возвращает копию данных
print(m.flatten())
</content>
<print>
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
 
 [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]
 [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]
</print>
</item> 


<item>
<id>334</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Транспонирование матрицы</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]

m = np.array(l)

print(m,end='\n\n')
# замена столбцов на строки
print(m.transpose(),end='\n\n')
print(m.T)
</content>
<print>
[[1 2 3]
 [4 5 6]
 [7 8 9]]

[[1 4 7]
 [2 5 8]
 [3 6 9]]
 
 [[1 4 7]
 [2 5 8]
 [3 6 9]]
</print>
</item> 


<item>
<id>335</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Изменение размерности resize()</title>
<content> 
#-*- coding:utf8 -*-
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9],
     [10, 11, 12]]

m = np.array(l)

print(m,end='\n\n')
'''
reshape() возвращает ее аргумент с измененной формой, в то время как метод resize() изменяет сам массив:
'''
m.resize((2, 6))

print(m)
</content>
<print>
[[ 1  2  3]
 [ 4  5  6]
 [ 7  8  9]
 [10 11 12]]

[[ 1  2  3  4  5  6]
 [ 7  8  9 10 11 12]]
</print>
</item> 


<item>
<id>336</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Объединение многомерных массивов</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6]]
n =  [[7, 8, 9],
     [10, 11, 12]]

new_vert = np.vstack((n, l))
new_hor = np.hstack((l, n))

print(new_vert,end='\n\n')
print(new_hor,end='\n\n')

new_vert1 = np.concatenate([l, n],axis=0)
print(new_vert1,end='\n\n')

new_hor1 = np.concatenate([l, n],axis=1)
print(new_hor1)
</content>
<print>
[[ 7  8  9]
 [10 11 12]
 [ 1  2  3]
 [ 4  5  6]]

[[ 1  2  3  7  8  9]
 [ 4  5  6 10 11 12]]

[[ 1  2  3]
 [ 4  5  6]
 [ 7  8  9]
 [10 11 12]]

[[ 1  2  3  7  8  9]
 [ 4  5  6 10 11 12]]
</print>
</item> 


<item>
<id>337</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Объединение одномерных массивов</title>
<content> 
#-*- coding:utf8 -*-
import numpy as np

a = [1, 2, 3]
b = [4, 5, 6]

new_column = np.column_stack((a, b))
new_row = np.row_stack((a, b))

print(new_column,end='\n\n')
print(new_row)
</content>
<print>
[[1 4]
 [2 5]
 [3 6]]

[[1 2 3]
 [4 5 6]]
</print>
</item> 


<item>
<id>338</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Разбиение массива</title>
<content>
#-*- coding:utf8 -*-
import numpy as np

l = [[1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
     [13, 14, 15, 16]]

m = np.array(l)

# Разбить на 2 части
print(np.hsplit(m, 2),end='\n\n')

# Разрезать m после 1 и до 4 столбца
print(np.hsplit(m, (1,4)),end='\n\n')

# Разрезать m после 1 и до 3 строки
print(np.vsplit(m,(1,3)))
</content>
<print>
[array([[ 1,  2],
       [ 5,  6],
       [ 9, 10],
       [13, 14]]), 
array([[ 3,  4],
       [ 7,  8],
       [11, 12],
       [15, 16]])]

[array([[ 1],
       [ 5],
       [ 9],
       [13]]), 
array([[ 2,  3,  4],
       [ 6,  7,  8],
       [10, 11, 12],
       [14, 15, 16]]),	   
array([], shape=(4, 0), dtype=int32)]

[array([[1, 2, 3, 4]]), array([[ 5,  6,  7,  8],
       [ 9, 10, 11, 12]]), array([[13, 14, 15, 16]])]
</print>
</item> 


<item>
<id>339</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Унарные функции:sqrt(),exp()</title>
<content> 
#-*- coding:utf8 -*-
import numpy as np

l = [[1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
     [13, 14, 15, 16]]

m = np.array(l)


# извлечение корня
print('sqrt: ',np.sqrt(m),end='\n\n')

print('exp: ',np.exp(m),end='\n\n')
</content>
<print>
sqrt:  [[ 1.          1.41421356  1.73205081  2.        ]
 [ 2.23606798  2.44948974  2.64575131  2.82842712]
 [ 3.          3.16227766  3.31662479  3.46410162]
 [ 3.60555128  3.74165739  3.87298335  4.        ]]

exp:  [[  2.71828183e+00   7.38905610e+00   2.00855369e+01   5.45981500e+01]
 [  1.48413159e+02   4.03428793e+02   1.09663316e+03   2.98095799e+03]
 [  8.10308393e+03   2.20264658e+04   5.98741417e+04   1.62754791e+05]
 [  4.42413392e+05   1.20260428e+06   3.26901737e+06   8.88611052e+06]]
</print>
</item> 


<item>
<id>340</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Статистические методы: sum(), mean(), min(), max()</title>
<content> 
#-*- coding:utf8 -*-
import numpy as np

l = [[1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
     [13, 14, 15, 16]]

m = np.array(l)

print('sum: ',m.sum())

# среднне значение массива
print('mean:',m.mean())

# среднее значение по строкам
print('mean:',m.mean(axis=1))
print('mean:',np.mean(m))
print('min: ',m.min())
print('max: ',m.max())

# минимальное число в каждой строке
print('min row: ',m.min(axis=1))

# минимальное число в каждом столбце
print('min col: ',m.min(axis=0),end='\n\n')
</content>
<print>
sum:  136
mean: 8.5
mean: [  2.5   6.5  10.5  14.5]
mean: 8.5
min:  1
max:  16
min row:  [ 1  5  9 13]
min col:  [1 2 3 4]
</print>
</item> 

<item>
<id>341</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Методы булевых массивов: any(), all()</title>
<content> 
bools =  np.array([False, False, True, False])
m = np.array(bools)

print(m.any())
print(m.all())
</content>
<print>
True
False
</print>
</item> 


<item>
<id>342</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка/Обратная сортировка</title>
<content> 
import numpy as np

l = [[1, 2, 3, 4],
     [5, 6, 22, 8],
     [9, 10, 33, 12],
     [13, 44, 15, 16]]

m = np.array(l)
m.sort(0)

print(m,end='\n\n')

m.sort(1)

print(m,end='\n\n')

print(m[:,: : -1])
</content>
<print>
[[ 1  2  3  4]
 [ 5  6 15  8]
 [ 9 10 22 12]
 [13 44 33 16]]

[[ 1  2  3  4]
 [ 5  6  8 15]
 [ 9 10 12 22]
 [13 16 33 44]]

[[ 4  3  2  1]
 [15  8  6  5]
 [22 12 10  9]
 [44 33 16 13]]
</print>
</item> 


<item>
<id>343</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка с созданием копии массива</title>
<content> 
#-*- coding:utf8 -*-
import numpy as np

l = [[1, 2, 3, 4],
     [5, 6, 22, 8],
     [9, 10, 33, 12],
     [13, 44, 15, 16]]

m = np.array(l)

n = np.sort(m,axis=0)

print(n, end='\n\n')

n = np.sort(m,axis=1)

print(n, end='\n\n')

# исходный массив неизменен
print(m)
</content>
<print>
[[ 1  2  3  4]
 [ 5  6 15  8]
 [ 9 10 22 12]
 [13 44 33 16]]

[[ 1  2  3  4]
 [ 5  6  8 22]
 [ 9 10 12 33]
 [13 15 16 44]]

[[ 1  2  3  4]
 [ 5  6 22  8]
 [ 9 10 33 12]
 [13 44 15 16]]
</print>
</item> 

<item>
<id>344</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Удаление дубликатов в массивах</title>
<content>
import numpy as np

names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])

print(np.unique(names))
print(np.unique(ints)) 
</content>
<print>
['Bob' 'Joe' 'Will']
[1 2 3 4]
</print>
</item> 


<item>
<id>345</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Присутствуют ли значения из одного массива в другом</title>
<content> 
import numpy as np

ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])
x = np.array([1, 0, 3])

print(np.in1d(ints,x))
</content>
<print>
[ True  True  True False False  True  True False False]
</print>
</item> 

<item>
<id>346</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Сохранение/Загрузка массивов</title>
<content> 
import numpy as np

l = [[1, 2, 3, 4],
     [5, 6, 22, 8],
     [9, 10, 33, 12],
     [13, 44, 15, 16]]
m = np.array(l)
np.save('new_arr',m)

n = np.load('new_arr.npy')
print(n)
</content>
<print>
[[ 1  2  3  4]
 [ 5  6 22  8]
 [ 9 10 33 12]
 [13 44 15 16]]
</print>
</item> 


<item>
<id>347</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Сохранение/Загрузка из текстовых файлов</title>
<content> 
import numpy as np
'''
test.txt
0.580052,0.186730,1.040717,1.134411
0.194163,-0.636917,-0.938659,0.124094
-0.126410,0.268607,-0.695724,0.047428
-1.484413,0.004176,-0.744203,0.005487
2.302869,0.200131,1.670238,-1.881090
-0.193230,1.047233,0.482803,0.960334
'''
arr =  np.loadtxt('test.txt',delimiter=',')
print(arr,end='\n\n')

m = np.where(arr > 0,1,0)

print(m,end='\n\n')

np.savetxt('test.txt',m,delimiter=',')
s = np.loadtxt('test.txt',delimiter=',')

print(s)
</content>
<print>
[[ 0.580052  0.18673   1.040717  1.134411]
 [ 0.194163 -0.636917 -0.938659  0.124094]
 [-0.12641   0.268607 -0.695724  0.047428]
 [-1.484413  0.004176 -0.744203  0.005487]
 [ 2.302869  0.200131  1.670238 -1.88109 ]
 [-0.19323   1.047233  0.482803  0.960334]]

[[1 1 1 1]
 [1 0 0 1]
 [0 1 0 1]
 [0 1 0 1]
 [1 1 1 0]
 [0 1 1 1]]

[[ 1.  1.  1.  1.]
 [ 1.  0.  0.  1.]
 [ 0.  1.  0.  1.]
 [ 0.  1.  0.  1.]
 [ 1.  1.  1.  0.]
 [ 0.  1.  1.  1.]]
</print>
</item> 


<item>
<id>348</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Перемножение матриц</title>
<content> 
import numpy as np
'''
1 * 1 + 2 * 3 + 3 * 5 = 22
'''
x = np.array([[1, 2, 3], [4, 5, 6]])
y = np.array([[1, 2], [3, 4], [5, 6]])

print(x.dot(y),end='\n\n')
print(np.dot(x, y))
</content>
<print>
[[22 28]
 [49 64]]

[[22 28]
 [49 64]]
</print>
</item> 


<item>
<id>349</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Повторение элементов: repeat()</title>
<content> 
import numpy as np

arr = np.arange(3)
print(arr,end='\n\n')

print(arr.repeat(2),end='\n\n')
print(arr.repeat([2, 3, 4]),end='\n\n')

l = [[1, 2, 3],
     [4, 5, 6]]


m = np.array(l)

print(m.repeat(2,axis = 0),end='\n\n')
print(m.repeat([2,3,1],axis = 1),end='\n\n')
</content>
<print>
[0 1 2]

[0 0 1 1 2 2]

[0 0 1 1 1 2 2 2 2]

[[1 2 3]
 [1 2 3]
 [4 5 6]
 [4 5 6]]

[[1 1 2 2 2 3]
 [4 4 5 5 5 6]]
</print>
</item>


<item>
<id>350</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Повторение элементов: tile()</title>
<content> 
import numpy as np

arr = np.arange(3)

print(arr,end='\n\n')
print(np.tile(arr,2),end='\n\n')
print(np.tile(arr,(2,2)),end='\n\n')

l = [[1, 2, 3],
     [4, 5, 6]]

m = np.array(l)

print(np.tile(m,2),end='\n\n')
print(np.tile(m,(2,2)),end='\n\n')
</content>
<print>
[0 1 2]

[0 1 2 0 1 2]

[[0 1 2 0 1 2]
 [0 1 2 0 1 2]]

[[1 2 3 1 2 3]
 [4 5 6 4 5 6]]

[[1 2 3 1 2 3]
 [4 5 6 4 5 6]
 [1 2 3 1 2 3]
 [4 5 6 4 5 6]]
</print>
</item>


<item>
<id>351</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Сложение элементов с промежуточным аккумулированием </title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]

m = np.array(l)

print(np.add.accumulate(m, axis=1),end='\n\n')
print(np.add.accumulate(m, axis=0))
</content>
<print>
[[ 1  3  6]
 [ 4  9 15]
 [ 7 15 24]]

[[ 1  2  3]
 [ 5  7  9]
 [12 15 18]]
</print>
</item>


<item>
<id>352</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Прямое произведение 2-х массивов</title>
<content> 
import numpy as np

arr = np.arange(3)

print(arr,end='\n\n')
print(np.multiply.outer(arr,arr))
</content>
<print>
[0 1 2]

[[0 0 0]
 [0 1 2]
 [0 2 4]]
</print>
</item>


<item>
<id>353</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Локальное сложение элементов: reduceat()</title>
<content> 
import numpy as np

arr = np.arange(8)

print(arr,end='\n\n')

# сумма элементов от 0 до 5(5 не включается),от 5 до 7,от 7 до конца
n = np.add.reduceat(arr, [0,  5,  7])
print(n,end='\n\n')

# сумма элементов от 0 до 4(4 не включается),от 1 до 5 и т.д.
# [::2] задает шаг в 2 элемента
n = np.add.reduceat(arr, [0,4, 1,5, 2,6, 3,7])[::2]
print(n)
</content>
<print>
[0 1 2 3 4 5 6 7]

[10 11  7]

[ 6 10 14 18]
</print>
</item>


<item>
<id>354</id>
<menu>Numpy</menu>
<submenu>Базовые операции</submenu>
<title>Поиск элементов в отсортированном массиве </title>
<content> 
import numpy as np

arr =np.array([0, 1, 7, 12, 15])

'''
производит двоичный поиск в отсортированном массиве и возвращает место, в которое нужно было бы вставить значение, чтобы массив оставался отсортированным
'''
print(arr.searchsorted(9) ,end='\n\n')
print(arr.searchsorted([0, 8, 11, 16]))
</content>
<print>
3

[0 3 3 5]
</print>
</item>


<item>
<id>355</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
array				Преобразует входные данные (список,кортеж,массив или любую другую последовательность)в ndarray.Тип dtype задается явно или выводится неявно.Входные данные по умолчанию копируются 

asarray 			Преобразует входные данные в ndarray, но не копирует, если на вход уже подан ndarray 

arange 				Аналогична встроенной функции range, но возвращает массив, а не список 

ones, ones_like 	Порождает массив, состоящий из одних единиц, с заданными атрибутами shape и dtype. Функция ones_like принимает другой массив и порождает массив из одних единиц с такими же значениями shape и dtype 

zeros,zeros_like	Аналогичны ones и ones_like, только порождаемый массив состоит из одних нулей  

empty,  empty_like	Создают новые массивы, выделяя под них память, но, в отличие от ones и zeros, не инициализируют ее  

еуе, identity 		Создают единичную квадратную матрицу N х N (элементы на главной диагонали равны 1, все остальные - О) 

</title>
<content> 
</content>
<print>
</print>
</item> 



<item>
<id>356</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Унарные функции

abs, fabs			Вычислить абсолютное значение целых, вещественных или комплексных элементов массива. Для вещественных данных f abs работает быстрее  

sqrt 				Вычислить квадратный корень из каждого элемента. Эквивалентно arr ** 0.5 

square				Вычислить квадрат каждого элемента. Эквивалентно arr  **  2 

ехр 				Вычислить экспоненту е каждого элемента 

log,log10,			 
log2, loglp 		Натуральный (по основанию е), десятичный, двоичный логарифм и функция log ( 1  +  х)

sign 				Вычислить знак каждого элемента: 1 (для положительных чисел), 0 (для нуля) или -1 (для отрицательных чисел) 

ceil 				Вычислить для каждого элемента наименьшее целое число, не меньшее его 

floor 				Вычислить для каждого элемента наибольшее целое число, не большее его 

rint 				Округлить элементы до ближайшего целого с сохранением dtype 

modf 				Вернуть дробные и целые части массива в виде отдельных массивов 

isnan 				Вернуть булев массив, показывающий, какие значения являются NaN (не числами) 

isfinite, isinf 	Вернуть булев массив, показывающий, какие элементы являются конечными (не inf и   не NaN) или бесконечными соответственно 

cos, cosh, sin, 	 
sinh, tan, tanh 	Обычные и гиперболические тригонометрические функции

arccos, arccosh, 	 
arcsin, arcsinh, 
arctan, arctanh 	Обратные тригонометрические функции

logical_not 		Вычислить значение истинности not  х для каждого элемента. Эквивалентно -arr. 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>357</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Бинарные функции

add 				Сложить соответственные элементы массивов 

subtract			Вычесть элементы второго массива из соответственных элементов первого  

multiply 			Перемножить соответственные элементы массивов 

divide, 			 
floor_divide 		Деление и деление с отбрасыванием остатка

power 				Возвести элементы первого массива в степени, указанные во втором массиве 

maximum, fmax 		Поэлементный максимум. Функция fmax игнорирует значения NaN 

minimum, fmin 		Поэлементный минимум. Функция fmin игнорирует значения NaN 

mod 				Поэлементный модуль (остаток от деления) 

copysign 			Копировать знаки значений второго массива в соответственные элементы первого массива 

greater 			Поэлементное сравнение, возвращается булев массив. 
greater_equal, 		
less, less_equal, 
equal, not_equal 	Эквивалентны операторам &gt;, &gt;=, &lt;, &lt;=, ==, !=

logical_and,  		
logical_or,
logical_xor  		Вычислить логическое значение истинности логических операций Эквивалентны инфиксным операторам &amp;, |, ^
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>358</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Статистические методы массива 

sum 				Сумма элементов всего массива или вдоль одной оси. Для массивов нулевой длины функция sum  возвращает 0

mean 				Среднее арифметическое. Для массивов нулевой длины равно NaN 

std, var 			Стандартное отклонение и дисперсия, соответственно. Может быть задано число степеней свободы (по умолчанию знаменатель равен n) 

min, max 			Минимум и максимум 

argmin, argmax 		Индексы минимального и максимального элемента 

cumsum 				Нарастающая сумма с начальным значением 0

cumprod 			Нарастающее произведение с начальным значением 1  

</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>359</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Теоретико-множественные операции с массивами 

unique(x) 			Вычисляет отсортированное множество уникальных элементов 

intersect1d(x, у) 	Вычисляет отсортированное множество элементов, общих для х и у 

union1d(x, у) 		Вычисляет отсортированное объединение элементов 

in1d(x, у) 			Вычисляет булев массив, показывающий, какие элементы х встречаются в у 

setdiff1d(x, у) 	Вычисляет разность множеств, т. е. элементы, принадлежащие х, но не принадлежащие у 

setxor1d(x, у) 		Симметрическая разность множеств; элементы, принадлежащие одному массиву, но не обоим сразу 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>360</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Функции из модуля numpy.linalg 

diag 				Возвращает диагональные элементы квадратной матрицы в виде одномерного массива или преобразует одномерный массив в квадратную матрицу, в которой все элементы, кроме находящихся на главной диагонали, равны нулю 

dot 				Вычисляет произведение матриц 

trace 				Вычисляет след матрицы - сумму диагональных элементов 

det 				Вычисляет определитель матрицы 

eig 				Вычисляет собственные значения и собственные векторы квадратной матрицы 

inv 				Вычисляет обратную матрицу 

pinv 				Вычисляет псевдообратную матрицу Мура-Пенроуза для квадратной матрицы 

qr 					Вычисляет QR-разложение 

svd 				Вычисляет сингулярное разложение (SVD) 

solve 				Решает линейную систему Ах = b, где А - квадратная матрица 

lstsq 				Вычисляет решение уравнения y  =  xb по методу наименьших квадратов 
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>361</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Наиболее употребительные функции из модуля numpy.random 

seed 			Задает начальное значение генератора случайных чисел 

permutation 	Возвращает случайную перестановку последовательности или диапазона 

shufflе			Случайным образом переставляет последовательность на месте  

rand 			Случайная выборка с равномерным распределением 

randint 		Случайная выборка целого числа из заданного диапазона 

randn 			Случайная выборка с нормальным распределением со средним 0 и стандартным отклонением 1  (интерфейс похож на MATLAB) 

binomial 		Случайная выборка с биномиальным распределением 

normal 			Случайная выборка с нормальным (гауссовым) распределением 

beta 			Случайная выборка с бета-распределением 

chisquare 		Случайная выборка с распределением хи-квадрат 

gamma 			Случайная выборка с гамма-распределением 

uniform 		Случайная выборка с равномерным распределением на полуинтервале [0, 1) 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>362</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Функции конкатенации массива 

concatenate 		Самая общая функция - конкатенирует коллекцию массивов вдоль указанной оси 

vstack, row_stack 	Составляет массивы по строкам (вдоль оси 0) 

hstack 				Составляет массивы по столбцам (вдоль оси 1) 

column_stack		Аналогична hstack, но сначала преобразует одномерные массивы с двумерные векторы по столбцам 

dstack 				Составляет массивы по в глубину (вдоль оси 2) 

split 				Разбивает массив в указанных позициях вдоль указанной оси 

hsplit / vsplit		Вспомогательные функции для разбиения по оси 0,1 и 2 соответственно 
/ dsplit 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>363</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Методы u-функций

reduce(x) 			Агрегирует значения путем последовательного применения операции 

accurnulate(x)		Агрегирует все промежуточные агрегаты 

reduceat(x, bins) 	«Локальная» редукция, или «group bу». Редуцирует соседние срезы данных и порождает массив агрегатов 

outer(x, у) 		Применяет операцию ко всем парам элементов х и у. Результирующий массив имеет форму х.shape +  у.shape 
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>364</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Importing/exporting

np.loadtxt('file.txt') 	From a text file

np.genfromtxt('file.csv',delimiter=',') 	From a CSV file

np.savetxt('file.txt',arr,delimiter=' ') 	Writes to a text file

np.savetxt('file.csv',arr,delimiter=',') 	Writes to a CSV file
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>365</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Creating Arrays

np.array([1,2,3]) 	One dimensional array

np.array([(1,2,3),(4,5,6)]) 	Two dimensional array

np.zeros(3) 	1D array of length 3 all values 0

np.ones((3,4)) 	3x4 array with all values 1

np.eye(5) 	5x5 array of 0 with 1 on diagonal (Identity matrix)

np.linspace(0,100,6) 	Array of 6 evenly divided values from 0 to 100

np.arange(0,10,3) 	Array of values from 0 to less than 10 with step 3 (eg [0,3,6,9])

np.full((2,3),8) 	2x3 array with all values 8

np.random.rand(4,5) 	4x5 array of random floats between 0-1

np.random.rand(6,7)*100 	6x7 array of random floats between 0-100

np.random.randint(5,size=(2,3)) 	2x3 array with random ints between 0-4
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>366</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Inspecting Properties

arr.size 	Returns number of elements in arr

arr.shape 	Returns dimensions of arr (rows,columns)

arr.dtype 	Returns type of elements in arr

arr.astype(dtype) 	Convert arr elements to type dtype

arr.tolist() 		Convert arr to a Python list

np.info(np.eye) 	View documentation for np.eye
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>367</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Copying/sorting/reshaping

np.copy(arr) 		Copies arr to new memory

arr.view(dtype) 	Creates view of arr elements with type dtype

arr.sort() 			Sorts arr

arr.sort(axis=0) 	Sorts specific axis of arr

two_d_arr.flatten() 	Flattens 2D array two_d_arr to 1D

arr.T 				Transposes arr (rows become columns and vice versa)

arr.reshape(3,4) 	Reshapes arr to 3 rows, 4 columns without changing data

arr.resize((5,6)) 	Changes arr shape to 5x6 and fills new values with 0
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>368</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Adding/removing Elements

np.append(arr,values) 		Appends values to end of arr

np.insert(arr,2,values) 	Inserts values into arr before index 2

np.delete(arr,3,axis=0) 	Deletes row on index 3 of arr

np.delete(arr,4,axis=1) 	Deletes column on index 4 of arr
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>369</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Combining/splitting

np.concatenate((arr1,arr2),axis=0) 	Adds arr2 as rows to the end of arr1

np.concatenate((arr1,arr2),axis=1) 	Adds arr2 as columns to end of arr1

np.split(arr,3) 	Splits arr into 3 sub-arrays

np.hsplit(arr,5) 	Splits arr horizontally on the 5th index
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>370</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Indexing/slicing/subsetting

arr[5] 		Returns the element at index 5

arr[2,5] 	Returns the 2D array element on index [2][5]

arr[1]=4 	Assigns array element on index 1 the value 4

arr[1,3]=10 	Assigns array element on index [1][3] the value 10

arr[0:3] 	Returns the elements at indices 0,1,2 (On a 2D array: returns rows 0,1,2)

arr[0:3,4] 	Returns the elements on rows 0,1,2 at column 4

arr[:2] 	Returns the elements at indices 0,1 (On a 2D array: returns rows 0,1)

arr[:,1] 	Returns the elements at index 1 on all rows

arr&lt;5 	Returns an array with boolean values

(arr1&lt;3) &amp; (arr2&gt;5) 	Returns an array with boolean values

~arr 	Inverts a boolean array

arr[arr&lt;5] 	Returns array elements smaller than 5
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>371</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Scalar Math

np.add(arr,1) 		Add 1 to each array element

np.subtract(arr,2) 	Subtract 2 from each array element

np.multiply(arr,3) 	Multiply each array element by 3

np.divide(arr,4) 	Divide each array element by 4 (returns np.nan for division by zero)

np.power(arr,5) 	Raise each array element to the 5th power
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>372</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Vector Math

np.add(arr1,arr2) 			Elementwise add arr2 to arr1

np.subtract(arr1,arr2) 		Elementwise subtract arr2 from arr1

np.multiply(arr1,arr2) 		Elementwise multiply arr1 by arr2

np.divide(arr1,arr2) 		Elementwise divide arr1 by arr2

np.power(arr1,arr2) 		Elementwise raise arr1 raised to the power of arr2

np.array_equal(arr1,arr2) 	Returns True if the arrays have the same elements and shape

np.sqrt(arr) 	Square root of each element in the array

np.sin(arr) 	Sine of each element in the array

np.log(arr) 	Natural log of each element in the array

np.abs(arr) 	Absolute value of each element in the array

np.ceil(arr) 	Rounds up to the nearest int

np.floor(arr) 	Rounds down to the nearest int

np.round(arr) 	Rounds to the nearest int
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>373</id>
<menu>Numpy</menu>
<submenu>Заметки</submenu>
<title>
Statistics

np.mean(arr,axis=0) 	Returns mean along specific axis

arr.sum() 				Returns sum of arr

arr.min() 				Returns minimum value of arr

arr.max(axis=0) 		Returns maximum value of specific axis

np.var(arr) 			Returns the variance of array

np.std(arr,axis=1) 		Returns the standard deviation of specific axis

arr.corrcoef() 			Returns correlation coefficient of array
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>374</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Замена значений массива по условию</title>
<content> 
import numpy as np

l = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]

m = np.array(l)
m[m &lt; 5] = 0

print(m)
</content>
<print>
[[0 0 0]
 [0 5 6]
 [7 8 9]]
</print>
</item> 

<item>
<id>375</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Прихотливое индексирование -  fancy indexing</title>
<content>
import numpy as np

m = np.empty((4,4),dtype='int32')
for i in range(4):
    m[i] = i

print(m,end='\n\n')

'''
Чтобы выбрать подмножество строк в определенном порядке,можно просто передать список или массив целых чисел, описывающих желаемый порядок.Отрицательные числа выбирают строки с конца
'''
print(m[[2,0,3,-1]]) 
</content>
<print>
[[0 0 0 0]
 [1 1 1 1]
 [2 2 2 2]
 [3 3 3 3]]

[[2 2 2 2]
 [0 0 0 0]
 [3 3 3 3]
 [3 3 3 3]]
</print>
</item> 

<item>
<id>376</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Прихотливое индексирование -  take()</title>
<content>
import numpy as np

arr = np.arange(10) * 100
inds = [7,  1,  2,  6]

print(arr, end='\n\n')
# инициализирует новый массив по индексам 
print(arr.take(inds), end='\n\n')

inds = [2, 0, 2, 1]
arr =  np.random.randn(2,4)

print(arr, end='\n\n')
print(arr.take(inds,axis=1))
</content>
<print>
[  0 100 200 300 400 500 600 700 800 900]

[700 100 200 600]

[[ 0.46506263  0.10440986 -1.3039181   0.99243664]
 [-0.46599251 -0.08268816  0.85564729  1.33252052]]

[[-1.3039181   0.46506263 -1.3039181   0.10440986]
 [ 0.85564729 -0.46599251  0.85564729 -0.08268816]]
</print>
</item> 

<item>
<id>377</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Прихотливое индексирование -  put()</title>
<content>
import numpy as np

arr = np.arange(10) * 100
inds = [7,  1,  2,  6]

print(arr, end='\n\n')

# вставляет в позиции inds число 42
np.put(arr,inds,42)

print(arr, end='\n\n')
</content>
<print>
[  0 100 200 300 400 500 600 700 800 900]

[  0  42  42 300 400 500  42  42 800 900]
</print>
</item> 

<item>
<id>378</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Выбор значения по условию</title>
<content>
xarr = np.array ([1.1,  1.2,  1.3,  1.4,  1.5])
yarr = np.array ([2.1,  2.2,  2.3,  2.4,  2.5])
cond = np.array([True, False, True, True, False])

print(np.where(cond, xarr, yarr)) 
</content>
<print>
[ 1.1  2.2  1.3  1.4  2.5]
</print>
</item> 

<item>
<id>379</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Выбор значения по условию (2)</title>
<content> 
import numpy as np

l = [[1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
     [13, 14, 15, 16]]

m = np.array(l)

print(np.where(m % 5, 0, m),end='\n\n')
print(np.where(m &lt; 7, 0, 1))
</content>
<print>
[[ 0  0  0  0]
 [ 5  0  0  0]
 [ 0 10  0  0]
 [ 0  0 15  0]]

[[0 0 0 0]
 [0 0 1 1]
 [1 1 1 1]
 [1 1 1 1]]
</print>
</item> 

<item>
<id>380</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Суммирование значений по условию</title>
<content> 
import numpy as np

l = [[1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
     [13, 14, 15, 16]]

m = np.array(l)

print(m[(m &lt; 5)].sum())
</content>
<print>
10
</print>
</item> 

<item>
<id>381</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Сортировка 2-x массивов</title>
<content> 
import numpy as np

first_name = np.array(['Bob','Jane','Steve','Bill','Barbara'])
last_name = np.array(['Jones','Arnold','Arnold','Jones','Walters'])
sorter =  np.lexsort((first_name,last_name))

print(list(zip(last_name[sorter], first_name[sorter])))
</content>
<print>
[('Arnold', 'Jane'), ('Arnold', 'Steve'), ('Jones', 'Bill'), ('Jones', 'Bob'), ('Walters', 'Barbara')]
</print>
</item> 

<item>
<id>382</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Сортировка некоторых строк</title>
<content> 
import numpy as np

arr = np.random.randn(5,5)

print(arr, end='\n\n')

arr[::2].sort(1)

print(arr, end='\n\n')
</content>
<print>
[[-0.30263048  0.04135036  0.98579241  0.75025984 -0.05812912]
 [ 0.97941441  0.82691859 -0.19144981  0.41805951 -0.13163224]
 [-1.09701117 -0.46242989 -1.21500281  0.91469593  0.07277518]
 [-0.98811083 -0.58526629 -1.65939717  0.27014333  0.36883042]
 [ 0.35082203  0.14277006  1.05158927 -0.1281721  -0.05746653]]

[[-0.30263048 -0.05812912  0.04135036  0.75025984  0.98579241]
 [ 0.97941441  0.82691859 -0.19144981  0.41805951 -0.13163224]
 [-1.21500281 -1.09701117 -0.46242989  0.07277518  0.91469593]
 [-0.98811083 -0.58526629 -1.65939717  0.27014333  0.36883042]
 [-0.1281721  -0.05746653  0.14277006  0.35082203  1.05158927]]
</print>
</item> 

<item>
<id>383</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Какому интервалу принадлежит число</title>
<content> 
import numpy as np

data = np.floor(np.random.uniform(0,10000,size=50))
bins = np.array([0,100,1000, 5000, 10000])

print(data,end='\n\n')

labels = bins.searchsorted(data)

print(labels,end='\n\n')
print(np.digitize(data,bins))
</content>
<print>
[ 2365.  9469.  8852.  7538.  1930.  7482.  7743.  7171.  5996.  9235.
  1331.  5852.  7817.  4225.  4783.  9342.  1333.  6330.  7256.  2747.
  6344.  5297.  9416.  8287.  5412.  7085.  7604.  3907.  8702.  6663.
  3059.   874.  5708.  5192.  6478.  1088.  5768.  7517.  5417.  5921.
  2007.  8522.  9248.  1584.  1192.  8643.  6328.  7699.  4357.  5032.]

[3 4 4 4 3 4 4 4 4 4 3 4 4 3 3 4 3 4 4 3 4 4 4 4 4 4 4 3 4 4 3 2 4 4 4 3 4
 4 4 4 3 4 4 3 3 4 4 4 3 4]

[3 4 4 4 3 4 4 4 4 4 3 4 4 3 3 4 3 4 4 3 4 4 4 4 4 4 4 3 4 4 3 2 4 4 4 3 4
 4 4 4 3 4 4 3 3 4 4 4 3 4]
</print>
</item>

<item>
<id>384</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Структурные массивы </title>
<content> 
import numpy as np
'''
Структурный массив - это объект ndarray,в котором каждый элемент можно рассматривать как аналог строки в таблице SQL, содержащий несколько именованных полей
'''
dtype = [('х ', np.float64), ('y', np.int32)]
sarr = np.array([(1.5, 6), (np.pi, -2)], dtype=dtype)

print(sarr)
print(sarr[0])
print(sarr[0]['y'])
</content>
<print>
[( 1.5       ,  6) ( 3.14159265, -2)]
( 1.5, 6)
6
</print>
</item>

<item>
<id>385</id>
<menu>Numpy</menu>
<submenu>Расширеный функционал</submenu>
<title>Вложенные типы данных и многомерные поля </title>
<content> 
import numpy as np

dtype = [('x', np.float64, 3), ('y', np.int32)]
sarr = np.zeros(4, dtype=dtype)

print(sarr, end='\n\n')
print(sarr[0]['x'], end='\n\n')
print(sarr['x'], end='\n\n')

dtype = [('x',[('a', 'f8'),('b', 'f4')]), ('y',np.int32)]
data = np.array([((1, 2),5),  ((3,4), 6)], dtype=dtype)

print(data['x'])
print(data['y'])
print(data['x']['a'])
</content>
<print>
[([ 0.,  0.,  0.], 0) ([ 0.,  0.,  0.], 0) ([ 0.,  0.,  0.], 0)
 ([ 0.,  0.,  0.], 0)]

[ 0.  0.  0.]

[[ 0.  0.  0.]
 [ 0.  0.  0.]
 [ 0.  0.  0.]
 [ 0.  0.  0.]]

[( 1.,  2.) ( 3.,  4.)]
[5 6]
[ 1.  3.]
</print>
</item>

<item>
<id>386</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Общий формат while</title>
<content> 
while &lt;test1&gt;:          
    &lt;statements1&gt;   
	
    # Выйти из цикла, пропустив часть else
	if &lt;test2&gt;: break;	 
	
	# Перейти в начало цикла, к выражению test
    if &lt;test3&gt;: continue 
# Необязательная часть else
else:   
	'''                 
	Выполняется, если выход из цикла 
	производится не инструкцией break
    '''
	&lt;statements2&gt;        
					     
x = "python"
while x:
    print(x, end=' ')
    x = x[1:]
else:
	print('\nstring is over')
</content>
<print>
python ython thon hon on n 
string is over
</print>
</item> 

<item>
<id>387</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Имитация do-while цикла</title>
<content> 
x = 0
while True:
	x +=1
	print(x,end = ' ')
	if x == 10:break
</content>
<print>
1 2 3 4 5 6 7 8 9 10 
</print>
</item> 

<item>
<id>388</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Инструкция сontinue</title>
<content> 
x = 10
while x:
    x = x-1                   
    if x % 2 != 0: continue 
    print(x, end=' ')
</content>
<print>
8 6 4 2 0 
</print>
</item> 

<item>
<id>389</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Инструкция break</title>
<content> 
while 1:
    name = input('Enter name:')
    if name == 'stop': break
    age = input('Enter age: ')
    print('Hello', name, '=>', int(age) ** 2)
</content>
<print>
Enter name:Den
Enter age: 33
Hello Den => 1089
Enter name:Ned
Enter age: 23
Hello Ned => 529
Enter name:stop
</print>
</item> 

<item>
<id>390</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Общий формат цикла for</title>
<content> 
# Присваивает элементы объекта с переменной цикла
for &lt;target&gt; in &lt;object&gt;: 
&lt;statements&gt;
	
	# Выход из цикла, минуя блок else
    if &lt;test&gt;: break   
		
	# Переход в начало цикла
    if &lt;test&gt;: continue   
else:
	# Если не была вызвана инструкция ‘break
	&lt;statements&gt;        
</content>
<print>
</print>
</item> 

<item>
<id>391</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Типичные варианты использования for</title>
<content> 
l = ['spam', 'eggs', 'ham']
for x in l:
    print(x, end=' ')
	
print()

sum = 0
for x in [1, 2, 3, 4]:
    sum = sum + x
	
print(sum,end='\n')

prod = 1
for item in range(1, 5):
    prod *= item
	
print(prod)
</content>
<print>
spam eggs ham 
10
24
</print>
</item> 

<item>
<id>392</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Обход объектов с помощью for</title>
<content> 
S = 'lumberjack'
T = ('and', 'I’m', 'okay')
T1 = [(1, 2), (3, 4), (5, 6)]
for x in S:
	# Обход строки
    print(x, end=' ') 
	
print()

for x in T:
	# Обход элементов кортежа
    print(x, end=' ')
	
print()

D = {'a': 1, 'b': 2, 'c': 3}

# Используется итератор словаря
# и операция индексирования
for key in D:
	print(key, '=>', D[key])
	
print()					
		
D = {'a': 4, 'c': 6, 'b': 5}
for (key, value) in D.items():
    print(key,' => ',value)
</content>
<print>
l u m b e r j a c k 
and I’m okay 
a => 1
b => 2
c => 3
a  =>  4
c  =>  6
b  =>  5
</print>
</item> 

<item>
<id>393</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Присваивание кортежа (for)</title>
<content> 
T = [(1, 2), (3, 4), (5, 6)]

# Операция присваивания кортежа
for (a, b) in T: 
	print(a, b)
</content>
<print>
1 2
3 4
5 6
</print>
</item> 

<item>
<id>394</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Обход вложеных структур - for</title>
<content> 
# Вложенные структуры также могут использоваться
((a, b), c) = ((1, 2), 3) 

print(((a, b), c))

for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]:
    print(a, b, c)
	
print()

for ((a, b), c) in [([7, 8], 9), ['XY', 12]]:
    print(a, b, c)
</content>
<print>
((1, 2), 3)
1 2 3
4 5 6
7 8 9
X Y 12
</print>
</item> 

<item>
<id>395</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Присваивание последовательности множеству переменных</title>
<content> 
a, *b, c = (10, 21, 32, 44) 

print(a, b, c)  
            
(1, [2, 3], 4)
for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
    print(a, b, c)
</content>
<print>
10 [21, 32] 44
1 [2, 3] 4
5 [6, 7] 8
</print>
</item> 

<item>
<id>396</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Вложенные циклы for</title>
<content> 
seq1 = 'spam'
seq2 = 'scam'
res = [] 

for x in seq1: 
    if x in seq2: 
        res.append(x) 
		
for i in res:
    print(i, end=' ')
</content>
<print>
s a m 
</print>
</item> 

<item>
<id>397</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Генерирование индексов и элементов: enumerate</title>
<content> 
n = 'python'
for(i,item) in enumerate(n):
    print(i,' ',item)
</content>
<print>
0   p
1   y
2   t
3   h
4   o
5   n
</print>
</item> 

<item>
<id>398</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Функция map()</title>
<content> 
#map() - привязывает функцию к аргументу
nums = [1, 2, 3]
#Обычный вид
def f(x):
    return x*x
	
for num in nums:
    print (f(num),end=' ')
	
print()

# С использованием map()
for x in map(f,nums):
    print(x, end=' ')
</content>
<print>
1 4 9 
1 4 9 
</print>
</item> 

<item>
<id>399</id>
<menu>Циклы</menu>
<submenu>Базовые операции</submenu>
<title>Функция filter()</title>
<content> 
'''
Возвращает итератор элементов,для которых заданная функция возвращает True
'''
numbers = [10, 4, 2, -1, 6]
l = filter(bool, ['spam', '', 'ni'])

print(list(l))

l = filter(lambda x:x &lt;5,numbers)

print(list(l))
</content>
<print>
['spam', 'ni']
[4, 2, -1]
</print>
</item>


<item>
<id>400</id>
<menu>Циклы</menu>
<submenu>Заметки</submenu>
<title>
Функция enumerate возвращает объект-генератор – разновидность объекта,
который поддерживает протокол итераций.Имеет метод __next__, вызываемый встроенной функцией
next и возвращающий кортеж (index, value) для каждого элемента списка
</title>
<content> 
</content>
<print>
</print>
</item> 


<item>
<id>401</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Инициализация списка</title>
<content> 
l=[]
</content>
<print>
</print>
</item> 

<item>
<id>402</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Длина списка</title>
<content> 
l=[1,2,3]

print(len(l))
</content>
<print>
3
</print>
</item> 

<item>
<id>403</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Конкатенация списков</title>
<content> 
l = [1, 2, 3]
s = [4, 5, 6]

print(l + s)
</content>
<print>
[1, 2, 3, 4, 5, 6]
</print>
</item> 

<item>
<id>404</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Повторение списков</title>
<content> 
s = [4, 5, 6]

print(s * 2)
</content>
<print>
[4, 5, 6, 4, 5, 6]
</print>
</item> 

<item>
<id>405</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Проверка на вхождение</title>
<content> 
l = [1, 2, 3]

print(3 in l)
</content>
<print>
True
</print>
</item> 

<item>
<id>406</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Итерация списка</title>
<content> 
for x in [1, 2, 3]:
	print(x, end=" ")
</content>
<print>
1 2 3
</print>
</item> 

<item>
<id>407</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Доступ к элементу / Срезы</title>
<content> 
l=['one', 'two', 'three']

print(l[2])
print(l[-2])
print(l[1:])
</content>
<print>
one
three
['two', 'three']
</print>
</item> 

<item>
<id>408</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Двумерный массив</title>
<content> 
m=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(m[1])
print(m[1][1])
</content>
<print>
[4, 5, 6]
5
</print>
</item> 

<item>
<id>409</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Присваивание по срезам</title>
<content> 
l=[1, 2, 3]
l[0:2]=[10, 11]

print(l)
</content>
<print>
[10, 11, 3]
</print>
</item> 

<item>
<id>410</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Добавление элемента - append()</title>
<content> 
l=[1, 2, 3]
l.append('hello')

print(l)
</content>
<print>
[1, 2, 3, 'hello']
</print>
</item> 

<item>
<id>411</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка - sort()</title>
<content> 
l=['Dog','cat' ,'Mouse' ]

#Сортировка с учетом регистра символов
l.sort() 

print(l)

#Сортировка с учетом нижнего регистра
l.sort(key=str.lower)  

print(l)

#Обратная сортировка
l.sort(key=str.lower,reverse=True) 

print(l)
</content>
<print>
['Dog', 'Mouse', 'cat']
['cat', 'Dog', 'Mouse']
['Mouse', 'Dog', 'cat']
</print>
</item> 

<item>
<id>412</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Сортировка с возвратом результата - sorted()</title>
<content> 
l=['Dog','cat' ,'Mouse' ]
l = sorted(l, key=str.lower, reverse=True)

print(l)

s = sorted([x.lower() for x in l], reverse=True)

print(s)
</content>
<print>
['Mouse', 'Dog', 'cat']
['mouse', 'dog', 'cat']
</print>
</item> 

<item>
<id>413</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Добавление нескольких элементов в конец списке - extend()</title>
<content> 
l=[1, 2]
l.extend([3, 4, 5])

print(l)
</content>
<print>
[1, 2, 3, 4, 5]
</print>
</item> 

<item>
<id>414</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Удаление и возврат элемента - pop()</title>
<content> 
l=[1, 2, 3, 4, 5]

print(l.pop(),'-',l)
print(l.pop(1),'-',l)
</content>
<print>
5 - [1, 2, 3, 4]
2 - [1, 3, 4]
</print>
</item> 

<item>
<id>415</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Реверс списка - reverse()</title>
<content> 
l=[1, 2, 3, 4, 5]
l.reverse()

print(l)
</content>
<print>
[5, 4, 3, 2, 1]
</print>
</item> 

<item>
<id>416</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Встроенная функция сортировки - reversed()</title>
<content> 
l=[1, 2, 3, 4, 5]

print(list(reversed(l)))
</content>
<print>
[5, 4, 3, 2, 1]
</print>
</item> 

<item>
<id>417</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Вставка элемента в нужную позицию - insert()</title>
<content> 
l=['one', 'two', 'three']
l.insert(1,'four')

print(l)
</content>
<print>
['one', 'four', 'two', 'three']
</print>
</item> 

<item>
<id>418</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Удаление элемента с определенным значением - remove()</title>
<content> 
l=['one', 'two', 'three']
l.remove('two')

print(l)
</content>
<print>
['one', 'three']
</print>
</item> 

<item>
<id>419</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Удаление элемента по индексу - del</title>
<content> 
l=['one', 'two', 'three']
del l[0]

print(l)
</content>
<print>
['two', 'three']
</print>
</item> 

<item>
<id>420</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Удаление сегмента списка - del</title>
<content> 
l=['one', 'two', 'three']
del l[1:]

print(l)

l=['one', 'two', 'three']
l[1:]=[]

print(l)
</content>
<print>
['one']
['one']
</print>
</item> 

<item>
<id>421</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Удаление и возврат значения - pop()</title>
<content> 
l=['one', 'two', 'three']
# Удаление и возврат последнего элемента
l.pop()  

print(l)
# Удаление и возврат элемента с заданой позиции 
l.pop(1)  

print(l)
</content>
<print>
['one', 'two'] 
['one']
</print>
</item> 

<item>
<id>422</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Сравнение списков</title>
<content>
L1 = [2, 3, 4]
L2 = [2, 3, 4]
'''
Оператор == проверяет равенство значений. Интерпретатор выполняет
проверку на равенство, рекурсивно сравнивая все вложенные объекты.
'''
print(L1 == L2)
'''
Оператор is проверяет идентичность объектов. Интерпретатор проверяет,
являются ли сравниваемые объекты одним и тем же объектом (то есть расположены ли они по одному и тому же адресу в памяти).
'''
print(L1 is L2)

L1 = [1, ('a', 3)]
L2 = [1, ('b', 2)]

print(L1 &lt; L2, L1 &gt; L2)
</content>
<print>
True
False
False True
</print>
</item> 

<item>
<id>423</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Сумма списка,макс/мин элемент - sum(), max(), min()</title>
<content>
l = [1, 22, 54, 3]

print(sum(l))
print(max(l))
print(min(l))
</content>
<print>
80
54
1
</print>
</item>

<item>
<id>424</id>
<menu>Списки</menu>
<submenu>Базовые операции</submenu>
<title>Проверка на истинность массива - any(), all()</title>
<content> 
'''
Функция sum вычисляет сумму всех чисел в любом итерируемом объекте. Встроенные функции any и all возвращают True, если любой (any) или все (all) элементы итерируемого объекта являются истинными значениями соответственно
'''
l = [1, '', 25]

print(any(l))
print(all(l))
</content>
<print>
True
False
</print>
</item>


<item>
<id>425</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title>
Списки относятся к категории изменяемых объектов, поэтому они поддерживают операции, которые изменяют сам список непосредственно. То есть все изменяются сам список объектов и не создается новую копию</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>426</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title>
Упорядоченные коллекции объектов произвольных типов.
C функциональной точки зрения, списки – это лишь место, в котором собраны другие объекты, поэтому их можно также рассматривать как группы. Кроме того, списки обеспечивают позиционное упорядочение элементов слева направо (то есть они являются последовательностями)
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>427</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title>
Доступ к элементам по смещению.
Так же как и в случае со строками, вы можете использовать операцию индексирования для извлечения отдельных объектов из списка по их смещениям. Поскольку элементы в списках упорядочены по их местоположению, можно также выполнять такие действия, как извлечение срезов и конкатенация.</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>428</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title>
Переменная длина,гетерогенность и произвольное число уровней вложенности.
В отличие от строк, списки могут увеличиваться и уменьшаться непосредственно (их длина может изменяться) и могут содержать не только односимвольные строки, но и любые другие объекты (списки гетерогенны). Списки могут содержать другие сложные объекты и поддерживают возможность создания произвольного числа уровней вложенности, поэтому имеется возможность создавать списки списков из списков и так далее.</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>429</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title>
Относятся к категории изменяемых объектов.
В терминах категорий типов списки могут изменяться непосредственно (являются изменяемыми объектами) и поддерживают все операции над последовательностями, которые поддерживаются и строками, такие как индексирование, извлечение срезов и конкатенация. Операции над последовательностями одинаковым образом работают как в случае списков, так и в случае строк, единственное отличие – при применении операций над последовательностями (таких как конкатенация и извлечение среза) к спискам возвращается новый список, а не новая строка. Кроме того, т. к. списки являются изменяемыми объектами, они поддерживают также операции, которые не поддерживаются строками (такие как операции удаления и присваивания по индексам, изменяющие список непосредственно).
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>430</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title>
Массивы ссылок на объекты.
Формально списки в языке Python могут содержать ноль или более ссылок на другие объекты. Списки чем-то напоминают массивы указателей (адресов). Извлечение элемента из списка в языке Python выполняется так же быстро, как извлечение элемента массива в языке C. В действительности списки – это самые настоящие массивы языка C, реализованные в интерпретаторе Python, а не связанные структуры данных. Как мы узнали в главе 6, всякий раз, когда используется ссылка на объект, интерпретатор разыменовывает ее, поэтому ваши программы всегда будут иметь дело только с объектами. Всякий раз, когда выполняется присваивание объекта элементу какой-либо структуры или имени переменной, интерпретатор Python сохраняет ссылку на этот объект, а не его копию (за исключением, когда явно запрашивается выполнение операции копирования).
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>431</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title>
Словари – это отображения, а не последовательности. Вследствие того, что словари не предусматривают никакого упорядочения элементов, такие операции, как конкатенация (упорядоченное объединение) и извлечение среза (извлечение непрерывного блока элементов), неприменимы.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>432</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title>
Ключи можно создавать при определении словаря в виде литерала (в этом случае они встраиваются непосредственно в литерал) или при присваивании значения новому ключу существующего объекта словаря.
</title>
<content> 
</content>
<print>
</print>
</item> 

<item>
<id>433</id>
<menu>Списки</menu>
<submenu>Заметки</submenu>
<title> 
В качестве ключей могут использоваться любые другие неизменяемые объекты (то есть не списки). Например, в качестве ключей допустимо использовать целые числа, что превращает словарь в подобие списка (как минимум, в смысле индексирования). В качестве ключей можно также использовать кортежи, что позволяет создавать составные ключи.Экземпляры классов также могут играть роль ключей при условии, что они поддерживают определенные методы, которые сообщат интерпретатору, что он имеет дело с неизменяемым объектом, в противном случае они будут бесполезны, если рассматривать их как фиксированные ключи.
</title>
<content> 
</content>
<print>
</print>
</item>


<item>
<id>434</id>
<menu>Генераторы</menu>
<submenu>Базовые операции</submenu>
<title>Генераторы словарей</title>
<content> 
D = {k: v for (k, v) in zip(['a', 'b', 'c'], [1, 2, 3])}
print(D)

D = {x: x ** 2 for x in range(1, 5)} 
print(D)

D = {c: c * 4 for c in 'SPAM'}
print(D)

D = {c.lower(): c + '!' for c in ['SPAM', 'EGGS', 'HAM']}
print(D)
</content>
<print>
{'a': 1, 'b': 2, 'c': 3}
{1: 1, 2: 4, 3: 9, 4: 16}
{'S': 'SSSS', 'P': 'PPPP', 'A': 'AAAA', 'M': 'MMMM'}
{'spam': 'SPAM!', 'eggs': 'EGGS!', 'ham': 'HAM!'}
</print>
</item> 

<item>
<id>435</id>
<menu>Генераторы</menu>
<submenu>Базовые операции</submenu>
<title>Генераторы списков</title>
<content> 
for x in [1, 2, 3, 4]: 
	print(x ** 2, end=' ')
print()

for x in (1, 2, 3, 4): 
	print(x ** 3, end=' ')
print()

for x in 'spam': 
	print(x * 2, end=' ')
print()

res = [x + y for x in [0, 1, 2] for y in [100, 200, 300]]

print(res)
</content>
<print>
1 4 9 16 
1 8 27 64 
ss pp aa mm 
[100, 200, 300, 101, 201, 301, 102, 202, 302]
</print>
</item> 

<item>
<id>436</id>
<menu>Генераторы</menu>
<submenu>Базовые операции</submenu>
<title>Расширенный синтаксис генераторов списков</title>
<content> 
'''
Отобрать только строки, начинающиеся с символа s в ранее созданном файле
'''
lines = [line.rstrip() for line in open('data.txt') if line[0] == 's']

print(lines)

l = [x + y for x in 'abc' for y in 'lmn']

print(l)

d = {ix: line for (ix, line) in enumerate(open('data.txt')) if(len(line) > 5)}

print(d)

a = [i for i in range(30,250) if i%30 == 0 or i%31 == 0]

print(a)
</content>
<print>
['spam...']
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
{0: 'spam...\n', 1: '99...\n', 2: "['eggs']|..\n"}
[30, 31, 60, 62, 90, 93, 120, 124, 150, 155, 180, 186, 210, 217, 240, 248]
</print>
</item> 

<item>
<id>437</id>
<menu>Генераторы</menu>
<submenu>Базовые операции</submenu>
<title>Сложные примеры генераторов</title>
<content> 
l = [(x, y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]

print(l)

# аналог,используя циклы
res = []
for x in range(5):
    if x % 2 == 0:
        for y in range(5):
            if y % 2 == 1:
                res.append((x, y))
				
print(res)

l = range(-5,5)
s = ['even' if x %2 == 0 else 'odd' for x in l ]

print(s)
</content>
<print>
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']
</print>
</item> 

<item>
<id>438</id>
<menu>Генераторы</menu>
<submenu>Базовые операции</submenu>
<title>Сложные пример генераторов(2)</title>
<content> 
M = [[1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]]
N = [[2, 2, 2],
    [3, 3, 3],
    [4, 4, 4]]
l = [M[row][col] * N[row][col] for row in range(3) for col in range(3)]

print(l)

l =  [[M[row][col] * N[row][col] for col in range(3)] for row in range(3)]

print(l)

# Используя циклы
res = []
for row in range(3):
    tmp = []
    for col in range(3):
        tmp.append(M[row][col] * N[row][col])
    res.append(tmp)
	
print(res)
</content>
<print>
[2, 4, 6, 12, 15, 18, 28, 32, 36]
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]
</print>
</item>


<item>
<id>439</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>Определение функции</title>
<content> 
def &lt;name&gt;(arg1, arg2,... argN):
	&lt;statements&gt;
	
	# Если требуется вернуть результат
	return &lt;value&gt;  
</content>
<print>
</print>
</item> 

<item>
<id>440</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>Вызов функции</title>
<content> 
def f(x):
    print(x)
	
# Связывание объекта функции с именем
func = f	
	
# Вызов функции
func(1)			
</content>
<print>
1
</print>
</item> 

<item>
<id>441</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>Присоединение атрибутов</title>
<content> 
def f(x):
    print(x)
	
f.attr = "hello"

print(f.attr)
</content>
<print>
hello
</print>
</item> 

<item>
<id>442</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>nonlocal</title>
<content> 
def tester(start):
    state = start
    def nested(label):
		# без инструкции nonlocal 
        nonlocal state	
        print(label, state)
        state += 1 
    return nested
F = tester(0)
F('hello')
</content>
<print>
hello 0

# без инструкции nonlocal 
UnboundLocalError: local variable 'state' referenced before assignment
</print>
</item> 

<item>
<id>443</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>Рекурсивные функции вычисление суммы</title>
<content> 
def mysum(L):
    if not L:
        return 0
    else:
        return L[0] + mysum(L[1:]) 
		
L = [1,2,3,4,5]

print(mysum(L))
</content>
<print>
15
</print>
</item> 

<item>
<id>444</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>lambda выражения</title>
<content> 
f = lambda x, y, z: x + y + z
result = f(1, 2, 3)

print(result)

L = [lambda x: x**2,
    lambda x: x**3,
    lambda x: x**4]
	
for f in L:
    print(f(2),end=' ')
	
print()
print(L[0](3))

L = [1, 6, 8, 4, 7, 3, 2, 1, 0]
l = lambda x :[y for y in L if y &lt; x]

print(l(5))
</content>
<print>
6
4 8 16 
9
[1, 4, 3, 2, 1, 0]
</print>
</item> 

<item>
<id>445</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>Вложенные lambda-выражения </title>
<content> 
def action(x):
	# Создать и вернуть ф-цию, запомнить x
    return (lambda y: x + y) 
	
act = action(99)

# Вызвать функцию, созданную ф-цией action
print(act(2))       
'''
Эта структура lambda-выражений создает функцию, которая при вызове создает другую функцию. В обоих случаях вложенное lambda-выражение имеет доступ к переменной x в объемлющем lambda-выражении. Этот фрагмент будет работать, но программный код выглядит весьма замысловато, поэтому в интересах соблюдения удобочитаемости лучше избегать использования вложенных друг в друга lambda-выражений.
'''
action = (lambda x: (lambda y: x + y))
act = action(99)
act(3)

print(act(3))
print(((lambda x: (lambda y: x + y))(99))(4))
</content>
<print>
101
</print>
</item> 

<item>
<id>446</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>Функция map()</title>
<content> 
counters = [1, 2, 3, 4]
def inc(x): 
	return x + 10 
	
l = list(map(inc, counters))

print(l) 

m = list(map((lambda x: x + 3), counters))

print(m)
</content>
<print>
[11, 12, 13, 14]
[4, 5, 6, 7]
</print>
</item> 

<item>
<id>447</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>Функция filter()</title>
<content> 
L = list(range(-5, 5))
l = list(filter((lambda x: x > 0), range(-5, 5)))

print(l)

l = list(filter(lambda x: x % 2 == 0,L))

print(l)
</content>
<print>
[1, 2, 3, 4]
[-4, -2, 0, 2, 4]
</print>
</item> 

<item>
<id>448</id>
<menu>Встроеные функции</menu>
<submenu>Базовые операции</submenu>
<title>Функция reduce()</title>
<content> 
'''
reduce может принимать третий необязательный аргумент, который используется в качестве начального значения и служит значением по умолчанию, когда передаваемая последовательность не содержит ни одного элемента
Цепочка вызовов связывается с помощью промежуточного результата (res). Если список пустой, просто используется третий параметр 
x – текущий пункт, а – аккумулятор. Это значение, которое возвращает выполнение lambda на предыдущем пункте. reduce() перебирает все значения, и запускает для каждого lambda на текущих значениях а и х, и возвращает результат в а для следующей итерации.
'''
from functools import reduce
L = [1, 2, 3, 4]
l = reduce((lambda a, x: a + x), L)

print(l)

l =  reduce((lambda a, x: a * x), L)

print(l)

l = reduce(lambda res, x: [x]+res, L, [])

print(l)
</content>
<print>
10
24
[4, 3, 2, 1]
</print>
</item>

<item>
<id>449</id>
<menu>Networking</menu>
<submenu>Simple threaded server</submenu>
<title>Client</title>
<content> 
import socket,common

host = 'localhost'
port = 10000
buf = 64

if __name__ == '__main__':
    while True:
        try:
            sock = socket.socket(socket.AF_INET,
                                 socket.SOCK_STREAM)
            sock.connect((host, port))
            print('\nConnected to {}:{}'.format(host, port))
            print("Type message, enter to send, 'q' to quit")
            msg = input()
            if msg == 'q': break
			
			# Блокировать до отправки
            common.send_msg(sock, msg)  
			
            print('Sent message: {}'.format(msg))
			# Блокировать до получения полного сообщения
            msg = common.recv_msg(sock)  
                                             
                                             
            print('Received echo: ' + msg)
        except ConnectionError:
            print('Socket error')
            break
        finally:
            sock.close()
            print('Closed connection to server\n')
</content>
<print>

</print>
</item>

<item>
<id>450</id>
<menu>Networking</menu>
<submenu>Simple threaded server</submenu>
<title>Server</title>
<content> 
import threading
import common

host = 'localhost'
port = 10000
buf = 64


def handle_client(sock, addr):
    try:
        msg = common.recv_msg(sock)
        print(msg)
        common.send_msg(sock,msg)
    except(ConnectionError, BrokenPipeError):
        print("Socket Error")
    finally:
        sock.close()

if __name__ == "__main__":
    sock = common.create_listen_socket(host, port)
    addr = sock.getsockname()

    while True:
        conn, addr = sock.accept()
        '''
        Thread will run function handle_client() autonomously
        and concurrently to this while loop
        '''

        thread = threading.Thread(target=handle_client,args=[conn,addr],daemon=True)
        thread.start()
        print('Connection from {}'.format(addr))
</content>
<print>

</print>
</item>

<item>
<id>451</id>
<menu>Networking</menu>
<submenu>Simple threaded server</submenu>
<title>common</title>
<content> 
import socket
HOST = ''
PORT = 4040


def create_listen_socket(host, port):
    """ Иницализация сокетов ,через которые сервер будет получать сообщения """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen(100)
    return sock


def recv_msg(sock):
    """ Ждем получения данных через сокет ,парсим используя b'\0' как разграничитель """
    data = bytearray()
    msg = ''
    ''' В цикле читаем 4096 байт из сокета сохраняя байты в data пока не наткнемся на разграничитель '''
  
    while not msg:
        recvd = sock.recv(4096)
        if not recvd:
            # Сокет закрылся преждемременно
            raise ConnectionError()
        data = data + recvd
        if b'\0' in recvd:
			''' Мы можем послать только 1 сообщение в соединении,поэтому  b'\0' всегда будет последным символом'''
            msg = data.rstrip(b'\0')
    msg = msg.decode('utf-8')
    return msg


def prep_msg(msg):
    """ Готовим строку для отсылки"""
    msg += '\0'
    return msg.encode('utf-8')


def send_msg(sock, msg):
    """ Посылаем строку через сокет,предварительно подготовив """
    data = prep_msg(msg)
    sock.sendall(data)
</content>
<print>

</print>
</item>

<item>
<id>452</id>
<menu>Networking</menu>
<submenu>Simple eventdriven chat server</submenu>
<title>Asincio server</title>
<content> 
import asyncio
import common

HOST = common.HOST
PORT = common.PORT

clients = []

class ChatServerProtocol(asyncio.Protocol):
    """ Each instance of class represents a client and the socket 
         connection to it. """

    def connection_made(self, transport):
        """ Called on instantiation, when new client connects """
        self.transport = transport
        self.addr = transport.get_extra_info('peername')
        self._rest = b''
        clients.append(self)
        print("Connection from " ,self.addr)

    def data_received(self, data):
        """ Handle data as it's received. Broadcast complete
        messages to all other clients """

        data += self._rest
        (msgs, rest) = common.parse_recv_data(data)
        self._rest = rest

        for msg in msgs:
            msg = msg.decode('utf-8')
            msg = '%s: %s' % (self.addr,msg)
            print(msg)
            msg = common.prep_msg(msg)

            for client in clients:
                client.transport.write(msg) # -- non-blocking


    def connection_lost(self, exc):
        """ Called on client disconnect. Clean up client state """
        print('Client %s disconnected'% (self.addr))
        clients.remove(self)


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    # Create server and initialize on the event loop
    coroutine = loop.create_server(ChatServerProtocol,host=HOST,port=PORT)

    server = loop.run_until_complete(coroutine)

    # print listening socket info

    for socket in server.sockets:
        addr = socket.getsockname()

    # Run the loop to process client connections
    loop.run_forever()
</content>
<print>

</print>
</item>

<item>
<id>453</id>
<menu>Networking</menu>
<submenu>Simple eventdriven chat server</submenu>
<title>Asyncio client</title>
<content> 
import socket, common
import sys, threading

host = 'localhost'
port = 10000
buf = 64


def handle_input(sock):
    """ Prompt user for message and send it to server """
    print("Type message, enter to send, 'q' to quit")
    while True:
        # Blocks
        msg = input()
        if msg == 'q':
            sock.shutdown(socket.SHUT_RDWR)
            sock.close()
            break
        try:
            # Block untill sent
            common.send_msg(sock, msg)
        except (BrokenPipeError, ConnectionError):
            break


if __name__ == '__main__':

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    print('\nConnected to {}:{}'.format(host, port))

    # Create thread for handling user input and message sending
    thread = threading.Thread(target=handle_input,args=[sock],daemon=True)
    thread.start()

    rest = bytes()
    addr = sock.getsockname()

    # Loop indefinitely to receive messages from server
    while True:
        try:
            #Blocks
            (msgs, rest) = common.recv_msgs(sock, rest)
            for msg in msgs:
                print(msg)

        except ConnectionError:
            print("Connection to server closed")
            sock.close()
            break 
</content>
<print>

</print>
</item>

<item>
<id>454</id>
<menu>Networking</menu>
<submenu>Simple eventdriven chat server</submenu>
<title>common</title>
<content> 
import socket
HOST = ''
PORT = 4040


def create_listen_socket(host, port):
    """ Setup the sockets our server will receive connection 
    requests on """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen(100)
    return sock


def recv_msgs(sock, data=bytes()):
    """ Receive data and break into complete messages on null byte
       delimiter. Block until at least one message received, then
       return received messages """
    msgs = []
    while not msgs:
        recvd = sock.recv(4096)
        if not recvd:
            raise ConnectionError()

        data +=recvd
        (msgs, rest) = parse_recv_data(data)
        msgs = [msg.decode('utf-8') for msg in msgs]
        return (msgs, rest)


def parse_recv_data(data):
    """ Break up raw received data into messages, delimited
        by null byte """
    parts = data.split(b'\0')
    msgs = parts[:-1]
    rest = parts[-1]
    return (msgs,rest)

def prep_msg(msg):
    """ Prepare a string to be sent as a message """
    msg += '\0'
    return msg.encode('utf-8')


def send_msg(sock, msg):
    """ Send a string over a socket, preparing it first """
    data = prep_msg(msg)
    sock.sendall(data)
</content>
<print>

</print>
</item>

<item>
<id>455</id>
<menu>Networking</menu>
<submenu>Simple broadcast chat server</submenu>
<title>Server</title>
<content> 
import threading, queue
import common

host = 'localhost'
port = 10000
buf = 64

send_queues = {}
lock = threading.Lock()


def handle_client_recv(sock, addr):
    """ Receive messages from client and broadcast them to
        other clients until client disconnects """
    rest = bytes()
    while True:
        try:
            (msgs, rest) = common.recv_msgs(sock, rest)

        except(ConnectionError, EOFError):
            handle_disconnect(sock, addr)
            break

        for msg in msgs:
            msg = '%s: %s' % (addr,msg)
            print(msg)
            broadcast_msg(msg)


def handle_client_send(sock, q, addr):
    """ Monitor queue for new messages, send them to client as
        they arrive """

    while True:
        msg = q.get()
        if msg == None:break

        try:
            common.send_msg(sock,msg)
        except (ConnectionError,BrokenPipeError):
            handle_disconnect(sock, addr)
            break


def broadcast_msg(msg):
    ''' Add message to each connected client's send queue '''
    with lock:
        for q in send_queues.values():
            q.put(msg)


def handle_disconnect(sock, addr):

    ''' Ensure queue is cleaned up and socket closed when a client disconnects '''
    fd = sock.fileno()

    with lock:

        ''' Get send queue for this client '''
        q = send_queues.get(fd, None)

    '''If we find a queue then this disconnect has not yet been handled'''
    if q:
        q.put(None)
        del send_queues[fd]
        addr = sock.getpeername()
        print('Client %s disconnected' % (addr))
        sock.close()


if __name__ == "__main__":
    sock = common.create_listen_socket(host, port)
    addr = sock.getsockname()

    while True:
        ''' accept incoming connection and get client socket and address '''
        conn, addr = sock.accept()
        q = queue.Queue()
        ''' use lock for thead safe operation with dic '''
        with lock:
            send_queues[conn.fileno()] = q

        recv_thread = threading.Thread(target=handle_client_recv,args=[conn, addr],daemon=True)
        send_thread = threading.Thread(target=handle_client_send,args=[conn, q, addr],daemon=True)

        recv_thread.start()
        send_thread.start()

        print('Connection from {}'.format(addr)) 
</content>
<print>

</print>
</item>

<item>
<id>456</id>
<menu>Networking</menu>
<submenu>Simple broadcast chat server</submenu>
<title>Client</title>
<content> 
import socket, common
import sys, threading

host = 'localhost'
port = 10000
buf = 64


def handle_input(sock):
    """ Prompt user for message and send it to server """
    print("Type message, enter to send, 'q' to quit")
    while True:
        # Blocks
        msg = input()
        if msg == 'q':
            sock.shutdown(socket.SHUT_RDWR)
            sock.close()
            break
        try:
            # Block untill sent
            common.send_msg(sock, msg)
        except (BrokenPipeError, ConnectionError):
            break


if __name__ == '__main__':

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    print('\nConnected to {}:{}'.format(host, port))

    # Create thread for handling user input and message sending
    thread = threading.Thread(target=handle_input,args=[sock],daemon=True)
    thread.start()

    rest = bytes()
    addr = sock.getsockname()

    # Loop indefinitely to receive messages from server
    while True:
        try:
            #Blocks
            (msgs, rest) = common.recv_msgs(sock, rest)
            for msg in msgs:
                print(msg)

        except ConnectionError:
            print("Connection to server closed")
            sock.close()
            break 
</content>
<print>

</print>
</item>

<item>
<id>457</id>
<menu>Networking</menu>
<submenu>Simple broadcast chat server</submenu>
<title>common</title>
<content> 
import socket
HOST = ''
PORT = 4040


def create_listen_socket(host, port):
    """ Setup the sockets our server will receive connection 
    requests on """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, port))
    sock.listen(100)
    return sock


def recv_msgs(sock, data=bytes()):
    """ Receive data and break into complete messages on null byte
       delimiter. Block until at least one message received, then
       return received messages """
    msgs = []
    while not msgs:
        recvd = sock.recv(4096)
        if not recvd:
            raise ConnectionError()

        data +=recvd
        (msgs, rest) = parse_recv_data(data)
        msgs = [msg.decode('utf-8') for msg in msgs]
        return (msgs, rest)


def parse_recv_data(data):
    """ Break up raw received data into messages, delimited
        by null byte """
    parts = data.split(b'\0')
    msgs = parts[:-1]
    rest = parts[-1]
    return (msgs,rest)

def prep_msg(msg):
    """ Prepare a string to be sent as a message """
    msg += '\0'
    return msg.encode('utf-8')


def send_msg(sock, msg):
    """ Send a string over a socket, preparing it first """
    data = prep_msg(msg)
    sock.sendall(data)
</content>
<print>

</print>
</item>

<item>
<id>458</id>
<menu>Время</menu>
<submenu>Таймеры</submenu>
<title>Простой таймер</title>
<content> 
import time
import os
sec=int(0)
mi=int(0)
chas=int(0)
if __name__ == "__main__":
    while 1==1:
        time.sleep(1)
        os.system('cls' if os.name == 'nt' else 'clear')
        print(chas,":",mi,":",sec)
        sec +=1
        if sec==60:
            mi=1
            sec=0
        if mi==60:
            chas=1
            mi=0
            sec=0
</content>
<print>

</print>
</item>

<item>
<id>459</id>
<menu>Файлы</menu>
<submenu>Расширеный функционал</submenu>
<title>Изменение файла</title>
<content> 
'''
main.txt
11111
11111
11111
'''

path = r'main.txt'
path1 = r'main1.txt'

with open(path) as f1, open(path1,mode='a') as f2:
    for line in f1:
        if line[:1] == '1':
            line = '222'+line[:-1]+'222\n'
        f2.write(line)
</content>
<print>
main1.txt

22211111222
22211111222
22211111222
</print>
</item>

<item>
<id>460</id>
<menu>Scikit-Learn</menu>
<submenu>Уроки</submenu>
<title>Классификация цветков Ириса методом KNN</title>
<content> 
# -*- coding:utf-8 -*-

from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

'''
Данные, которые мы будем использовать для этого примера–это набор данных  Iris классический  набор  данных  в  машинном  обучении  и статистике.
DESCR – это краткое описание набора данных
target_names – это массив строк, содержащий сорта цветов, которые мы хотим предсказать
feature_names – это список  строк с  описанием  каждого признака
Сами  данные записаны  в массивах target и data
'''
iris_dataset = load_iris()


'''
train_test_split -разбивает набор на тренировочные и тестовые данные в пропорции 75%/25%.random_state позволяет воспроизводить одинаковый результат
'''
X_train,X_test,y_train,y_test = train_test_split(iris_dataset['data'],iris_dataset['target'],random_state=0)


'''
создаем dataframe из данных в массиве X_train маркируем столбцы, используя строки в iris_dataset.feature_names
'''
iris_dataframe = pd.DataFrame(X_train,columns=iris_dataset.feature_names)


'''
Исследуем данные с помощью матрицы диаграмм рассеяния на которых будут изображены всевозможные пары признаков
создаем матрицу рассеяния из dataframe, цвет точек задаем с помощью y_train
'''
grr = pd.plotting.scatter_matrix(iris_dataframe, c=y_train, figsize=(15,15), marker = 'o', hist_kwds={'bins':40},s=30,alpha=.8)
plt.show()


'''
Пробуем классифицировать с помощью метода k ближайших соседей.У нас будет 1 сосед. knn хранит алгоритм для построения модели и алгоритм для генерации прогноза для новых данных
'''
knn = KNeighborsClassifier(n_neighbors=1)


'''
Для построения модели вызываем fit, который принимает в качестве аргументов массив X_train, y_train.Метод возвращает объект knn,в строковом представлении которого можно посмотреть какие параметры были использованы при создании модели
'''
print(knn.fit(X_train, y_train))


'''
Теперь можно получить прогнозы применив эту модель к новым данным
'''
X_new = np.array([[5, 2.9, 1, 0.2]])


'''
Чтобы сделать прогноз вызываем метод knn.predict()
'''
prediction = knn.predict(X_new)

print('Прогноз:',prediction)
print('Метка:',iris_dataset['target_names'][prediction])


'''
Оценим качество модели на тестовой выборке
'''
y_pred = knn.predict(X_test)
print("Правильность на тестовом выборке : %.2f" % np.mean(y_pred==y_test))
print("Правильность на тестовом выборке : %.2f" % knn.score(X_test,y_test))
</content>
<print>
KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
           metric_params=None, n_jobs=1, n_neighbors=5, p=2,
           weights='uniform')
Прогноз: [0]
Метка: ['setosa']
Правильность на тестовом выборке : 0.97
Правильность на тестовом выборке : 0.97
</print>
</item>

<item>
<id>461</id>
<menu>Machine Learning</menu>
<submenu>Основные определения</submenu>
<title>
Обычно в задаче анализа данных имеется некоторая прямоугольная таблица. Ее строки соответствуют объектам, а столбцы – признакам этих объектов. Объекты также называются наблюдениями или примерами (samples), а признаки – атрибутами (features).Признаки бывают количественными (как, например, доход в рублях или рост в сантиметрах и т.д.) или категориальными (как, например, марка автомобиля, модель телефона и т.д.).Один из признаков (столбцов) выделен. Этот признак называется ответом. Остальные признаки – входные. Требуется по имеющейся таблице научиться по новому объекту, которого нет в таблице, но для которого известны значения входных признаков, по возможности с небольшой ошибкой предсказывать значение выделенного признака (ответа).Если ответ количественный, то задача называется задачей восстановления регрессии. Если ответ категориальный, то задача называется задачей классификации.
</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>462</id>
<menu>Machine Learning</menu>
<submenu>Основные определения</submenu>
<title>Регуляризация в статистике, машинном обучении, теории обратных задач — метод добавления некоторой дополнительной информации к условию с целью решить некорректно поставленную задачу или предотвратить переобучение. Эта информация часто имеет вид штрафа за сложность модели.Простыми словами: Переобучение в большинстве случаев проявляется в том, что в получающихся многочленах слишком большие коэффициенты. Соответственно, и бороться с этим можно довольно естественным способом: нужно просто добавить в целевую функцию штраф, который бы наказывал модель за слишком большие коэффициенты.</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>463</id>
<menu>Machine Learning</menu>
<submenu>Основные определения</submenu>
<title>Есть  два  основные  задачи машинного обучения  с  учителем: классификация(classification) и регрессия(regression).
Цель классификации состоит  в  том,  чтобы спрогнозировать метку класса(class label),  которая представляет  собой  выбор  из  заранее определенного списка возможных вариантов. Классификация  иногда  разделяется  на бинарную классификацию (binary classification), которая является частным случаем разделения на два класса, и мультиклассовую классификацию (multiclass classification),когда  в  классификации участвует  более  двух классов. Бинарную классификацию можно представить как попытку ответить на поставленный вопрос в формате «да/нет».
В бинарной классификации мы часто говорим о том, что один класс является положительным(positive) классом, а другой класс является отрицательным(negative) классом. При этом «положительный» означает здесь не наличие выгоды (ценности), а  объект  исследования.
Цель регрессии состоит в том, чтобы спрогнозировать число. Прогнозирование годового дохода человека в зависимости  от  его образования,  возраста и места жительства,является  примером регрессионной  задачи. Прогнозируемое  значение дохода представляет собой сумму(amount) и  может  быть  любым числом в  заданном диапазоне.

Самый  простой  способ отличить классификацию от регрессии – спросить, заложена ли в полученном ответе определенная непрерывность(преемственность).  
Если полученные результаты непрерывно  связаны друг с другом, то решаемая задача является задачей регрессии. 
Возьмем прогнозирование годового дохода. Здесь  ясно  видна непрерывность ответа. Разница  между  годовым  доходом  в 40000$ или  40001$ не существенна, хотя  речь  идет  о разных  денежных суммах.Если  наш алгоритм предсказывает 39999$ или 40001$ , в то время как он должен предсказать 40000$(реальное значение годового дохода), мы не будем настаивать  на  том,  что  разница  существенна.
Наоборот,  в  задаче распознавании языка  веб-сайта  (задаче классификации)  ответы четко определены. Контент  сайта может  быть написан либо на  одном конкретном языке,либо на другом. Между языками нет непрерывной связи, не  существует  языка,  находящегося между  английским  и французским.
</title>
<content> 
</content>
<print>

</print>
</item>

<item>
<id>464</id>
<menu>Machine Learning</menu>
<submenu>Основные определения</submenu>
<title>Если модель может  выдавать точные  прогнозы  на ранее  не  встречавшихся данных,  мы  говорим,  что модель обладает  способностью обобщать (generalize)результат на тестовые данные. Нам необходимо построить модель, которая будет обладать максимальной обобщающей способностью .</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>465</id>
<menu>Machine Learning</menu>
<submenu>Основные определения</submenu>
<title>Переобучение(overfitting) - построение модели, которая слишком  сложна для имеющегося  у  нас  объема  информации. 
Переобучение происходит,  когда ваша модель слишком  точно  подстраивается  под особенности обучающего набора и вы получаете модель, которая хорошо работает на обучающем наборе,  но  не  умеет  обобщать результат  на новые  данные</title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>466</id>
<menu>Machine Learning</menu>
<submenu>Основные определения</submenu>
<title>Недообучение (underfitting) - выбор слишком простой модели </title>
<content> 
</content>
<print>
</print>
</item>

<item>
<id>467</id>
<menu></menu>
<submenu></submenu>
<title>Важно отметить, что сложность модели тесно связана с изменчивостью входных данных, содержащихся в вашем обучающем наборе: чем больше разнообразие точек данных в вашем наборе, тем более сложную модель можно использовать, не беспокоясь о переобучении. Обычно больший объем  данных  дает  большее  разнообразие, таким  образом,большие наборы  данных  позволяют  строить  более  сложные  модели. </title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>468</id>
<menu>Файлы</menu>
<submenu>Расширеный функционал</submenu>
<title>Чтение файла по несколько строк</title>
<content> 
def more(p,numlines=30):
    file = open(p)
    lines = file.readlines()

    while lines:
        chunk = lines[:numlines]
        lines = lines[numlines:]
        for line in chunk:
            print(line,end="")
        if lines and input('More? press enter to continue or type smth. to exit'):break

if __name__ == "__main__":
    more(path)
</content>
<print>

</print>
</item>

<item>
<id>469</id>
<menu>Разное</menu>
<submenu>os</submenu>
<title>Средства администрирования</title>
<content> 
# -*- coding:utf-8 -*-
import os

# числовой идентификатор процесса
print(os.getpid())

# текущий рабочий каталог
print(os.getcwd())

# смена каталога
os.chdir(r'D:\DISTR')
print(os.getcwd())

print(os.pathsep, os.sep, os.pardir, os.curdir)

# os.linesep возвращает последовательность символов \r\n
</content>
<print>
4792
D:\Projects\ex2
D:\DISTR
; \ .. .
</print>
</item>

<item>
<id>470</id>
<menu>Разное</menu>
<submenu>os</submenu>
<title>Инструменты модуля os</title>
<content> 
Переменные окружения	os.environ

Запуск программ		os.system, os.popen, os.execv, os.spawnv

Порождение дочерних процессов	os.fork, os.pipe, os.waitpid, os.kill

Дескрипторы файлов, блокировки	os.open, os.read, os.write

Обработка файлов	os.remove, os.rename, os.mkfifo, os.mkdir,os.rmdir

Инструменты администрирования	os.getcwd, os.chdir, os.chmod, os.getpid,os.listdir, os.access

Инструменты обеспечения переносимости	os.sep, os.pathsep, os.curdir, os.path.split,os.path.join

Инструменты для работы с путями к каталогам		os.path.exists('path'), os.path.isdir('path'), os.path.getsize('path')
</content>
<print>

</print>
</item>

<item>
<id>471</id>
<menu>Разное</menu>
<submenu>os</submenu>
<title>Основные инструменты os.path</title>
<content> 
# -*- coding:utf-8 -*-
import os

print('Проверка каталога: ', os.path.isdir(r'C:\Users'))

print('Проверка файла: ', os.path.isfile(r'C:\Users'))

print('Проверка пути: ', os.path.exists(r'C:\Windows\System32'))

print('Получение размера файла: ', os.path.getsize(r'C:\Windows\regedit.exe'))

print('Отделение имени файла от пути: ',os.path.split(r'C:\Windows\System32\regedit.exe'))

print('Объединение имени файла и пути: ',os.path.join(r'C:\temp', 'output.txt'))

name = '/home/lutz/temp/data.txt'
print('Путь в стиле Unix:', os.path.dirname(name),' файл:', os.path.basename(name))

print("Отделение расширения файла:",os.path.splitext(r'C:\PP4E\PyDemos.pyw'))
</content>
<print>
Проверка каталога:  True
Проверка файла:  False
Проверка пути:  True
Получение размера файла:  398336
Отделение имени файла от пути:  ('C:\\Windows\\System32', 'regedit.exe')
Объединение имени файла и пути:  C:\temp\output.txt
Путь в стиле Unix: /home/lutz/temp  файл: data.txt
Отделение расширения файла: ('C:\\PP4E\\PyDemos', '.pyw')
</print>
</item>

<item>
<id>472</id>
<menu>Разное</menu>
<submenu>os</submenu>
<title>Основные инструменты os.path - 2</title>
<content> 
# -*- coding:utf-8 -*-
import os

pathname = r'C:\PP4thEd\Examples\PP4E\PyDemos.pyw'

print("Разбиение пути по слешу:",pathname.split(os.sep))

print(os.sep.join(pathname.split(os.sep)))

print('Возврат текущего каталога:',os.path.abspath(''))

print('Добавление к текущему пути:',os.path.abspath('temp'))

print('Изменение пути:',os.path.abspath(r'C:\temp'))

print('Расширение относит. путей:',os.path.abspath(r'.\temp'))

print('Расширение относит. путей:',os.path.abspath(r'..\temp'))
</content>
<print>
Разбиение пути по слешу: ['C:', 'PP4thEd', 'Examples', 'PP4E', 'PyDemos.pyw']
C:\PP4thEd\Examples\PP4E\PyDemos.pyw
Возврат текущего каталога: D:\Projects\ex2
Добавление к текущему пути: D:\Projects\ex2\temp
Изменение пути: C:\temp
Расширение относит. путей: D:\Projects\ex2\temp
Расширение относит. путей: D:\Projects\temp
</print>
</item>

<item>
<id>473</id>
<menu>Разное</menu>
<submenu>os</submenu>
<title>Выполнение команд оболочки из сценариев</title>
<content> 
# -*- coding:utf-8 -*-
import subprocess

# запустит программу на языке Python
os.system('python helloshell.py')

subprocess.call('python helloshell.py')

# Запуск через встроеные команды
subprocess.call('type helloshell.py', shell=True)

# Открыть страничку в браузере
os.startfile('webpage.html') 

# Открыть файл в Word
os.startfile('document.doc') 

# Запустить скрипт в python
os.startfile('myscript.py')

</content>
<print>

</print>
</item>

<item>
<id>474</id>
<menu>Разное</menu>
<submenu>os</submenu>
<title>os.environ</title>
<content> 
import os

print(list(os.environ.keys()))
print(os.environ['COMPUTERNAME'])
</content>
<print>
['ALLUSERSPROFILE', 'APPDATA', 'COMMONPROGRAMFILES', 'COMMONPROGRAMFILES(X86)', 'COMMONPROGRAMW6432', 'COMPUTERNAME', 'COMSPEC', 'FP_NO_HOST_CHECK', 'HOMEDRIVE', 'HOMEPATH', 'LOCALAPPDATA', 'LOGONSERVER', 'NUMBER_OF_PROCESSORS', 'OS', 'PATH', 'PATHEXT', 'PROCESSOR_ARCHITECTURE', 'PROCESSOR_ARCHITEW6432', 'PROCESSOR_IDENTIFIER', 'PROCESSOR_LEVEL', 'PROCESSOR_REVISION', 'PROGRAMDATA', 'PROGRAMFILES', 'PROGRAMFILES(X86)', 'PROGRAMW6432', 'PSMODULEPATH', 'PUBLIC', 'PYCHARM_HOSTED', 'PYTHONIOENCODING', 'PYTHONPATH', 'PYTHONUNBUFFERED', 'SESSIONNAME', 'SYSTEMDRIVE', 'SYSTEMROOT', 'TEMP', 'TMP', 'USERDOMAIN', 'USERNAME', 'USERPROFILE', 'VBOX_MSI_INSTALL_PATH', 'WINDIR', 'WINDOWS_TRACING_FLAGS', 'WINDOWS_TRACING_LOGFILE']
ADMIN-ПК
</print>
</item>

<item>
<id>475</id>
<menu>Файлы</menu>
<submenu>Базовые операции</submenu>
<title>Возврат в начало файла</title>
<content> 
file.seek(0)
</content>
<print>

</print>
</item>

<item>
<id>476</id>
<menu>Разное</menu>
<submenu>os</submenu>
<title>Переименование/удаление файла,просмотр каталога</title>
<content> 
# -*- coding:utf-8 -*-
import os

'''
Переименование файла, если путь совпадает и перемещение если нет
'''
# os.rename(os.getcwd()+r'\eggs.txt', os.getcwd()+r'\eggs.txt')

# Удаление файла
# os.remove(r'C:\temp\eggs.txt')

# Просмотр содержимого каталога
print("Просмотр содержимого каталога: ",os.listdir(os.getcwd()))
</content>
<print>

</print>
</item>

<item>
<id>477</id>
<menu>Файлы</menu>
<submenu>Расширеный функционал</submenu>
<title>Получить абсолютный путь файлов в каталоге</title>
<content> 
# -*- coding:utf-8 -*-
import glob,os

for file in glob.glob(os.getcwd() + '/*'):
    print(file)
</content>
<print>
D:\Den\Projects\ex2\ex2
D:\Den\Projects\ex2\ex2.pdf
D:\Den\Projects\ex2\ex2_logistic_regression.py
D:\Den\Projects\ex2\main1.txt
D:\Den\Projects\ex2\ss.py
</print>
</item>

<item>
<id>478</id>
<menu>Файлы</menu>
<submenu>Расширеный функционал</submenu>
<title>Обход каталогов</title>
<content> 
# -*- coding:utf-8 -*-
import os

# Можно подставить вместо '.' любой путь, 'C:'
for (dirname, subshere, fileshere) in os.walk('.'):
    print('[' + dirname + ']')
    for fname in fileshere:
        print(os.path.join(dirname, fname))
</content>
<print>
[.]
.\ex2.pdf
.\ex2_logistic_regression.py
.\main1.txt
.\ss.py
[.\ex2]
.\ex2\costFunction.m
.\ex2\costFunctionReg.m
.\ex2\ex2.m
.\ex2\ex2data1.txt
.\ex2\ex2data2.txt
.\ex2\ex2_reg.m
</print>
</item>

<item>
<id>479</id>
<menu>Файлы</menu>
<submenu>Расширеный функционал</submenu>
<title>Поиск слова в определенном типе файлов</title>
<content> 
# -*- coding:utf-8 -*-
import os

matches = []
for (dirname, dirshere, fileshere) in os.walk(r'.'):
    for filename in fileshere:
        if filename.endswith('.py'):
            print(filename)
            pathname = os.path.join(dirname, filename)
            if 'mimetypes' in open(pathname).read():
                matches.append(pathname)

for name in matches: print(name)
</content>
<print>
.\ss.py
</print>
</item>

<item>
<id>480</id>
<menu>Файлы</menu>
<submenu>Расширеный функционал</submenu>
<title>Обход каталогов - 2</title>
<content> 
# -*- coding:utf-8 -*-
import sys, os

def mylister(currdir):
    print('[' + currdir + ']')
    # генерирует список файлов
    for file in os.listdir(currdir):       
        # добавить путь к каталогу
        path = os.path.join(currdir, file) 
        if not os.path.isdir(path):
            print(path)
        else:
            # рекурсивный спуск в подкаталоги
            mylister(path)                 
if __name__ == '__main__':
    mylister(os.getcwd())
</content>
<print>
[D:\Den\Projects\Coursera-Machine_Learning_Andrew_Ng_in_Python\ex2]
[D:\Den\Projects\Coursera-Machine_Learning_Andrew_Ng_in_Python\ex2\ex2]
D:\Den\Projects\Coursera-Machine_Learning_Andrew_Ng_in_Python\ex2\ex2\costFunction.m
D:\Den\Projects\Coursera-Machine_Learning_Andrew_Ng_in_Python\ex2\ex2\costFunctionReg.m
D:\Den\Projects\Coursera-Machine_Learning_Andrew_Ng_in_Python\ex2\ex2\ex2.m
D:\Den\Projects\Coursera-Machine_Learning_Andrew_Ng_in_Python\ex2\ex2\ex2data1.txt
D:\Den\Projects\Coursera-Machine_Learning_Andrew_Ng_in_Python\ex2\ex2\ex2data2.txt
D:\Den\Projects\Coursera-Machine_Learning_Andrew_Ng_in_Python\ex2\ex2\ex2_reg.m
</print>
</item>

<item>
<id>481</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Создание словаря - defaultdict</title>
<content> 
from collections import defaultdict

d = defaultdict(int)
d["key"] +=1

print(d)

d["key"] +=1

print(d)

dd = defaultdict(list)
dd[1].append("val")
dd[1].append("val1")

print(dd)

ddd = defaultdict(dict)
ddd['one']['two'] = 'three'
ddd['one']['three'] = 'four'
ddd['two']['five'] = 'six'

print(ddd)

dddd = defaultdict(lambda :[0, 0])
dddd[2][1] = 3
dddd[2][0] = 7

print(dddd)
</content>
<print>
defaultdict(class 'int', {'key': 1})
defaultdict(class 'int', {'key': 2})
defaultdict(class 'list', {1: ['val', 'val1']})
defaultdict(class 'dict', {'one': {'two': 'three', 'three': 'four'}, 'two': {'five': 'six'}})
defaultdict(function  at 0x0028C618, {2: [7, 3]})
</print>
</item>

<item>
<id>482</id>
<menu>Словари</menu>
<submenu>Базовые операции</submenu>
<title>Создание словаря - Counter</title>
<content> 
from collections import Counter

c = Counter([1,2,3,4])

print(c)

c[1] = 2

print(c)

c[5] = 4

print(c)
</content>
<print>
Counter({1: 1, 2: 1, 3: 1, 4: 1})
Counter({1: 2, 2: 1, 3: 1, 4: 1})
Counter({5: 4, 1: 2, 2: 1, 3: 1, 4: 1})
</print>
</item>

<item>
<id>483</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>484</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>485</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>486</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>487</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>488</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>489</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>490</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>491</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>492</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>493</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>494</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>495</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>496</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>497</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>498</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>499</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id>500</id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

<item>
<id></id>
<menu></menu>
<submenu></submenu>
<title></title>
<content> 

</content>
<print>

</print>
</item>

</data>