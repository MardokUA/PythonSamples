<?xml version="1.0" encoding="UTF-8"?>
<data>
<item>
<title>Вычитание классов и чисел - __del__</title>
<content> 
class Number:
	# Вызов Number(start)
    def __init__(self, start):           
        self.data = start
		
	# Выражение: экземпляр - other
    def __sub__(self, other):            
		# Результат – новый экземпляр
        return Number(self.data - other)
		# Результат – число
		#return self.data - other 
# Number.__init__(X, 5)
X = Number(5)
# Number.__sub__(X, 2) 
Y = X - 2 
# Y - новый экземпляр класса Number
print(Y.data) 
# Результат – число
#print(X - 2) 
</content>
<print>
3
</print>
</item> 
<item>
<title>Вычитание классов - __del__</title>
<content>
class Number:
	# Вызов Number(start)
    def __init__(self, start):           
        self.data = start
	# Выражение: экземпляр - other
    def __sub__(self, other):            
		# Результат – новый экземпляр
        #return Number(self.data - other.data)
		# Результат – число
        return self.data - other.data 	 
# Number.__init__(X, 5)
X = Number(5) 
Y = Number(3)
Z = X - Y
# Z - новый экземпляр класса Number
#print(Z.data)	
# Результат – число
print(X - Y)	
</content>
<print>
1 4 9 16 25 
</print>
</item> 
<item>
<title>Проверка на вхождение:__contains__, __iter__ и __getitem__</title>
<content> 
class Iters:
    def __init__(self, value):
        self.data = value
	'''
	Крайний случай для итераций
	А также для индексирования и срезов
	'''
    def __getitem__(self, i):           
        print('get[%s]:' % i, end='')   
        return self.data[i]
	'''
	Предпочтительный для итераций
	Возможен только 1 активный итератор
	'''
    def __iter__(self):                 
        print('iter=> ', end='')        
        self.ix = 0
        return self
    def __next__(self):
        print('next:', end='')
        if self.ix == len(self.data): raise StopIteration
        item = self.data[self.ix]
        self.ix += 1
        return item
	
	# Предпочтительный для оператора 'in'
    def __contains__(self, x):         
        print('contains: ', end='')
        return x in self.data
# Создать экземпляр
X = Iters([1, 2, 3, 4, 5])             
# Проверка на вхождение
print(3 in X)                          
for i in X:                            
    print(i, end=' | ')
print()
print([i ** 2 for i in X])             
print( list(map(bin, X)) )
'''
Обход вручную (именно так действуют
другие итерационные контексты)
'''
I = iter(X)                             
while True:                             
    try:
        print(next(I), end=' @ ')
    except StopIteration:
        break
</content>
<print>
contains: True
iter=> next:1 | next:2 | next:3 | next:4 | next:5 | next:
iter=> next:next:next:next:next:next:[1, 4, 9, 16, 25]
iter=> next:next:next:next:next:next:['0b1', '0b10', '0b11', '0b100', '0b101']
iter=> next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:
</print>
</item> 
<item>
<title>Обращения к атрибутам: __getattr__ и __setattr__</title>
<content> 
class Privacy:
	# Вызывается self.attrname = value
    def __setattr__(self, attrname, value): 
            print('Setting: ' + attrname + '->' , value)
			
			# Self.attrname = value
            self.__dict__[attrname] = value 
	
	'''
	__getattr__(self, name) будет вызван в случае,
	если запрашиваемый атрибут не найден обычным механизмом 
	(в __dict__ экземпляра, класса и т.д.)
	'''
    def __getattr__(self, item):    
        print('Getting: ' + item)    
        return item
    def __str__(self):
        return str(self.age)+ ' '+ self.name
class Test1(Privacy):
    pass
x = Test1()
x.age = 40
x.name = 'Bob'
print(x)
print(x.new_attr)
</content>
<print>
Setting: age-> 40
Setting: name-> Bob
40 Bob
Getting: new_attr
new_attr
</print>
</item> 
<item>
<title>
Строковое представление объектов: __repr__ и __str__
</title>
<content> 
class adder:
	# Инициализировать атрибут data
    def __init__(self, value=0):
        self.data = value 
'''
__repr__ используется везде, за исключением функций print и st
Однако, если метод __str__ отсутствует, операции вывода будут
использовать метод __repr__, но не наоборот
'''
	class addrepr(adder): # Наследует __init__, __add__
	
	# Добавляет строковое представление
	def __repr__(self): 
		
		# Преобразует в строку программного кода
        return 'addrepr(%s)' % self.data 
                                            
	# есть __str__, но нет __repr__
    # def __str__(self):  
		# Преобразовать в красивую строку
    #     return '[Value: % s]' % self.data  
# Формат отображения по умолчанию
x = adder() 
print(x)
# Вызовет __init__
x = addrepr(2)
# Вызовет __str__ , если нет __str__ вызовет __repr__ 
print(x) 
</content>
<print>
add 88 1
radd 99 1
add 88 __main__.Commuter object at 0x005113F0
radd 99 88
</print>
</item> 
<item>
<title>Комбинированная операция сложения __iadd__</title>
<content> 
class Number:
    def __init__(self, val):
        self.val = val
		
	# __iadd__ явно реализует операцию x += y
    def __iadd__(self, other): 
        self.val += other 
		
		# Обычно возвращает self
        return self
		
x = Number(5)
x += 1
x += 1
print(x.val)
class Number:
    def __init__(self, val):
        self.val = val
	
	# __add__ - как крайнее средство: x=(x + y)
	def __add__(self, other): 
        return Number(self.val + other) 
x = Number(5)
x += 1
x += 1
print(x.val)
</content>
<print>
Called: (1, 2, 3) {}
Called: (1, 2, 3) {'x': 4, 'y': 5}
</print>
</item> 
<item>
<title>Сравнение: __lt__, __gt__ и другие</title>
<content> 
class C:
    data = 'spam'
	
    def __gt__(self, other):
        print('__gt__')
        return self.data > other
    def __lt__(self, other):
        print('__lt__')
        return self.data &lt; other
X = C()
# Выведет True (вызовет __gt__)
print(X > 'ham')               
# Выведет False (вызовет __lt__)
print(X &lt; 'ham')               
</content>
<print>
__gt__
True
__lt__
False
</print>
</item> 
<item>
<title>Проверка логического значения:__bool__ и __len__</title>
<content> 
'''
Интерпретатор сначала пытается напрямую получить логическое значение с помощью метода __bool__ и только потом, если этот метод не реализован, пытается вызвать метод __len__ , чтобы выяснить истинность объекта, исходя из его длины
'''
class Truth:
    data = [1, 2, 3, 4]
	
	# первым выполняется __bool__
	# если нет __bool__ выполняется __len__
    def __bool__(self):
        return False        
                            
	'''
	находится длина строки и определяется инстинность либо
	просто находится длина объекта
	'''
    def __len__(self):
        return len(self.data)
                            
                            
X = Truth()
if not X:print('Not X')
print(len(X))
</content>
<print>
Not X
4
</print>
</item> 
<item>
<title>Уничтожение объектов: __del__</title>
<content> 
class Life:
    def __init__(self, name='unknown'):
        print ('Hello', name)
        self.name = name
        
    def __del__(self):
        print('Goodbye', self.name)
brian = Life('Brian')
brian = None
</content>
<print>
Hello Brian
Goodbye Brian
</print>
</item> 
</data>